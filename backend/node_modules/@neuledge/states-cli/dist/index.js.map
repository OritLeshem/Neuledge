{"version":3,"sources":["../src/index.ts","../../../node_modules/tsup/assets/cjs_shims.js","../src/generate.ts","../src/error.ts"],"sourcesContent":["import { Command } from 'commander';\nimport { readFileSync } from 'node:fs';\nimport { setGenerateCommand } from './generate';\nimport { catchExceptions } from './error';\n\nconst { version }: { version: string } = JSON.parse(\n  readFileSync(new URL('../package.json', import.meta.url)).toString(),\n);\n\nexport const createProgram = () => {\n  const program = new Command();\n\n  setProgram(program);\n  setGenerateCommand(program);\n\n  catchExceptions();\n\n  return program;\n};\n\nconst setProgram = (program: Command) =>\n  program\n    .name('states')\n    .description('CLI to build and compile `.states` files')\n    .version(version, '-v, --version', 'output the current version');\n","// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL('file:' + __filename).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","import fs from 'node:fs/promises';\nimport { resolve } from 'node:path';\nimport fg from 'fast-glob';\nimport { StatesContext } from '@neuledge/states';\nimport { generate } from '@neuledge/typescript-states';\nimport pLimit from 'p-limit';\nimport { Command } from 'commander';\n\nexport const setGenerateCommand = (program: Command) =>\n  program\n    .command('generate', { isDefault: true })\n    .description(\n      'Convert `.states` files to TypeScript files (default command)',\n    )\n    .argument('<files...>', 'files to build')\n    .option('-P, --basepath <path>', 'base path')\n    .option('-O, --output <file>', 'output ts file')\n    .action(action);\n\ninterface BuildOptions {\n  basepath?: string;\n  output?: string;\n}\n\nexport { action as __test_action };\n\nconst action = async (\n  files: string[],\n  options: BuildOptions,\n): Promise<void> => {\n  const resolvedFiles = await resolveFiles(files, options.basepath);\n  const asyncLimit = pLimit(10);\n\n  const inputs = await Promise.all(\n    resolvedFiles.map((filepath) =>\n      asyncLimit(async () => ({\n        source: await fs.readFile(filepath, { encoding: 'utf8' }),\n        filepath,\n      })),\n    ),\n  );\n\n  const ctx = new StatesContext();\n  await ctx.load(inputs);\n\n  const outputFile = resolve(\n    options.basepath ?? '',\n    options.output || 'states.ts',\n  );\n\n  await fs.writeFile(outputFile, generate(ctx));\n};\n\nconst resolveFiles = async (\n  files: string[],\n  basepath?: string,\n): Promise<string[]> => {\n  const staticFiles = [];\n  const dynamicFiles = [];\n\n  for (const file of files) {\n    if (fg.isDynamicPattern(file)) {\n      dynamicFiles.push(file);\n    } else {\n      staticFiles.push(file);\n    }\n  }\n\n  return [\n    ...staticFiles,\n    ...(await fg(dynamicFiles, {\n      cwd: basepath,\n      onlyFiles: true,\n      unique: true,\n    })),\n  ].map((file) => resolve(basepath ?? '', file));\n};\n","import fs from 'node:fs';\n\nexport const catchExceptions = () =>\n  process.on('uncaughtException', (err) => errorHandler(err));\n\nconst errorHandler = (err: unknown, code = 1): never => {\n  fs.writeSync(process.stderr.fd, String((err as Error)?.stack || err) + '\\n');\n\n  // eslint-disable-next-line unicorn/no-process-exit\n  process.exit(code);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;ACKA,IAAMA,mBAAmB,6BACvB,OAAOC,aAAa,cAChB,IAAIC,IAAI,UAAUC,UAAAA,EAAYC,OAC7BH,SAASI,iBAAiBJ,SAASI,cAAcC,OAClD,IAAIJ,IAAI,WAAWD,SAASM,OAAO,EAAEH,MAJlB;AAMlB,IAAMI,gBAAgCR,iCAAAA;;;ADX7C,uBAAwB;AACxB,IAAAS,kBAA6B;;;AED7B,sBAAe;AACf,uBAAwB;AACxB,uBAAe;AACf,oBAA8B;AAC9B,+BAAyB;AACzB,qBAAmB;AAGZ,IAAMC,qBAAqB,wBAACC,YACjCA,QACGC,QAAQ,YAAY;EAAEC,WAAW;AAAK,CAAA,EACtCC,YACC,+DAAA,EAEDC,SAAS,cAAc,gBAAA,EACvBC,OAAO,yBAAyB,WAAA,EAChCA,OAAO,uBAAuB,gBAAA,EAC9BC,OAAOA,MAAAA,GATsB;AAkBlC,IAAMC,SAAS,8BACbC,OACAC,YACkB;AAClB,QAAMC,gBAAgB,MAAMC,aAAaH,OAAOC,QAAQG,QAAQ;AAChE,QAAMC,iBAAaC,eAAAA,SAAO,EAAA;AAE1B,QAAMC,SAAS,MAAMC,QAAQC,IAC3BP,cAAcQ,IAAI,CAACC,aACjBN,WAAW,aAAa;IACtBO,QAAQ,MAAMC,gBAAAA,QAAGC,SAASH,UAAU;MAAEI,UAAU;IAAO,CAAA;IACvDJ;EACF,EAAA,CAAA,CAAA;AAIJ,QAAMK,MAAM,IAAIC,4BAAAA;AAChB,QAAMD,IAAIE,KAAKX,MAAAA;AAEf,QAAMY,iBAAaC,0BACjBnB,QAAQG,YAAY,IACpBH,QAAQoB,UAAU,WAAA;AAGpB,QAAMR,gBAAAA,QAAGS,UAAUH,gBAAYI,mCAASP,GAAAA,CAAAA;AAC1C,GAzBe;AA2Bf,IAAMb,eAAe,8BACnBH,OACAI,aACsB;AACtB,QAAMoB,cAAc,CAAA;AACpB,QAAMC,eAAe,CAAA;AAErB,aAAWC,QAAQ1B,OAAO;AACxB,QAAI2B,iBAAAA,QAAGC,iBAAiBF,IAAAA,GAAO;AAC7BD,mBAAaI,KAAKH,IAAAA;IACpB,OAAO;AACLF,kBAAYK,KAAKH,IAAAA;IACnB;EACF;AAEA,SAAO;OACFF;OACC,UAAMG,iBAAAA,SAAGF,cAAc;MACzBK,KAAK1B;MACL2B,WAAW;MACXC,QAAQ;IACV,CAAA;IACAtB,IAAI,CAACgB,aAASN,0BAAQhB,YAAY,IAAIsB,IAAAA,CAAAA;AAC1C,GAvBqB;;;ACrDrB,qBAAe;AAER,IAAMO,kBAAkB,6BAC7BC,QAAQC,GAAG,qBAAqB,CAACC,QAAQC,aAAaD,GAAAA,CAAAA,GADzB;AAG/B,IAAMC,eAAe,wBAACD,KAAcE,OAAO,MAAa;AACtDC,iBAAAA,QAAGC,UAAUN,QAAQO,OAAOC,IAAIC,OAAQP,KAAeQ,SAASR,GAAAA,IAAO,IAAA;AAGvEF,UAAQW,KAAKP,IAAAA;AACf,GALqB;;;AHArB,IAAM,EAAEQ,QAAO,IAA0BC,KAAKC,UAC5CC,8BAAa,IAAIC,IAAI,mBAAmB,aAAe,CAAA,EAAGC,SAAQ,CAAA;AAG7D,IAAMC,gBAAgB,6BAAM;AACjC,QAAMC,UAAU,IAAIC,yBAAAA;AAEpBC,aAAWF,OAAAA;AACXG,qBAAmBH,OAAAA;AAEnBI,kBAAAA;AAEA,SAAOJ;AACT,GAT6B;AAW7B,IAAME,aAAa,wBAACF,YAClBA,QACGK,KAAK,QAAA,EACLC,YAAY,0CAAA,EACZb,QAAQA,SAAS,iBAAiB,4BAAA,GAJpB;","names":["getImportMetaUrl","document","URL","__filename","href","currentScript","src","baseURI","importMetaUrl","import_node_fs","setGenerateCommand","program","command","isDefault","description","argument","option","action","action","files","options","resolvedFiles","resolveFiles","basepath","asyncLimit","pLimit","inputs","Promise","all","map","filepath","source","fs","readFile","encoding","ctx","StatesContext","load","outputFile","resolve","output","writeFile","generate","staticFiles","dynamicFiles","file","fg","isDynamicPattern","push","cwd","onlyFiles","unique","catchExceptions","process","on","err","errorHandler","code","fs","writeSync","stderr","fd","String","stack","exit","version","JSON","parse","readFileSync","URL","toString","createProgram","program","Command","setProgram","setGenerateCommand","catchExceptions","name","description"]}