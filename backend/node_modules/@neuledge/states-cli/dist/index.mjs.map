{"version":3,"sources":["../src/index.ts","../src/generate.ts","../src/error.ts"],"sourcesContent":["import { Command } from 'commander';\nimport { readFileSync } from 'node:fs';\nimport { setGenerateCommand } from './generate';\nimport { catchExceptions } from './error';\n\nconst { version }: { version: string } = JSON.parse(\n  readFileSync(new URL('../package.json', import.meta.url)).toString(),\n);\n\nexport const createProgram = () => {\n  const program = new Command();\n\n  setProgram(program);\n  setGenerateCommand(program);\n\n  catchExceptions();\n\n  return program;\n};\n\nconst setProgram = (program: Command) =>\n  program\n    .name('states')\n    .description('CLI to build and compile `.states` files')\n    .version(version, '-v, --version', 'output the current version');\n","import fs from 'node:fs/promises';\nimport { resolve } from 'node:path';\nimport fg from 'fast-glob';\nimport { StatesContext } from '@neuledge/states';\nimport { generate } from '@neuledge/typescript-states';\nimport pLimit from 'p-limit';\nimport { Command } from 'commander';\n\nexport const setGenerateCommand = (program: Command) =>\n  program\n    .command('generate', { isDefault: true })\n    .description(\n      'Convert `.states` files to TypeScript files (default command)',\n    )\n    .argument('<files...>', 'files to build')\n    .option('-P, --basepath <path>', 'base path')\n    .option('-O, --output <file>', 'output ts file')\n    .action(action);\n\ninterface BuildOptions {\n  basepath?: string;\n  output?: string;\n}\n\nexport { action as __test_action };\n\nconst action = async (\n  files: string[],\n  options: BuildOptions,\n): Promise<void> => {\n  const resolvedFiles = await resolveFiles(files, options.basepath);\n  const asyncLimit = pLimit(10);\n\n  const inputs = await Promise.all(\n    resolvedFiles.map((filepath) =>\n      asyncLimit(async () => ({\n        source: await fs.readFile(filepath, { encoding: 'utf8' }),\n        filepath,\n      })),\n    ),\n  );\n\n  const ctx = new StatesContext();\n  await ctx.load(inputs);\n\n  const outputFile = resolve(\n    options.basepath ?? '',\n    options.output || 'states.ts',\n  );\n\n  await fs.writeFile(outputFile, generate(ctx));\n};\n\nconst resolveFiles = async (\n  files: string[],\n  basepath?: string,\n): Promise<string[]> => {\n  const staticFiles = [];\n  const dynamicFiles = [];\n\n  for (const file of files) {\n    if (fg.isDynamicPattern(file)) {\n      dynamicFiles.push(file);\n    } else {\n      staticFiles.push(file);\n    }\n  }\n\n  return [\n    ...staticFiles,\n    ...(await fg(dynamicFiles, {\n      cwd: basepath,\n      onlyFiles: true,\n      unique: true,\n    })),\n  ].map((file) => resolve(basepath ?? '', file));\n};\n","import fs from 'node:fs';\n\nexport const catchExceptions = () =>\n  process.on('uncaughtException', (err) => errorHandler(err));\n\nconst errorHandler = (err: unknown, code = 1): never => {\n  fs.writeSync(process.stderr.fd, String((err as Error)?.stack || err) + '\\n');\n\n  // eslint-disable-next-line unicorn/no-process-exit\n  process.exit(code);\n};\n"],"mappings":";;;;AAAA,SAASA,eAAe;AACxB,SAASC,oBAAoB;;;ACD7B,OAAOC,QAAQ;AACf,SAASC,eAAe;AACxB,OAAOC,QAAQ;AACf,SAASC,qBAAqB;AAC9B,SAASC,gBAAgB;AACzB,OAAOC,YAAY;AAGZ,IAAMC,qBAAqB,wBAACC,YACjCA,QACGC,QAAQ,YAAY;EAAEC,WAAW;AAAK,CAAA,EACtCC,YACC,+DAAA,EAEDC,SAAS,cAAc,gBAAA,EACvBC,OAAO,yBAAyB,WAAA,EAChCA,OAAO,uBAAuB,gBAAA,EAC9BC,OAAOA,MAAAA,GATsB;AAkBlC,IAAMC,SAAS,8BACbC,OACAC,YACkB;AAClB,QAAMC,gBAAgB,MAAMC,aAAaH,OAAOC,QAAQG,QAAQ;AAChE,QAAMC,aAAaC,OAAO,EAAA;AAE1B,QAAMC,SAAS,MAAMC,QAAQC,IAC3BP,cAAcQ,IAAI,CAACC,aACjBN,WAAW,aAAa;IACtBO,QAAQ,MAAMC,GAAGC,SAASH,UAAU;MAAEI,UAAU;IAAO,CAAA;IACvDJ;EACF,EAAA,CAAA,CAAA;AAIJ,QAAMK,MAAM,IAAIC,cAAAA;AAChB,QAAMD,IAAIE,KAAKX,MAAAA;AAEf,QAAMY,aAAaC,QACjBnB,QAAQG,YAAY,IACpBH,QAAQoB,UAAU,WAAA;AAGpB,QAAMR,GAAGS,UAAUH,YAAYI,SAASP,GAAAA,CAAAA;AAC1C,GAzBe;AA2Bf,IAAMb,eAAe,8BACnBH,OACAI,aACsB;AACtB,QAAMoB,cAAc,CAAA;AACpB,QAAMC,eAAe,CAAA;AAErB,aAAWC,QAAQ1B,OAAO;AACxB,QAAI2B,GAAGC,iBAAiBF,IAAAA,GAAO;AAC7BD,mBAAaI,KAAKH,IAAAA;IACpB,OAAO;AACLF,kBAAYK,KAAKH,IAAAA;IACnB;EACF;AAEA,SAAO;OACFF;OACC,MAAMG,GAAGF,cAAc;MACzBK,KAAK1B;MACL2B,WAAW;MACXC,QAAQ;IACV,CAAA;IACAtB,IAAI,CAACgB,SAASN,QAAQhB,YAAY,IAAIsB,IAAAA,CAAAA;AAC1C,GAvBqB;;;ACrDrB,OAAOO,SAAQ;AAER,IAAMC,kBAAkB,6BAC7BC,QAAQC,GAAG,qBAAqB,CAACC,QAAQC,aAAaD,GAAAA,CAAAA,GADzB;AAG/B,IAAMC,eAAe,wBAACD,KAAcE,OAAO,MAAa;AACtDC,EAAAA,IAAGC,UAAUN,QAAQO,OAAOC,IAAIC,OAAQP,KAAeQ,SAASR,GAAAA,IAAO,IAAA;AAGvEF,UAAQW,KAAKP,IAAAA;AACf,GALqB;;;AFArB,IAAM,EAAEQ,QAAO,IAA0BC,KAAKC,MAC5CC,aAAa,IAAIC,IAAI,mBAAmB,YAAYC,GAAG,CAAA,EAAGC,SAAQ,CAAA;AAG7D,IAAMC,gBAAgB,6BAAM;AACjC,QAAMC,UAAU,IAAIC,QAAAA;AAEpBC,aAAWF,OAAAA;AACXG,qBAAmBH,OAAAA;AAEnBI,kBAAAA;AAEA,SAAOJ;AACT,GAT6B;AAW7B,IAAME,aAAa,wBAACF,YAClBA,QACGK,KAAK,QAAA,EACLC,YAAY,0CAAA,EACZd,QAAQA,SAAS,iBAAiB,4BAAA,GAJpB;","names":["Command","readFileSync","fs","resolve","fg","StatesContext","generate","pLimit","setGenerateCommand","program","command","isDefault","description","argument","option","action","action","files","options","resolvedFiles","resolveFiles","basepath","asyncLimit","pLimit","inputs","Promise","all","map","filepath","source","fs","readFile","encoding","ctx","StatesContext","load","outputFile","resolve","output","writeFile","generate","staticFiles","dynamicFiles","file","fg","isDynamicPattern","push","cwd","onlyFiles","unique","fs","catchExceptions","process","on","err","errorHandler","code","fs","writeSync","stderr","fd","String","stack","exit","version","JSON","parse","readFileSync","URL","url","toString","createProgram","program","Command","setProgram","setGenerateCommand","catchExceptions","name","description"]}