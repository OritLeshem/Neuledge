"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createProgram: () => createProgram
});
module.exports = __toCommonJS(src_exports);

// ../../node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = /* @__PURE__ */ __name(() => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href, "getImportMetaUrl");
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// src/index.ts
var import_commander = require("commander");
var import_node_fs2 = require("fs");

// src/generate.ts
var import_promises = __toESM(require("fs/promises"));
var import_node_path = require("path");
var import_fast_glob = __toESM(require("fast-glob"));
var import_states = require("@neuledge/states");
var import_typescript_states = require("@neuledge/typescript-states");
var import_p_limit = __toESM(require("p-limit"));
var setGenerateCommand = /* @__PURE__ */ __name((program) => program.command("generate", {
  isDefault: true
}).description("Convert `.states` files to TypeScript files (default command)").argument("<files...>", "files to build").option("-P, --basepath <path>", "base path").option("-O, --output <file>", "output ts file").action(action), "setGenerateCommand");
var action = /* @__PURE__ */ __name(async (files, options) => {
  const resolvedFiles = await resolveFiles(files, options.basepath);
  const asyncLimit = (0, import_p_limit.default)(10);
  const inputs = await Promise.all(resolvedFiles.map((filepath) => asyncLimit(async () => ({
    source: await import_promises.default.readFile(filepath, {
      encoding: "utf8"
    }),
    filepath
  }))));
  const ctx = new import_states.StatesContext();
  await ctx.load(inputs);
  const outputFile = (0, import_node_path.resolve)(options.basepath ?? "", options.output || "states.ts");
  await import_promises.default.writeFile(outputFile, (0, import_typescript_states.generate)(ctx));
}, "action");
var resolveFiles = /* @__PURE__ */ __name(async (files, basepath) => {
  const staticFiles = [];
  const dynamicFiles = [];
  for (const file of files) {
    if (import_fast_glob.default.isDynamicPattern(file)) {
      dynamicFiles.push(file);
    } else {
      staticFiles.push(file);
    }
  }
  return [
    ...staticFiles,
    ...await (0, import_fast_glob.default)(dynamicFiles, {
      cwd: basepath,
      onlyFiles: true,
      unique: true
    })
  ].map((file) => (0, import_node_path.resolve)(basepath ?? "", file));
}, "resolveFiles");

// src/error.ts
var import_node_fs = __toESM(require("fs"));
var catchExceptions = /* @__PURE__ */ __name(() => process.on("uncaughtException", (err) => errorHandler(err)), "catchExceptions");
var errorHandler = /* @__PURE__ */ __name((err, code = 1) => {
  import_node_fs.default.writeSync(process.stderr.fd, String(err?.stack || err) + "\n");
  process.exit(code);
}, "errorHandler");

// src/index.ts
var { version } = JSON.parse((0, import_node_fs2.readFileSync)(new URL("../package.json", importMetaUrl)).toString());
var createProgram = /* @__PURE__ */ __name(() => {
  const program = new import_commander.Command();
  setProgram(program);
  setGenerateCommand(program);
  catchExceptions();
  return program;
}, "createProgram");
var setProgram = /* @__PURE__ */ __name((program) => program.name("states").description("CLI to build and compile `.states` files").version(version, "-v, --version", "output the current version"), "setProgram");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createProgram
});
//# sourceMappingURL=index.js.map