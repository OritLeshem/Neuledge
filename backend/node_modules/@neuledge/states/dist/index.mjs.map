{"version":3,"sources":["../src/arguments.ts","../src/context.ts","../src/either.ts","../src/decorators.ts","../src/mutation/index.ts","../src/type.ts","../src/entity.ts","../src/parameter.ts","../src/property.ts","../src/literal.ts","../src/expression/call.ts","../src/expression/identifier.ts","../src/expression/logical.ts","../src/expression/this.ts","../src/expression/member.ts","../src/expression/unary.ts","../src/expression/expression.ts","../src/expression/binary.ts","../src/void.ts","../src/scalar.ts","../src/state/field.ts","../src/state/state-index.ts","../src/state/state.ts"],"sourcesContent":["import { ArgumentNode, ParsingError } from '@neuledge/states-parser';\n\nexport type Arguments<T extends { node?: unknown }> = Record<\n  string,\n  Argument<T>\n>;\n\nexport interface Argument<T extends { node?: unknown }> {\n  type: 'Argument';\n  node: ArgumentNode<T['node']>;\n  name: string;\n  value: T;\n}\n\nexport const parseArguments = <T extends { node: unknown }>(\n  nodes: ArgumentNode<T['node']>[],\n  parser: (node: T['node']) => T,\n): Arguments<T> => {\n  const acc: Arguments<T> = {};\n\n  for (const node of nodes) {\n    if (node.key.name in acc) {\n      throw new ParsingError(node.key, `Duplicate argument '${node.key.name}'`);\n    }\n\n    acc[node.key.name] = parseArgument(node, parser);\n  }\n\n  return acc;\n};\n\nconst parseArgument = <T extends { node: unknown }>(\n  node: ArgumentNode<T['node']>,\n  parser: (node: T['node']) => T,\n): Argument<T> => ({\n  type: 'Argument',\n  node,\n  name: node.key.name,\n  value: parser(node.value),\n});\n","import {\n  DocumentBodyNode,\n  DocumentNode,\n  EitherNode,\n  EntityNode,\n  MutationNode,\n  ParsingError,\n  StateFieldNode,\n  StateNode,\n  STATE_FIELD_INDEX_MAX_INPUT_VALUE,\n  parseStates,\n} from '@neuledge/states-parser';\nimport { Either, parseEither } from './either';\nimport { Entity } from './entity';\nimport { Mutation, parseMutation } from './mutation';\nimport { builtInScalars, CustomScalar } from './scalar';\nimport {\n  isStateSortingIndexEquals,\n  parseState,\n  parseStateField,\n  State,\n  StateField,\n} from './state';\nimport { Void } from './void';\n\n/**\n * The order in which the context processes its entities.\n */\nenum ProcessingOrder {\n  Eithers = 10,\n  States = 20,\n  StateRelations = 21,\n  Mutations = 30,\n  EitherMutations = 31,\n  Transforms = 40,\n}\n\nexport class StatesContext {\n  private readonly entityMap: { [K in string]?: Entity<K> } = {\n    ...builtInScalars,\n    Void,\n  };\n  private readonly mutationMap: Partial<\n    Record<string, Partial<Record<string, Mutation>>>\n  > = {};\n  private parent?: StatesContext;\n  private processing: { process(): unknown; order: ProcessingOrder }[] = [];\n\n  // iterators\n\n  *scalars(): Generator<CustomScalar, void, unknown> {\n    yield* this.entities('Scalar');\n  }\n\n  *states(): Generator<State, void, unknown> {\n    yield* this.entities('State');\n  }\n\n  *eithers(): Generator<Either, void, unknown> {\n    yield* this.entities('Either');\n  }\n\n  *entities<T extends Entity['type']>(\n    type?: T | null,\n  ): Generator<Entity & { type: T }, void, unknown> {\n    for (const key in this.entityMap) {\n      const entity = this.entityMap[key];\n\n      if (type == null || entity?.type === type) {\n        yield entity as Entity & { type: T };\n      }\n    }\n  }\n\n  // getters\n\n  entity<N extends string>(name: N): Entity<N> | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias, unicorn/no-this-assignment\n    let self = this;\n\n    do {\n      const res = this.entityMap[name] as Entity<N> | undefined;\n      if (res) return res;\n    } while ((self = self.parent as this));\n\n    return undefined;\n  }\n\n  mutation(stateName: string, name: string): Mutation | undefined {\n    const key = `${stateName || ''}.${name}` as const;\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias, unicorn/no-this-assignment\n    let self = this;\n\n    do {\n      const res = this.mutationMap[key]?.[name];\n      if (res) return res;\n    } while ((self = self.parent as this));\n\n    return undefined;\n  }\n\n  // executors\n\n  async exec(source: string, filepath?: string): Promise<DocumentNode> {\n    const [document] = await this.load([{ source, filepath }]);\n    return document;\n  }\n\n  async load(\n    inputs: { source: string; filepath?: string }[],\n  ): Promise<DocumentNode[]> {\n    const documents = inputs.map(({ source, filepath }) =>\n      parseStates(source, filepath),\n    );\n\n    // we will execute the documents on a child context and only if no errors\n    // triggered we will embed it within the current parser\n    const child = new StatesContext();\n    child.parent = this;\n\n    // first load all the entities and mutations\n    for (const document of documents) {\n      for (const item of document.body) {\n        child.register(item);\n      }\n    }\n\n    // then process the registered nodes by order\n    child.process();\n\n    // success! embed the child context within the current one\n    this.embed(child);\n\n    return documents;\n  }\n\n  private embed(child: StatesContext): void {\n    Object.assign(this.entityMap, child.entityMap);\n\n    Object.assign(\n      this.mutationMap,\n      Object.fromEntries(\n        Object.entries(child.mutationMap).map(([key, value]) => [\n          key,\n          Object.assign(this.mutationMap[key] ?? {}, value),\n        ]),\n      ),\n    );\n  }\n\n  // registerers\n\n  register(node: DocumentBodyNode): void {\n    switch (node.type) {\n      case 'Either': {\n        this.registerEither(node);\n        break;\n      }\n\n      case 'Scalar': {\n        // TODO implement scalars\n        break;\n      }\n\n      case 'State': {\n        this.registerState(node);\n        break;\n      }\n\n      case 'Mutation': {\n        this.registerMutation(node);\n        break;\n      }\n\n      case 'Migration': {\n        // TODO implement migrations\n        break;\n      }\n\n      default: {\n        throw new ParsingError(\n          node,\n          // @ts-expect-error `node.type` should be never\n          `Unsupported document node '${node.type}'`,\n        );\n      }\n    }\n  }\n\n  private registerEntity<T extends EntityNode>(\n    node: T,\n    order: ProcessingOrder,\n    process: (ref: object) => Entity & { type: T['type']; node: T },\n  ): void {\n    const { name } = node.id;\n\n    if (this.entity(name)) {\n      throw new ParsingError(\n        node.id,\n        `An entity name '${name}' already defined`,\n      );\n    }\n\n    const ref: Pick<Entity, 'type' | 'node'> = { type: node.type, node };\n    this.entityMap[name] = ref as Entity;\n\n    this.processing.push({\n      order,\n      process: () => Object.assign(ref, process(ref)),\n    });\n  }\n\n  private registerEither(node: EitherNode): void {\n    this.registerEntity(node, ProcessingOrder.Eithers, () =>\n      parseEither(this, node),\n    );\n\n    this.registerEitherMutations(node);\n  }\n\n  private registerState(node: StateNode): void {\n    this.registerEntity(node, ProcessingOrder.States, (ref) => {\n      const fields: State['fields'] = {};\n      const baseIndex = this.assignStateFields(node, ref, fields);\n\n      let mutations = this.mutationMap[node.id.name];\n      if (!mutations) {\n        mutations = this.mutationMap[node.id.name] = {};\n      }\n\n      return parseState(\n        node,\n        fields,\n        mutations as Record<string, Mutation>,\n        baseIndex,\n      );\n    });\n\n    this.registerStateRelations(node);\n    this.registerStateTransforms(node);\n  }\n\n  private registerStateRelations(node: StateNode): void {\n    this.processing.push({\n      order: ProcessingOrder.StateRelations,\n      process: () => {\n        const state = this.entity(node.id.name) as State;\n\n        for (const field of Object.values(state.fields)) {\n          if (field.type !== 'RelationField') continue;\n\n          const { entity } = field.as;\n\n          if (entity.type === 'Scalar') {\n            throw new ParsingError(\n              field.node,\n              `A relation field '${field.name}' must be a state or an either`,\n            );\n          }\n\n          const states = entity.type === 'State' ? [entity] : entity.states;\n          const { referenceField } = field;\n\n          for (const state of states) {\n            if (state.fields[referenceField]) continue;\n\n            throw new ParsingError(\n              field.node,\n              `A relation field '${field.name}' must reference a field '${referenceField}' in state '${state.name}', but it does not exist`,\n            );\n          }\n        }\n      },\n    });\n  }\n\n  private registerStateTransforms(node: StateNode): void {\n    this.processing.push({\n      order: ProcessingOrder.Transforms,\n      process: () => {\n        const state = this.entity(node.id.name) as State;\n        const mutations = this.mutationMap[node.id.name] ?? {};\n\n        for (const mutation of Object.values(mutations)) {\n          if (mutation?.mutation !== 'update') continue;\n\n          const returns = mutation.returns;\n          if (returns.name !== state.name) {\n            continue;\n          }\n\n          if (\n            returns.type !== 'State' ||\n            !isStateSortingIndexEquals(\n              state,\n              state.primaryKey,\n              returns,\n              returns.primaryKey,\n            )\n          ) {\n            throw new ParsingError(\n              mutation.node.key,\n              `A mutation for state '${state.name}' must return a state with the same primary key as the original state`,\n            );\n          }\n        }\n      },\n    });\n  }\n\n  private registerMutation(node: MutationNode): void {\n    const form = node.from ?? node.returns;\n\n    if (this.mutation(form.name, node.key.name)) {\n      throw new ParsingError(\n        node.key,\n        `The mutation name '${node.key.name}'${\n          node.from ? ` for '${node.from.name}'` : ''\n        } already defined`,\n      );\n    }\n\n    let entry = this.mutationMap[form.name];\n    if (!entry) {\n      entry = {};\n      this.mutationMap[form.name] = entry;\n    }\n\n    const ref: Pick<Mutation, 'type' | 'node'> = { type: node.type, node };\n    entry[node.key.name] = ref as Mutation;\n\n    this.processing.push({\n      order: ProcessingOrder.Mutations,\n      process: () => Object.assign(ref, parseMutation(this, node)),\n    });\n  }\n\n  private registerEitherMutations(node: EitherNode): void {\n    this.processing.push({\n      order: ProcessingOrder.EitherMutations,\n      process: () => {\n        const mutations = this.mutationMap[node.id.name] ?? {};\n\n        for (const stateNode of node.states) {\n          const state = this.entity(stateNode.name) as State;\n\n          let stateMutations = this.mutationMap[state.name];\n          if (!stateMutations) {\n            this.mutationMap[state.name] = stateMutations = {};\n          }\n\n          for (const name in mutations) {\n            const mutation = mutations[name];\n\n            if (stateMutations[name] || !mutation) {\n              // do not override existing state mutations\n              continue;\n            }\n\n            stateMutations[name] = {\n              ...mutation,\n              target: state,\n              returns:\n                !mutation.node.from ||\n                mutation.node.returns.name === mutation.node.from.name\n                  ? state\n                  : mutation.returns,\n            };\n          }\n        }\n      },\n    });\n  }\n\n  // processors\n\n  process(): void {\n    this.processing.sort((a, b) => a.order - b.order);\n\n    for (const { process } of this.processing) {\n      process();\n    }\n\n    this.processing = [];\n  }\n\n  /**\n   * Assign the given `fields` dictionary with the fields of the given `node` state.\n   * Return the calculated base index of the state.\n   */\n  private assignStateFields(\n    node: StateNode,\n    ref: Partial<State>,\n    fields: State['fields'],\n  ): number {\n    // return the cached fields if already processed\n    if ('fields' in ref) {\n      if (ref.baseIndex == null || ref.fields == null) {\n        throw new ParsingError(node.id, `Circular dependency detected`);\n      }\n\n      Object.assign(fields, ref.fields);\n\n      return ref.baseIndex;\n    }\n\n    // mark the state as processing (to detect circular dependencies)\n    ref.fields = undefined;\n    let baseIndex = 0;\n\n    // if the state has a parent, we need to parse its fields first\n    if (node.from) {\n      const parent = this.entity(node.from.name);\n\n      if (parent?.type !== 'State') {\n        throw new ParsingError(\n          node.from,\n          `Unknown state name '${node.from.name}'`,\n        );\n      }\n\n      baseIndex +=\n        this.assignStateFields(parent.node, parent, fields) +\n        STATE_FIELD_INDEX_MAX_INPUT_VALUE;\n    }\n\n    // we will sort the fields by their index\n    const sortedFields = [...node.fields].sort(\n      (a, b) =>\n        ('index' in a ? a.index.value : 0) - ('index' in b ? b.index.value : 0),\n    );\n\n    for (const fieldNode of sortedFields) {\n      const field = this.parseStateField(fieldNode, baseIndex);\n\n      if (!field) {\n        // field marked as excluded\n\n        if (!fields[fieldNode.key.name]) {\n          throw new ParsingError(\n            fieldNode.key,\n            `Unknown field name '${fieldNode.key.name}'`,\n          );\n        }\n\n        delete fields[fieldNode.key.name];\n        continue;\n      }\n\n      fields[field.name] = field;\n    }\n\n    // mark the state as processed\n    ref.fields = fields;\n    ref.baseIndex = baseIndex;\n\n    return baseIndex;\n  }\n\n  private parseStateField(\n    node: StateFieldNode,\n    baseIndex: number,\n  ): StateField | null {\n    switch (node.type) {\n      case 'Field': {\n        return parseStateField(this, node, baseIndex);\n      }\n\n      case 'ReferenceField': {\n        const refState = this.entity(node.state.name);\n        if (refState?.type !== 'State') {\n          throw new ParsingError(\n            node.state,\n            `Unknown state name '${node.state.name}'`,\n          );\n        }\n        const fields: State['fields'] = {};\n        this.assignStateFields(refState.node, refState, fields);\n\n        const field = fields[node.key.name];\n        if (!field) {\n          throw new ParsingError(\n            node.key,\n            `Undefined field name '${node.key.name}' on state '${node.state.name}'`,\n          );\n        }\n\n        return {\n          ...field,\n          index: node.index.value + baseIndex,\n        };\n      }\n\n      case 'ExcludedField': {\n        return null;\n      }\n    }\n  }\n}\n","import { EitherNode, ParsingError } from '@neuledge/states-parser';\nimport { z } from 'zod';\nimport { applyDecorators, createDecorator, Decorators } from './decorators';\nimport { State, StatesContext } from './index';\n\nexport interface Either<N extends string = string> {\n  type: 'Either';\n  node: EitherNode;\n  name: N;\n  description?: string;\n  deprecated?: boolean | string;\n  states: State[];\n}\n\nexport const parseEither = (ctx: StatesContext, node: EitherNode): Either => {\n  const either: Either = {\n    type: 'Either',\n    node,\n    name: node.id.name,\n    description: node.description?.value,\n    states: node.states.map((identifier) => {\n      const state = ctx.entity(identifier.name);\n\n      if (state?.type !== 'State') {\n        throw new ParsingError(\n          identifier,\n          `Unknown state name '${identifier.name}'`,\n        );\n      }\n\n      return state;\n    }),\n  };\n\n  applyDecorators(either, node.decorators, decorators);\n\n  return either;\n};\n\nconst decorators: Decorators<Either> = {\n  deprecated: createDecorator(\n    z.object({\n      reason: z.string().optional(),\n    }),\n    (state, args) => {\n      state.deprecated = args.reason || true;\n    },\n  ),\n};\n","import {\n  ArgumentNode,\n  DecoratorNode,\n  LiteralNode,\n  ParsingError,\n} from '@neuledge/states-parser';\nimport z from 'zod';\n\nexport type Decorators<T> = Record<string, Decorator<T>>;\nexport type Decorator<T> = (target: T, args: DecoratorNode) => void;\n\nexport const createDecorator =\n  <T, A extends z.AnyZodObject>(\n    decoratorArgs: A,\n    decorator: (\n      target: T,\n      args: z.infer<A>,\n      argNodes: Record<string, ArgumentNode<LiteralNode>>,\n      node: DecoratorNode,\n    ) => T | void,\n  ): Decorator<T> =>\n  (target, node) => {\n    const argsNodes = Object.fromEntries(\n      node.arguments.map((arg) => [arg.key.name, arg]),\n    );\n\n    const argsValues = Object.fromEntries(\n      Object.entries(argsNodes).map(([key, value]) => [\n        key,\n        value.value?.value,\n      ]),\n    );\n\n    const args = decoratorArgs.safeParse(argsValues);\n    if (!args.success) {\n      const [issue] = args.error.issues;\n      const key = issue.path[0];\n\n      throw new ParsingError(\n        argsNodes[key] ?? node.callee,\n        `Invalid '@${node.callee.name}()' decorator on argument '${key}': ${issue.message}`,\n      );\n    }\n\n    return decorator(target, args.data, argsNodes, node);\n  };\n\nexport const applyDecorators = <T>(\n  target: T,\n  nodes: DecoratorNode[],\n  decorators: Decorators<T>,\n): void => {\n  for (const node of nodes) {\n    const { name } = node.callee;\n    const decorator = decorators[name];\n\n    if (decorator) {\n      decorator(target, node);\n    }\n  }\n};\n","import { StatesContext } from '@/context';\nimport { applyDecorators, createDecorator, Decorators } from '@/decorators';\nimport { MutationNode, ParsingError } from '@neuledge/states-parser';\nimport { z } from 'zod';\nimport {\n  ParametersContext,\n  Parameter,\n  parseParametersContext,\n} from '@/parameter';\nimport { parseProperties, Property } from '@/property';\nimport { State } from '@/state';\nimport { Either } from '@/either';\nimport { Void } from '@/void';\n\nexport interface Mutation extends ParametersContext {\n  type: 'Mutation';\n  node: MutationNode;\n  name: string;\n  mutation: 'create' | 'update' | 'delete';\n  description?: string;\n  deprecated?: boolean | string;\n  target: State | Either;\n  returns: State | Either | typeof Void;\n  parameters: Record<string, Parameter>;\n  body: Record<string, Property>;\n}\n\nexport const parseMutation = (\n  ctx: StatesContext,\n  node: MutationNode,\n): Mutation => {\n  const target = parseTarget(ctx, node);\n  const returns = parseReturns(ctx, node, target);\n\n  const params = parseParametersContext(\n    ctx,\n    node.from ? target : null,\n    node.parameters,\n  );\n  const body = parseBody(ctx, params, node);\n\n  const mutation: Mutation = {\n    type: 'Mutation',\n    node,\n    ...params,\n    mutation: node.from\n      ? returns.name === Void.name\n        ? 'delete'\n        : 'update'\n      : 'create',\n    name: node.key.name,\n    description: node.description?.value,\n    target,\n    returns,\n    body,\n  };\n\n  applyDecorators(mutation, node.decorators, decorators);\n\n  return mutation;\n};\n\nconst decorators: Decorators<Mutation> = {\n  deprecated: createDecorator(\n    z.object({\n      reason: z.string().optional(),\n    }),\n    (state, args) => {\n      state.deprecated = args.reason || true;\n    },\n  ),\n};\n\nconst parseTarget = (\n  ctx: StatesContext,\n  node: MutationNode,\n): State | Either => {\n  const targetNode = node.from ?? node.returns;\n  const target = ctx.entity(targetNode.name);\n\n  if (!target) {\n    throw new ParsingError(\n      targetNode,\n      `Unknown entity name '${targetNode.name}'`,\n    );\n  }\n\n  if (node.from) {\n    if (target.type !== 'State' && target.type !== 'Either') {\n      throw new ParsingError(\n        targetNode,\n        `Expected state or either, got '${target.type}'`,\n      );\n    }\n  } else if (target.type !== 'State') {\n    throw new ParsingError(targetNode, `Expected state, got '${target.type}'`);\n  }\n\n  return target;\n};\n\nconst parseReturns = (\n  ctx: StatesContext,\n  node: MutationNode,\n  target: State | Either,\n): State | Either | typeof Void => {\n  const returnsNode = node.returns;\n  const returns = ctx.entity(returnsNode.name);\n\n  if (!returns) {\n    throw new ParsingError(\n      returnsNode,\n      `Unknown entity name '${returnsNode.name}'`,\n    );\n  }\n\n  switch (returns.type) {\n    case 'State':\n    case 'Void': {\n      break;\n    }\n\n    case 'Either': {\n      if (target.type !== 'Either') {\n        throw new ParsingError(\n          returnsNode,\n          `Expected state or void, got '${returns.type}'`,\n        );\n      }\n\n      if (target.name !== returns.name) {\n        throw new ParsingError(\n          returnsNode,\n          `Expected either '${target.name}', got '${returns.name}'`,\n        );\n      }\n      break;\n    }\n\n    case 'Scalar': {\n      throw new ParsingError(\n        returnsNode,\n        `Expected state or void, got '${returns.type}'`,\n      );\n    }\n  }\n\n  return returns;\n};\n\nconst parseBody = (\n  ctx: StatesContext,\n  params: ParametersContext,\n  node: MutationNode,\n): Record<string, Property> => parseProperties(ctx, params, node.body);\n","import {\n  ParsingError,\n  TypeExpressionNode,\n  TypeNode,\n} from '@neuledge/states-parser';\nimport { StatesContext } from './context';\nimport { NonNullableEntity, parseNonNullableEntity } from './entity';\n\nexport type Type = EntityExpression;\n\nexport interface EntityExpression {\n  type: 'EntityExpression';\n  node: TypeExpressionNode;\n  entity: NonNullableEntity;\n  list: boolean;\n}\n\n// export interface TypeGenerator {\n//     type: 'TypeGenerator';\n//     generator: Generator;\n//     arguments: ...;\n// }\n\nexport const parseType = (ctx: StatesContext, node: TypeNode): Type => {\n  if (node.type === 'TypeGenerator') {\n    throw new ParsingError(node, 'Not implemented');\n  }\n\n  return parseEntityExpression(ctx, node);\n};\n\nconst parseEntityExpression = (\n  ctx: StatesContext,\n  node: TypeExpressionNode,\n): EntityExpression => ({\n  type: 'EntityExpression',\n  node,\n  entity: parseNonNullableEntity(ctx, node.identifier),\n  list: node.list,\n});\n","import { IdentifierNode, ParsingError } from '@neuledge/states-parser';\nimport { Either } from './either';\nimport { StatesContext } from './index';\nimport { CustomScalar, Scalar } from './scalar';\nimport { State } from './state';\nimport { Void } from './void';\n\nexport type Entity<N extends string = string> =\n  | NonNullableEntity<N>\n  | ((typeof Void)['name'] extends N ? typeof Void : never);\n\nexport type NonNullableEntity<N extends string = string> =\n  | Either<N>\n  | State<N>\n  | (Scalar & { name: N })\n  | CustomScalar<N>;\n\nexport const parseEntity = (\n  ctx: StatesContext,\n  node: IdentifierNode,\n): Entity => {\n  const entity = ctx.entity(node.name);\n\n  if (!entity) {\n    throw new ParsingError(node, `Unknown entity name '${node.name}'`);\n  }\n\n  return entity;\n};\n\nexport const parseNonNullableEntity = (\n  ctx: StatesContext,\n  node: IdentifierNode,\n): NonNullableEntity => {\n  const entity = ctx.entity(node.name);\n\n  if (!entity) {\n    throw new ParsingError(node, `Unknown entity name '${node.name}'`);\n  }\n  if (entity.type === 'Void') {\n    throw new ParsingError(node, `Void entity is nullable`);\n  }\n\n  return entity;\n};\n","import { StatesContext } from '@/context';\nimport { applyDecorators, createDecorator, Decorators } from '@/decorators';\nimport { parseType, Type } from '@/type';\nimport { ParameterNode, ParsingError } from '@neuledge/states-parser';\nimport { z } from 'zod';\nimport { Either } from './either';\nimport { State } from './state';\n\nexport interface ParametersContext {\n  this: State | Either | null;\n  parameters: Record<string, Parameter>;\n}\n\nexport interface Parameter {\n  type: 'Parameter';\n  node: ParameterNode;\n  name: string;\n  description?: string;\n  deprecated?: boolean | string;\n  nullable: boolean;\n  as: Type;\n}\n\nexport const parseParametersContext = (\n  ctx: StatesContext,\n  target: State | Either | null,\n  nodes: ParameterNode[],\n): ParametersContext => ({\n  this: target,\n  parameters: parseParameters(ctx, nodes),\n});\n\nexport const parseParameters = (\n  ctx: StatesContext,\n  nodes: ParameterNode[],\n): Record<string, Parameter> => {\n  const parameters: Record<string, Parameter> = {};\n\n  for (const node of nodes) {\n    if (node.key.name in parameters) {\n      throw new ParsingError(\n        node.key,\n        `Duplicate parameter name '${node.key.name}'`,\n      );\n    }\n\n    parameters[node.key.name] = parseParameter(ctx, node);\n  }\n\n  return parameters;\n};\n\nconst parseParameter = (ctx: StatesContext, node: ParameterNode): Parameter => {\n  const parameter: Parameter = {\n    type: 'Parameter',\n    node,\n    name: node.key.name,\n    description: node.description?.value,\n    nullable: node.nullable,\n    as: parseType(ctx, node.as),\n  };\n\n  applyDecorators(parameter, node.decorators, decorators);\n\n  return parameter;\n};\n\nconst decorators: Decorators<Parameter> = {\n  deprecated: createDecorator(\n    z.object({\n      reason: z.string().optional(),\n    }),\n    (parameter, args) => {\n      parameter.deprecated = args.reason || true;\n    },\n  ),\n};\n","import { ParsingError, PropertyNode } from '@neuledge/states-parser';\nimport { StatesContext } from './context';\nimport {\n  Expression,\n  parseExpression,\n  parseIdentifierExpression,\n} from './expression';\nimport { Parameter, ParametersContext } from './parameter';\n\nexport interface Property {\n  type: 'Property';\n  node?: PropertyNode;\n  name: string;\n  value: Expression;\n}\n\nexport const parseProperties = (\n  ctx: StatesContext,\n  params: ParametersContext,\n  nodes: PropertyNode[],\n): Record<string, Property> => {\n  const properties: Record<string, Property> = {};\n\n  if (nodes.length) {\n    for (const node of nodes) {\n      const property = parseProperty(params, node);\n\n      if (properties[property.name]) {\n        throw new ParsingError(\n          node.key,\n          `Duplicate property '${property.name}'`,\n        );\n      }\n\n      properties[property.name] = property;\n    }\n  } else {\n    for (const parameter of Object.values(params.parameters)) {\n      properties[parameter.name] = parseParameterProperty(params, parameter);\n    }\n  }\n\n  return properties;\n};\n\nconst parseProperty = (\n  params: ParametersContext,\n  node: PropertyNode,\n): Property => ({\n  type: 'Property',\n  node,\n  name: node.key.name,\n  value: parseExpression(params, node.value),\n});\n\nconst parseParameterProperty = (\n  params: ParametersContext,\n  parameter: Parameter,\n): Property => ({\n  type: 'Property',\n  name: parameter.name,\n  value: parseIdentifierExpression(params, parameter.node.key),\n});\n","import {\n  LiteralNode,\n  LiteralValue,\n  NullLiteralNode,\n} from '@neuledge/states-parser';\n\nexport interface Literal<T extends LiteralValue = LiteralValue> {\n  type: 'Literal';\n  node?: LiteralNode<T>;\n  value: T;\n}\n\nexport const parseLiteral = <T extends LiteralValue = LiteralValue>(\n  node: LiteralNode<T>,\n): Literal<T> & { node: LiteralNode<T> } => ({\n  type: 'Literal',\n  node,\n  value: node.value,\n});\n\nexport interface NullLiteral {\n  type: 'NullLiteral';\n  node: NullLiteralNode;\n  value: null;\n}\n\nexport const parseNullLiteral = (node: NullLiteralNode): NullLiteral => ({\n  type: 'NullLiteral',\n  node,\n  value: null,\n});\n","import { Arguments, parseArguments } from '@/arguments';\nimport { ParametersContext } from '@/parameter';\nimport { Callable, runtime } from '@neuledge/scalars';\nimport {\n  CallExpressionNode,\n  ExpressionNode,\n  ParsingError,\n} from '@neuledge/states-parser';\nimport { Expression, parseExpression } from './expression';\n\nexport interface CallExpression {\n  type: 'CallExpression';\n  node: CallExpressionNode;\n  callee: Callable;\n  arguments: Arguments<Expression & { node: ExpressionNode }>;\n}\n\nexport const parseCallExpression = (\n  params: ParametersContext,\n  node: CallExpressionNode,\n): CallExpression => {\n  const callee = runtime[node.callee.name as keyof typeof runtime];\n  if (!callee) {\n    throw new ParsingError(\n      node.callee,\n      `Unknown runtime function '${node.callee.name}'`,\n    );\n  }\n\n  return {\n    type: 'CallExpression',\n    node,\n    callee,\n    arguments: parseArguments(node.arguments, (node) =>\n      parseExpression(params, node),\n    ),\n  };\n};\n","import { Parameter, ParametersContext } from '@/parameter';\nimport { IdentifierNode, ParsingError } from '@neuledge/states-parser';\n\nexport interface IdentifierExpression {\n  type: 'IdentifierExpression';\n  node: IdentifierNode;\n  reference: Parameter;\n}\n\nexport const parseIdentifierExpression = (\n  params: ParametersContext,\n  node: IdentifierNode,\n): IdentifierExpression => {\n  const reference = params.parameters[node.name];\n\n  if (!reference) {\n    throw new ParsingError(node, `Unknown identifier '${node.name}'`);\n  }\n\n  return {\n    type: 'IdentifierExpression',\n    node,\n    reference,\n  };\n};\n","import { ParametersContext } from '@/parameter';\nimport { LogicalExpressionNode } from '@neuledge/states-parser';\nimport { Expression, parseExpression } from './expression';\n\nexport interface LogicalExpression {\n  type: 'LogicalExpression';\n  node: LogicalExpressionNode;\n  operator: LogicalExpressionOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport type LogicalExpressionOperator = LogicalExpressionNode['operator'];\n\nexport const parseLogicalExpression = (\n  params: ParametersContext,\n  node: LogicalExpressionNode,\n): LogicalExpression => ({\n  type: 'LogicalExpression',\n  node,\n  operator: node.operator,\n  left: parseExpression(params, node.left),\n  right: parseExpression(params, node.right),\n});\n","import { ParametersContext } from '@/parameter';\nimport { State } from '@/state';\nimport { ParsingError, ThisExpressionNode } from '@neuledge/states-parser';\n\nexport interface ThisExpression {\n  type: 'ThisExpression';\n  node: ThisExpressionNode;\n  reference: State;\n}\n\nexport const parseThisExpression = (\n  params: ParametersContext,\n  node: ThisExpressionNode,\n): ThisExpression => {\n  if (params.this?.type !== 'State') {\n    throw new ParsingError(node, 'ThisExpression is not allowed here');\n  }\n\n  return {\n    type: 'ThisExpression',\n    node,\n    reference: params.this,\n  };\n};\n","import { ParametersContext } from '@/parameter';\nimport { IdentifierNode, MemberExpressionNode } from '@neuledge/states-parser';\nimport { IdentifierExpression, parseIdentifierExpression } from './identifier';\nimport { parseThisExpression, ThisExpression } from './this';\n\nexport interface MemberExpression {\n  type: 'MemberExpression';\n  node: MemberExpressionNode;\n  object: IdentifierExpression | ThisExpression;\n  properties: PropertyExpression[];\n}\n\nexport interface PropertyExpression {\n  type: 'PropertyExpression';\n  node: IdentifierNode;\n  name: string;\n}\n\nexport const parseMemberExpression = (\n  params: ParametersContext,\n  node: MemberExpressionNode,\n): MemberExpression => {\n  const properties = [parsePropertyExpression(params, node.property)];\n\n  while (node.object.type === 'MemberExpression') {\n    properties.push(parsePropertyExpression(params, node.object.property));\n    node = node.object;\n  }\n\n  const object =\n    node.object.type === 'Identifier'\n      ? parseIdentifierExpression(params, node.object)\n      : parseThisExpression(params, node.object);\n\n  return {\n    type: 'MemberExpression',\n    node,\n    object,\n    properties,\n  };\n};\n\nconst parsePropertyExpression = (\n  params: ParametersContext,\n  node: IdentifierNode,\n): PropertyExpression => ({\n  type: 'PropertyExpression',\n  node,\n  name: node.name,\n});\n","import { ParametersContext } from '@/parameter';\nimport { UnaryExpressionNode } from '@neuledge/states-parser';\nimport { Expression, parseExpression } from './expression';\n\nexport interface UnaryExpression {\n  type: 'UnaryExpression';\n  node: UnaryExpressionNode;\n  operator: UnaryExpressionOperator;\n  argument: Expression;\n}\n\nexport type UnaryExpressionOperator = UnaryExpressionNode['operator'];\n\nexport const parseUnaryExpression = (\n  params: ParametersContext,\n  node: UnaryExpressionNode,\n): UnaryExpression => ({\n  type: 'UnaryExpression',\n  node,\n  operator: node.operator,\n  argument: parseExpression(params, node.argument),\n});\n","import {\n  Literal,\n  NullLiteral,\n  parseLiteral,\n  parseNullLiteral,\n} from '@/literal';\nimport { ParametersContext } from '@/parameter';\nimport { ExpressionNode } from '@neuledge/states-parser';\nimport { BinaryExpression, parseBinaryExpression } from './binary';\nimport { CallExpression, parseCallExpression } from './call';\nimport { IdentifierExpression, parseIdentifierExpression } from './identifier';\nimport { LogicalExpression, parseLogicalExpression } from './logical';\nimport { MemberExpression, parseMemberExpression } from './member';\nimport { parseThisExpression, ThisExpression } from './this';\nimport { parseUnaryExpression, UnaryExpression } from './unary';\n\nexport type Expression =\n  | CallExpression\n  | IdentifierExpression\n  | ThisExpression\n  | MemberExpression\n  | UnaryExpression\n  | BinaryExpression\n  | LogicalExpression\n  | NullLiteral\n  | Literal;\n\nexport const parseExpression = (\n  params: ParametersContext,\n  node: ExpressionNode,\n): Expression & { node: ExpressionNode } => {\n  switch (node.type) {\n    case 'CallExpression': {\n      return parseCallExpression(params, node);\n    }\n\n    case 'Identifier': {\n      return parseIdentifierExpression(params, node);\n    }\n\n    case 'ThisExpression': {\n      return parseThisExpression(params, node);\n    }\n\n    case 'MemberExpression': {\n      return parseMemberExpression(params, node);\n    }\n\n    case 'Literal': {\n      return parseLiteral(node);\n    }\n\n    case 'UnaryExpression': {\n      return parseUnaryExpression(params, node);\n    }\n\n    case 'BinaryExpression': {\n      return parseBinaryExpression(params, node);\n    }\n\n    case 'LogicalExpression': {\n      return parseLogicalExpression(params, node);\n    }\n\n    case 'NullLiteral': {\n      return parseNullLiteral(node);\n    }\n\n    default: {\n      // @ts-expect-error `node` type is never\n      throw new TypeError(`Unexpected expression type: ${node.type}`);\n    }\n  }\n};\n","import { ParametersContext } from '@/parameter';\nimport { BinaryExpressionNode } from '@neuledge/states-parser';\nimport { Expression, parseExpression } from './expression';\n\nexport interface BinaryExpression {\n  type: 'BinaryExpression';\n  node: BinaryExpressionNode;\n  operator: BinaryExpressionOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport type BinaryExpressionOperator = BinaryExpressionNode['operator'];\n\nexport const parseBinaryExpression = (\n  params: ParametersContext,\n  node: BinaryExpressionNode,\n): BinaryExpression => ({\n  type: 'BinaryExpression',\n  node,\n  operator: node.operator,\n  left: parseExpression(params, node.left),\n  right: parseExpression(params, node.right),\n});\n","export type Void = void;\n\nexport const Void: { type: 'Void'; name: 'Void'; node?: never } = {\n  type: 'Void',\n  name: 'Void',\n};\n","import {\n  CallableScalar,\n  Scalar as BuiltInScalar,\n  types,\n} from '@neuledge/scalars';\nimport { ScalarNode } from '@neuledge/states-parser';\n\nexport type Scalar = BuiltInScalar & { node?: never };\n\nexport interface CustomScalar<Name extends string = string>\n  extends BuiltInScalar {\n  type: Scalar['type'];\n  name: Name;\n  node?: ScalarNode;\n}\n\nexport const builtInScalars: { [K in string]: Scalar & { name: K } } =\n  Object.fromEntries(\n    (Object.values(types) as CallableScalar[])\n      .filter((value): value is CallableScalar => value?.type === 'Scalar')\n      .map((value) => [value.name, value]),\n  );\n","import { StatesContext } from '@/context';\nimport { applyDecorators, createDecorator, Decorators } from '@/decorators';\nimport { parseType, Type } from '@/type';\nimport { FieldNode, ParsingError } from '@neuledge/states-parser';\nimport { z } from 'zod';\nimport {\n  StateSortingIndex,\n  StateIndexNameRegex,\n  StatePrimaryKey,\n} from './state-index';\n\nexport type StateField = ScalarField | RelationField;\n\n/**\n * A scalar field is a field that exists in the current state. Typically,\n * this is a column in a database table and it can contain a scalar value\n * (including arrays and objects).\n */\nexport interface ScalarField extends AbstractField {\n  type: 'ScalarField';\n  sortingIndex?: StateSortingIndex;\n  primaryKey?: StatePrimaryKey;\n}\n\n/**\n * A relation field is a field that references another state but does not\n * exist in the current state. Typically, this is a foreign key.\n */\nexport interface RelationField extends AbstractField {\n  type: 'RelationField';\n  referenceField: ScalarField['name'];\n}\n\ninterface AbstractField {\n  node: FieldNode;\n  name: string;\n  nullable?: boolean;\n  index: number;\n  description?: string;\n  deprecated?: boolean | string;\n  as: Type;\n}\n\nexport const parseStateField = (\n  ctx: StatesContext,\n  node: FieldNode,\n  baseIndex: number,\n): StateField => {\n  const as = parseType(ctx, node.as);\n\n  const base: AbstractField = {\n    node,\n    name: node.key.name,\n    nullable: node.nullable,\n    index: node.index.value + baseIndex,\n    description: node.description?.value,\n    as,\n  };\n\n  const field: StateField =\n    as.entity.type === 'Scalar' || !as.list\n      ? {\n          type: 'ScalarField',\n          ...base,\n        }\n      : {\n          type: 'RelationField',\n          ...base,\n          referenceField: null as never,\n        };\n\n  applyDecorators(field, node.decorators, decorators);\n\n  if (field.type === 'RelationField' && !field.referenceField) {\n    throw new ParsingError(\n      node,\n      `Relation field '${field.name}' must have a '@reference()' field annotation`,\n    );\n  }\n\n  return field;\n};\n\nconst decorators: Decorators<StateField> = {\n  deprecated: createDecorator(\n    z.object({\n      reason: z.string().optional(),\n    }),\n    (field, args) => {\n      field.deprecated = args.reason || true;\n    },\n  ),\n\n  id: createDecorator(\n    z.object({\n      sort: z\n        .union([\n          z.literal('asc'),\n          z.literal('desc'),\n          z.literal(1),\n          z.literal(-1),\n        ])\n        .optional(),\n      auto: z.literal('increment').optional(),\n    }),\n    (field, { sort, auto }) => {\n      if (field.type !== 'ScalarField') {\n        throw new ParsingError(\n          field.node,\n          `@id can only be applied to scalar fields`,\n        );\n      }\n\n      if (field.primaryKey) {\n        throw new ParsingError(\n          field.node,\n          `Duplicate @id on field '${field.name}'`,\n        );\n      }\n\n      field.primaryKey = {\n        name: field.name,\n        fields: {\n          [field.name]:\n            sort == null || sort === 'asc' || sort === 1 ? 'asc' : 'desc',\n        },\n        unique: true,\n        auto,\n      };\n    },\n  ),\n\n  index: createDecorator(\n    z.object({\n      sort: z\n        .union([\n          z.literal('asc'),\n          z.literal('desc'),\n          z.literal(1),\n          z.literal(-1),\n        ])\n        .optional(),\n      unique: z.boolean().optional(),\n      name: z.string().regex(StateIndexNameRegex).optional(),\n    }),\n    (field, { sort, unique, name }) => {\n      if (field.type !== 'ScalarField') {\n        throw new ParsingError(\n          field.node,\n          `@index can only be applied to scalar fields`,\n        );\n      }\n\n      if (field.sortingIndex) {\n        throw new ParsingError(\n          field.node,\n          `Duplicate @index or @unique on field '${field.name}'`,\n        );\n      }\n\n      field.sortingIndex = {\n        name: name || field.name,\n        fields: {\n          [field.name]:\n            sort == null || sort === 'asc' || sort === 1 ? 'asc' : 'desc',\n        },\n        unique,\n      };\n    },\n  ),\n\n  unique: createDecorator(\n    z.object({\n      sort: z\n        .union([\n          z.literal('asc'),\n          z.literal('desc'),\n          z.literal(1),\n          z.literal(-1),\n        ])\n        .optional(),\n      name: z.string().regex(StateIndexNameRegex).optional(),\n    }),\n    (field, { sort, name }) => {\n      if (field.type !== 'ScalarField') {\n        throw new ParsingError(\n          field.node,\n          `@unique can only be applied to scalar fields`,\n        );\n      }\n\n      if (field.sortingIndex) {\n        throw new ParsingError(\n          field.node,\n          `Duplicate @unique or @index on field '${field.name}'`,\n        );\n      }\n\n      field.sortingIndex = {\n        name: name || field.name,\n        fields: {\n          [field.name]:\n            sort == null || sort === 'asc' || sort === 1 ? 'asc' : 'desc',\n        },\n        unique: true,\n      };\n    },\n  ),\n\n  reference: createDecorator(\n    z.object({\n      field: z.string().regex(/^[_a-z]\\w*$/i),\n    }),\n    (field, { field: referenceField }) => {\n      if (field.type === 'RelationField' && field.referenceField) {\n        throw new ParsingError(\n          field.node,\n          `Duplicate @reference on field '${field.name}'`,\n        );\n      }\n\n      Object.assign(field, {\n        type: 'RelationField',\n        referenceField,\n      });\n    },\n  ),\n};\n","import { State } from './state';\n\nexport interface StateSortingIndex {\n  name: string;\n  fields: Record<string, 'asc' | 'desc'>;\n  unique?: boolean;\n}\n\nexport interface StatePrimaryKey extends StateSortingIndex {\n  unique: true;\n  auto?: 'increment';\n}\n\nexport const StateIndexNameRegex = /^[\\w.]+$/i;\n\nexport const isStateSortingIndexEquals = (\n  sa: State,\n  ia: StateSortingIndex,\n  sb: State,\n  ib: StateSortingIndex,\n): boolean => {\n  if (\n    !ia.unique !== !ib.unique &&\n    (ia as StatePrimaryKey).auto !== (ib as StatePrimaryKey).auto\n  ) {\n    return false;\n  }\n\n  const a_keys = Object.keys(ia.fields);\n  const b_keys = Object.keys(ib.fields);\n\n  if (a_keys.length !== b_keys.length) {\n    return false;\n  }\n\n  return a_keys.every((ak, i) => {\n    const bk = b_keys[i];\n\n    return (\n      ia.fields[ak] === ib.fields[bk] &&\n      sa.fields[ak].as.entity.name === sb.fields[bk].as.entity.name &&\n      !sa.fields[ak].as.list === !sb.fields[bk].as.list &&\n      !sa.fields[ak].nullable === !sb.fields[bk].nullable\n    );\n  });\n};\n","import { applyDecorators, createDecorator, Decorators } from '@/decorators';\nimport { Mutation } from '@/mutation';\nimport { ParsingError, StateNode } from '@neuledge/states-parser';\nimport { z } from 'zod';\nimport { StateField } from './field';\nimport {\n  StateSortingIndex,\n  StateIndexNameRegex,\n  StatePrimaryKey,\n} from './state-index';\n\nexport interface State<N extends string = string> {\n  type: 'State';\n  node: StateNode;\n  name: N;\n  description?: string;\n  deprecated?: boolean | string;\n  fields: Record<string, StateField>;\n  primaryKey: StatePrimaryKey;\n  indexes: Record<string, StateSortingIndex>;\n  mutations: Record<string, Mutation>;\n  baseIndex: number;\n}\n\nexport const parseState = (\n  node: StateNode,\n  fields: State['fields'],\n  mutations: State['mutations'],\n  baseIndex: State['baseIndex'],\n): State => {\n  const state: State = {\n    type: 'State',\n    node,\n    name: node.id.name,\n    description: node.description?.value,\n    fields,\n    primaryKey: {\n      name: '',\n      fields: {},\n      unique: true,\n    },\n    indexes: {},\n    mutations,\n    baseIndex,\n  };\n\n  for (const field of Object.values(fields)) {\n    if (field.type !== 'ScalarField') continue;\n\n    const { sortingIndex, primaryKey } = field;\n\n    if (sortingIndex) {\n      if (state.indexes[sortingIndex.name]) {\n        throw new ParsingError(\n          field.node,\n          `Index '${sortingIndex.name}' already exists`,\n        );\n      }\n\n      state.indexes[sortingIndex.name] = sortingIndex;\n    }\n\n    if (primaryKey) {\n      Object.assign(state.primaryKey.fields, primaryKey.fields);\n\n      if (primaryKey.auto) {\n        state.primaryKey.auto = primaryKey.auto;\n      }\n    }\n  }\n\n  applyDecorators(state, node.decorators, decorators);\n  applyPrimaryKey(state, node);\n\n  return state;\n};\n\nconst decorators: Decorators<State> = {\n  deprecated: createDecorator(\n    z.object({\n      reason: z.string().optional(),\n    }),\n    (state, args) => {\n      state.deprecated = args.reason || true;\n    },\n  ),\n\n  id: createDecorator(\n    z.object({\n      fields: z.union([\n        z.record(\n          z.union([\n            z.literal('asc'),\n            z.literal('desc'),\n            z.literal(1),\n            z.literal(-1),\n          ]),\n        ),\n        z.array(z.string()),\n      ]),\n      auto: z.literal('increment').optional(),\n    }),\n    (state, { fields, auto }, argsNodes) => {\n      const fieldsEntries = Array.isArray(fields)\n        ? fields.map((field): [string, 'asc'] => [field, 'asc'])\n        : Object.entries(fields);\n\n      for (const [key, sort] of fieldsEntries) {\n        const field = state.fields[key];\n\n        if (!field) {\n          throw new ParsingError(\n            argsNodes.fields.value,\n            `Field ${key} does not exist`,\n          );\n        }\n\n        state.primaryKey.fields[field.name] =\n          sort === 1 || sort === 'asc' ? 'asc' : 'desc';\n      }\n\n      if (auto) {\n        state.primaryKey.auto = auto;\n      }\n    },\n  ),\n\n  index: createDecorator(\n    z.object({\n      fields: z.union([\n        z.record(\n          z.union([\n            z.literal('asc'),\n            z.literal('desc'),\n            z.literal(1),\n            z.literal(-1),\n          ]),\n        ),\n        z.array(z.string()),\n      ]),\n      unique: z.boolean().optional(),\n      name: z.string().regex(StateIndexNameRegex).optional(),\n    }),\n    (state, { fields, unique, name }, argsNodes, node) => {\n      const fieldsEntries = Array.isArray(fields)\n        ? fields.map((field): [string, 'asc'] => [field, 'asc'])\n        : Object.entries(fields);\n\n      const index: StateSortingIndex = {\n        name: name || fieldsEntries.map(([key]) => key).join('_'),\n        fields: {},\n        unique,\n      };\n\n      for (const [key, sort] of fieldsEntries) {\n        const field = state.fields[key];\n\n        if (!field) {\n          throw new ParsingError(\n            argsNodes.fields.value,\n            `Field ${key} does not exist`,\n          );\n        }\n\n        index.fields[field.name] =\n          sort === 1 || sort === 'asc' ? 'asc' : 'desc';\n      }\n\n      if (state.indexes[index.name]) {\n        throw new ParsingError(node, `Duplicate index name: ${index.name}`);\n      }\n\n      state.indexes[index.name] = index;\n\n      if (index.name) {\n        state.indexes[index.name] = index;\n      }\n    },\n  ),\n};\n\nconst applyPrimaryKey = (state: State, node: StateNode) => {\n  const { primaryKey, indexes, fields } = state;\n\n  const primaryKeys = Object.keys(primaryKey.fields);\n  if (!primaryKeys.length) {\n    throw new ParsingError(\n      node.id,\n      'State must have at least one primary key field',\n    );\n  }\n\n  if (primaryKey.auto && primaryKeys.length > 1) {\n    throw new ParsingError(\n      node.id,\n      'State with auto-incrementing primary key can only have one field',\n    );\n  }\n\n  for (const key of primaryKeys) {\n    const field = fields[key];\n\n    if (field.nullable) {\n      throw new ParsingError(\n        field.node,\n        'Primary key field cannot be nullable',\n      );\n    }\n  }\n\n  const primaryKeyName = primaryKeys.join('_');\n  primaryKey.name = primaryKeyName;\n\n  let i = 0;\n  while (indexes[primaryKey.name]) {\n    primaryKey.name = `${primaryKeyName}_${++i}`;\n  }\n\n  indexes[primaryKey.name] = primaryKey;\n};\n"],"mappings":"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","names":["ParsingError","parseArguments","nodes","parser","acc","node","key","name","ParsingError","parseArgument","type","value","ParsingError","STATE_FIELD_INDEX_MAX_INPUT_VALUE","parseStates","ParsingError","z","ParsingError","createDecorator","decoratorArgs","decorator","target","node","argsNodes","Object","fromEntries","arguments","map","arg","key","name","argsValues","entries","value","args","safeParse","success","issue","error","issues","path","ParsingError","callee","message","data","applyDecorators","nodes","decorators","parseEither","ctx","node","either","type","name","id","description","value","states","map","identifier","state","entity","ParsingError","applyDecorators","decorators","deprecated","createDecorator","z","object","reason","string","optional","args","ParsingError","z","ParsingError","ParsingError","parseEntity","ctx","node","entity","name","ParsingError","parseNonNullableEntity","type","parseType","ctx","node","type","ParsingError","parseEntityExpression","entity","parseNonNullableEntity","identifier","list","ParsingError","z","parseParametersContext","ctx","target","nodes","this","parameters","parseParameters","node","key","name","ParsingError","parseParameter","parameter","type","description","value","nullable","as","parseType","applyDecorators","decorators","deprecated","createDecorator","z","object","reason","string","optional","args","ParsingError","parseLiteral","node","type","value","parseNullLiteral","runtime","ParsingError","parseCallExpression","params","node","callee","runtime","name","ParsingError","type","arguments","parseArguments","parseExpression","ParsingError","parseIdentifierExpression","params","node","reference","parameters","name","ParsingError","type","parseLogicalExpression","params","node","type","operator","left","parseExpression","right","ParsingError","parseThisExpression","params","node","this","type","ParsingError","reference","parseMemberExpression","params","node","properties","parsePropertyExpression","property","object","type","push","parseIdentifierExpression","parseThisExpression","name","parseUnaryExpression","params","node","type","operator","argument","parseExpression","parseExpression","params","node","type","parseCallExpression","parseIdentifierExpression","parseThisExpression","parseMemberExpression","parseLiteral","parseUnaryExpression","parseBinaryExpression","parseLogicalExpression","parseNullLiteral","TypeError","parseBinaryExpression","params","node","type","operator","left","parseExpression","right","parseProperties","ctx","params","nodes","properties","length","node","property","parseProperty","name","ParsingError","key","parameter","Object","values","parameters","parseParameterProperty","type","value","parseExpression","parseIdentifierExpression","Void","type","name","parseMutation","ctx","node","target","parseTarget","returns","parseReturns","params","parseParametersContext","from","parameters","body","parseBody","mutation","type","name","Void","key","description","value","applyDecorators","decorators","deprecated","createDecorator","z","object","reason","string","optional","state","args","targetNode","entity","ParsingError","returnsNode","parseProperties","types","builtInScalars","Object","fromEntries","values","filter","value","type","map","name","ParsingError","z","StateIndexNameRegex","isStateSortingIndexEquals","sa","ia","sb","ib","unique","auto","a_keys","Object","keys","fields","b_keys","length","every","ak","i","bk","as","entity","name","list","nullable","parseStateField","ctx","node","baseIndex","as","parseType","base","name","key","nullable","index","value","description","field","entity","type","list","referenceField","applyDecorators","decorators","ParsingError","deprecated","createDecorator","z","object","reason","string","optional","args","id","sort","union","literal","auto","primaryKey","fields","unique","boolean","regex","StateIndexNameRegex","sortingIndex","reference","Object","assign","ParsingError","z","parseState","node","fields","mutations","baseIndex","state","type","name","id","description","value","primaryKey","unique","indexes","field","Object","values","sortingIndex","ParsingError","assign","auto","applyDecorators","decorators","applyPrimaryKey","deprecated","createDecorator","z","object","reason","string","optional","args","union","record","literal","array","argsNodes","fieldsEntries","Array","isArray","map","entries","key","sort","index","boolean","regex","StateIndexNameRegex","join","primaryKeys","keys","length","nullable","primaryKeyName","i","ProcessingOrder","Eithers","States","StateRelations","Mutations","EitherMutations","Transforms","StatesContext","entityMap","builtInScalars","Void","mutationMap","parent","processing","scalars","entities","states","eithers","type","key","entity","name","self","res","undefined","mutation","stateName","exec","source","filepath","document","load","inputs","documents","map","parseStates","child","item","body","register","process","embed","Object","assign","fromEntries","entries","value","node","registerEither","registerState","registerMutation","ParsingError","registerEntity","order","id","ref","push","parseEither","registerEitherMutations","fields","baseIndex","assignStateFields","mutations","parseState","registerStateRelations","registerStateTransforms","state","field","values","as","referenceField","returns","isStateSortingIndexEquals","primaryKey","form","from","entry","parseMutation","stateNode","stateMutations","target","sort","a","b","STATE_FIELD_INDEX_MAX_INPUT_VALUE","sortedFields","index","fieldNode","parseStateField","refState"]}