import { DocumentBodyNode, DocumentNode } from '@neuledge/states-parser';
import { Either } from './either';
import { Entity } from './entity';
import { Mutation } from './mutation';
import { CustomScalar } from './scalar';
import { State } from './state';
export declare class StatesContext {
    private readonly entityMap;
    private readonly mutationMap;
    private parent?;
    private processing;
    scalars(): Generator<CustomScalar, void, unknown>;
    states(): Generator<State, void, unknown>;
    eithers(): Generator<Either, void, unknown>;
    entities<T extends Entity['type']>(type?: T | null): Generator<Entity & {
        type: T;
    }, void, unknown>;
    entity<N extends string>(name: N): Entity<N> | undefined;
    mutation(stateName: string, name: string): Mutation | undefined;
    exec(source: string, filepath?: string): Promise<DocumentNode>;
    load(inputs: {
        source: string;
        filepath?: string;
    }[]): Promise<DocumentNode[]>;
    private embed;
    register(node: DocumentBodyNode): void;
    private registerEntity;
    private registerEither;
    private registerState;
    private registerStateRelations;
    private registerStateTransforms;
    private registerMutation;
    private registerEitherMutations;
    process(): void;
    /**
     * Assign the given `fields` dictionary with the fields of the given `node` state.
     * Return the calculated base index of the state.
     */
    private assignStateFields;
    private parseStateField;
}
//# sourceMappingURL=context.d.ts.map