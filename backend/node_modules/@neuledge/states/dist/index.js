"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  StateIndexNameRegex: () => StateIndexNameRegex,
  StatesContext: () => StatesContext,
  Void: () => Void,
  builtInScalars: () => builtInScalars,
  isStateSortingIndexEquals: () => isStateSortingIndexEquals,
  parseArguments: () => parseArguments,
  parseBinaryExpression: () => parseBinaryExpression,
  parseCallExpression: () => parseCallExpression,
  parseEither: () => parseEither,
  parseEntity: () => parseEntity,
  parseExpression: () => parseExpression,
  parseIdentifierExpression: () => parseIdentifierExpression,
  parseLiteral: () => parseLiteral,
  parseLogicalExpression: () => parseLogicalExpression,
  parseMemberExpression: () => parseMemberExpression,
  parseMutation: () => parseMutation,
  parseNonNullableEntity: () => parseNonNullableEntity,
  parseNullLiteral: () => parseNullLiteral,
  parseParameters: () => parseParameters,
  parseParametersContext: () => parseParametersContext,
  parseProperties: () => parseProperties,
  parseState: () => parseState,
  parseStateField: () => parseStateField,
  parseThisExpression: () => parseThisExpression,
  parseType: () => parseType,
  parseUnaryExpression: () => parseUnaryExpression
});
module.exports = __toCommonJS(src_exports);

// src/arguments.ts
var import_states_parser = require("@neuledge/states-parser");
var parseArguments = /* @__PURE__ */ __name((nodes, parser) => {
  const acc = {};
  for (const node of nodes) {
    if (node.key.name in acc) {
      throw new import_states_parser.ParsingError(node.key, `Duplicate argument '${node.key.name}'`);
    }
    acc[node.key.name] = parseArgument(node, parser);
  }
  return acc;
}, "parseArguments");
var parseArgument = /* @__PURE__ */ __name((node, parser) => ({
  type: "Argument",
  node,
  name: node.key.name,
  value: parser(node.value)
}), "parseArgument");

// src/context.ts
var import_states_parser14 = require("@neuledge/states-parser");

// src/either.ts
var import_states_parser3 = require("@neuledge/states-parser");
var import_zod = require("zod");

// src/decorators.ts
var import_states_parser2 = require("@neuledge/states-parser");
var createDecorator = /* @__PURE__ */ __name((decoratorArgs, decorator) => (target, node) => {
  const argsNodes = Object.fromEntries(node.arguments.map((arg) => [
    arg.key.name,
    arg
  ]));
  const argsValues = Object.fromEntries(Object.entries(argsNodes).map(([key, value]) => [
    key,
    value.value?.value
  ]));
  const args = decoratorArgs.safeParse(argsValues);
  if (!args.success) {
    const [issue] = args.error.issues;
    const key = issue.path[0];
    throw new import_states_parser2.ParsingError(argsNodes[key] ?? node.callee, `Invalid '@${node.callee.name}()' decorator on argument '${key}': ${issue.message}`);
  }
  return decorator(target, args.data, argsNodes, node);
}, "createDecorator");
var applyDecorators = /* @__PURE__ */ __name((target, nodes, decorators6) => {
  for (const node of nodes) {
    const { name } = node.callee;
    const decorator = decorators6[name];
    if (decorator) {
      decorator(target, node);
    }
  }
}, "applyDecorators");

// src/either.ts
var parseEither = /* @__PURE__ */ __name((ctx, node) => {
  const either = {
    type: "Either",
    node,
    name: node.id.name,
    description: node.description?.value,
    states: node.states.map((identifier) => {
      const state = ctx.entity(identifier.name);
      if (state?.type !== "State") {
        throw new import_states_parser3.ParsingError(identifier, `Unknown state name '${identifier.name}'`);
      }
      return state;
    })
  };
  applyDecorators(either, node.decorators, decorators);
  return either;
}, "parseEither");
var decorators = {
  deprecated: createDecorator(import_zod.z.object({
    reason: import_zod.z.string().optional()
  }), (state, args) => {
    state.deprecated = args.reason || true;
  })
};

// src/mutation/index.ts
var import_states_parser11 = require("@neuledge/states-parser");
var import_zod3 = require("zod");

// src/type.ts
var import_states_parser5 = require("@neuledge/states-parser");

// src/entity.ts
var import_states_parser4 = require("@neuledge/states-parser");
var parseEntity = /* @__PURE__ */ __name((ctx, node) => {
  const entity = ctx.entity(node.name);
  if (!entity) {
    throw new import_states_parser4.ParsingError(node, `Unknown entity name '${node.name}'`);
  }
  return entity;
}, "parseEntity");
var parseNonNullableEntity = /* @__PURE__ */ __name((ctx, node) => {
  const entity = ctx.entity(node.name);
  if (!entity) {
    throw new import_states_parser4.ParsingError(node, `Unknown entity name '${node.name}'`);
  }
  if (entity.type === "Void") {
    throw new import_states_parser4.ParsingError(node, `Void entity is nullable`);
  }
  return entity;
}, "parseNonNullableEntity");

// src/type.ts
var parseType = /* @__PURE__ */ __name((ctx, node) => {
  if (node.type === "TypeGenerator") {
    throw new import_states_parser5.ParsingError(node, "Not implemented");
  }
  return parseEntityExpression(ctx, node);
}, "parseType");
var parseEntityExpression = /* @__PURE__ */ __name((ctx, node) => ({
  type: "EntityExpression",
  node,
  entity: parseNonNullableEntity(ctx, node.identifier),
  list: node.list
}), "parseEntityExpression");

// src/parameter.ts
var import_states_parser6 = require("@neuledge/states-parser");
var import_zod2 = require("zod");
var parseParametersContext = /* @__PURE__ */ __name((ctx, target, nodes) => ({
  this: target,
  parameters: parseParameters(ctx, nodes)
}), "parseParametersContext");
var parseParameters = /* @__PURE__ */ __name((ctx, nodes) => {
  const parameters = {};
  for (const node of nodes) {
    if (node.key.name in parameters) {
      throw new import_states_parser6.ParsingError(node.key, `Duplicate parameter name '${node.key.name}'`);
    }
    parameters[node.key.name] = parseParameter(ctx, node);
  }
  return parameters;
}, "parseParameters");
var parseParameter = /* @__PURE__ */ __name((ctx, node) => {
  const parameter = {
    type: "Parameter",
    node,
    name: node.key.name,
    description: node.description?.value,
    nullable: node.nullable,
    as: parseType(ctx, node.as)
  };
  applyDecorators(parameter, node.decorators, decorators2);
  return parameter;
}, "parseParameter");
var decorators2 = {
  deprecated: createDecorator(import_zod2.z.object({
    reason: import_zod2.z.string().optional()
  }), (parameter, args) => {
    parameter.deprecated = args.reason || true;
  })
};

// src/property.ts
var import_states_parser10 = require("@neuledge/states-parser");

// src/literal.ts
var parseLiteral = /* @__PURE__ */ __name((node) => ({
  type: "Literal",
  node,
  value: node.value
}), "parseLiteral");
var parseNullLiteral = /* @__PURE__ */ __name((node) => ({
  type: "NullLiteral",
  node,
  value: null
}), "parseNullLiteral");

// src/expression/call.ts
var import_scalars = require("@neuledge/scalars");
var import_states_parser7 = require("@neuledge/states-parser");
var parseCallExpression = /* @__PURE__ */ __name((params, node) => {
  const callee = import_scalars.runtime[node.callee.name];
  if (!callee) {
    throw new import_states_parser7.ParsingError(node.callee, `Unknown runtime function '${node.callee.name}'`);
  }
  return {
    type: "CallExpression",
    node,
    callee,
    arguments: parseArguments(node.arguments, (node2) => parseExpression(params, node2))
  };
}, "parseCallExpression");

// src/expression/identifier.ts
var import_states_parser8 = require("@neuledge/states-parser");
var parseIdentifierExpression = /* @__PURE__ */ __name((params, node) => {
  const reference = params.parameters[node.name];
  if (!reference) {
    throw new import_states_parser8.ParsingError(node, `Unknown identifier '${node.name}'`);
  }
  return {
    type: "IdentifierExpression",
    node,
    reference
  };
}, "parseIdentifierExpression");

// src/expression/logical.ts
var parseLogicalExpression = /* @__PURE__ */ __name((params, node) => ({
  type: "LogicalExpression",
  node,
  operator: node.operator,
  left: parseExpression(params, node.left),
  right: parseExpression(params, node.right)
}), "parseLogicalExpression");

// src/expression/this.ts
var import_states_parser9 = require("@neuledge/states-parser");
var parseThisExpression = /* @__PURE__ */ __name((params, node) => {
  if (params.this?.type !== "State") {
    throw new import_states_parser9.ParsingError(node, "ThisExpression is not allowed here");
  }
  return {
    type: "ThisExpression",
    node,
    reference: params.this
  };
}, "parseThisExpression");

// src/expression/member.ts
var parseMemberExpression = /* @__PURE__ */ __name((params, node) => {
  const properties = [
    parsePropertyExpression(params, node.property)
  ];
  while (node.object.type === "MemberExpression") {
    properties.push(parsePropertyExpression(params, node.object.property));
    node = node.object;
  }
  const object = node.object.type === "Identifier" ? parseIdentifierExpression(params, node.object) : parseThisExpression(params, node.object);
  return {
    type: "MemberExpression",
    node,
    object,
    properties
  };
}, "parseMemberExpression");
var parsePropertyExpression = /* @__PURE__ */ __name((params, node) => ({
  type: "PropertyExpression",
  node,
  name: node.name
}), "parsePropertyExpression");

// src/expression/unary.ts
var parseUnaryExpression = /* @__PURE__ */ __name((params, node) => ({
  type: "UnaryExpression",
  node,
  operator: node.operator,
  argument: parseExpression(params, node.argument)
}), "parseUnaryExpression");

// src/expression/expression.ts
var parseExpression = /* @__PURE__ */ __name((params, node) => {
  switch (node.type) {
    case "CallExpression": {
      return parseCallExpression(params, node);
    }
    case "Identifier": {
      return parseIdentifierExpression(params, node);
    }
    case "ThisExpression": {
      return parseThisExpression(params, node);
    }
    case "MemberExpression": {
      return parseMemberExpression(params, node);
    }
    case "Literal": {
      return parseLiteral(node);
    }
    case "UnaryExpression": {
      return parseUnaryExpression(params, node);
    }
    case "BinaryExpression": {
      return parseBinaryExpression(params, node);
    }
    case "LogicalExpression": {
      return parseLogicalExpression(params, node);
    }
    case "NullLiteral": {
      return parseNullLiteral(node);
    }
    default: {
      throw new TypeError(`Unexpected expression type: ${node.type}`);
    }
  }
}, "parseExpression");

// src/expression/binary.ts
var parseBinaryExpression = /* @__PURE__ */ __name((params, node) => ({
  type: "BinaryExpression",
  node,
  operator: node.operator,
  left: parseExpression(params, node.left),
  right: parseExpression(params, node.right)
}), "parseBinaryExpression");

// src/property.ts
var parseProperties = /* @__PURE__ */ __name((ctx, params, nodes) => {
  const properties = {};
  if (nodes.length) {
    for (const node of nodes) {
      const property = parseProperty(params, node);
      if (properties[property.name]) {
        throw new import_states_parser10.ParsingError(node.key, `Duplicate property '${property.name}'`);
      }
      properties[property.name] = property;
    }
  } else {
    for (const parameter of Object.values(params.parameters)) {
      properties[parameter.name] = parseParameterProperty(params, parameter);
    }
  }
  return properties;
}, "parseProperties");
var parseProperty = /* @__PURE__ */ __name((params, node) => ({
  type: "Property",
  node,
  name: node.key.name,
  value: parseExpression(params, node.value)
}), "parseProperty");
var parseParameterProperty = /* @__PURE__ */ __name((params, parameter) => ({
  type: "Property",
  name: parameter.name,
  value: parseIdentifierExpression(params, parameter.node.key)
}), "parseParameterProperty");

// src/void.ts
var Void = {
  type: "Void",
  name: "Void"
};

// src/mutation/index.ts
var parseMutation = /* @__PURE__ */ __name((ctx, node) => {
  const target = parseTarget(ctx, node);
  const returns = parseReturns(ctx, node, target);
  const params = parseParametersContext(ctx, node.from ? target : null, node.parameters);
  const body = parseBody(ctx, params, node);
  const mutation = {
    type: "Mutation",
    node,
    ...params,
    mutation: node.from ? returns.name === Void.name ? "delete" : "update" : "create",
    name: node.key.name,
    description: node.description?.value,
    target,
    returns,
    body
  };
  applyDecorators(mutation, node.decorators, decorators3);
  return mutation;
}, "parseMutation");
var decorators3 = {
  deprecated: createDecorator(import_zod3.z.object({
    reason: import_zod3.z.string().optional()
  }), (state, args) => {
    state.deprecated = args.reason || true;
  })
};
var parseTarget = /* @__PURE__ */ __name((ctx, node) => {
  const targetNode = node.from ?? node.returns;
  const target = ctx.entity(targetNode.name);
  if (!target) {
    throw new import_states_parser11.ParsingError(targetNode, `Unknown entity name '${targetNode.name}'`);
  }
  if (node.from) {
    if (target.type !== "State" && target.type !== "Either") {
      throw new import_states_parser11.ParsingError(targetNode, `Expected state or either, got '${target.type}'`);
    }
  } else if (target.type !== "State") {
    throw new import_states_parser11.ParsingError(targetNode, `Expected state, got '${target.type}'`);
  }
  return target;
}, "parseTarget");
var parseReturns = /* @__PURE__ */ __name((ctx, node, target) => {
  const returnsNode = node.returns;
  const returns = ctx.entity(returnsNode.name);
  if (!returns) {
    throw new import_states_parser11.ParsingError(returnsNode, `Unknown entity name '${returnsNode.name}'`);
  }
  switch (returns.type) {
    case "State":
    case "Void": {
      break;
    }
    case "Either": {
      if (target.type !== "Either") {
        throw new import_states_parser11.ParsingError(returnsNode, `Expected state or void, got '${returns.type}'`);
      }
      if (target.name !== returns.name) {
        throw new import_states_parser11.ParsingError(returnsNode, `Expected either '${target.name}', got '${returns.name}'`);
      }
      break;
    }
    case "Scalar": {
      throw new import_states_parser11.ParsingError(returnsNode, `Expected state or void, got '${returns.type}'`);
    }
  }
  return returns;
}, "parseReturns");
var parseBody = /* @__PURE__ */ __name((ctx, params, node) => parseProperties(ctx, params, node.body), "parseBody");

// src/scalar.ts
var import_scalars2 = require("@neuledge/scalars");
var builtInScalars = Object.fromEntries(Object.values(import_scalars2.types).filter((value) => value?.type === "Scalar").map((value) => [
  value.name,
  value
]));

// src/state/field.ts
var import_states_parser12 = require("@neuledge/states-parser");
var import_zod4 = require("zod");

// src/state/state-index.ts
var StateIndexNameRegex = /^[\w.]+$/i;
var isStateSortingIndexEquals = /* @__PURE__ */ __name((sa, ia, sb, ib) => {
  if (!ia.unique !== !ib.unique && ia.auto !== ib.auto) {
    return false;
  }
  const a_keys = Object.keys(ia.fields);
  const b_keys = Object.keys(ib.fields);
  if (a_keys.length !== b_keys.length) {
    return false;
  }
  return a_keys.every((ak, i) => {
    const bk = b_keys[i];
    return ia.fields[ak] === ib.fields[bk] && sa.fields[ak].as.entity.name === sb.fields[bk].as.entity.name && !sa.fields[ak].as.list === !sb.fields[bk].as.list && !sa.fields[ak].nullable === !sb.fields[bk].nullable;
  });
}, "isStateSortingIndexEquals");

// src/state/field.ts
var parseStateField = /* @__PURE__ */ __name((ctx, node, baseIndex) => {
  const as = parseType(ctx, node.as);
  const base = {
    node,
    name: node.key.name,
    nullable: node.nullable,
    index: node.index.value + baseIndex,
    description: node.description?.value,
    as
  };
  const field = as.entity.type === "Scalar" || !as.list ? {
    type: "ScalarField",
    ...base
  } : {
    type: "RelationField",
    ...base,
    referenceField: null
  };
  applyDecorators(field, node.decorators, decorators4);
  if (field.type === "RelationField" && !field.referenceField) {
    throw new import_states_parser12.ParsingError(node, `Relation field '${field.name}' must have a '@reference()' field annotation`);
  }
  return field;
}, "parseStateField");
var decorators4 = {
  deprecated: createDecorator(import_zod4.z.object({
    reason: import_zod4.z.string().optional()
  }), (field, args) => {
    field.deprecated = args.reason || true;
  }),
  id: createDecorator(import_zod4.z.object({
    sort: import_zod4.z.union([
      import_zod4.z.literal("asc"),
      import_zod4.z.literal("desc"),
      import_zod4.z.literal(1),
      import_zod4.z.literal(-1)
    ]).optional(),
    auto: import_zod4.z.literal("increment").optional()
  }), (field, { sort, auto }) => {
    if (field.type !== "ScalarField") {
      throw new import_states_parser12.ParsingError(field.node, `@id can only be applied to scalar fields`);
    }
    if (field.primaryKey) {
      throw new import_states_parser12.ParsingError(field.node, `Duplicate @id on field '${field.name}'`);
    }
    field.primaryKey = {
      name: field.name,
      fields: {
        [field.name]: sort == null || sort === "asc" || sort === 1 ? "asc" : "desc"
      },
      unique: true,
      auto
    };
  }),
  index: createDecorator(import_zod4.z.object({
    sort: import_zod4.z.union([
      import_zod4.z.literal("asc"),
      import_zod4.z.literal("desc"),
      import_zod4.z.literal(1),
      import_zod4.z.literal(-1)
    ]).optional(),
    unique: import_zod4.z.boolean().optional(),
    name: import_zod4.z.string().regex(StateIndexNameRegex).optional()
  }), (field, { sort, unique, name }) => {
    if (field.type !== "ScalarField") {
      throw new import_states_parser12.ParsingError(field.node, `@index can only be applied to scalar fields`);
    }
    if (field.sortingIndex) {
      throw new import_states_parser12.ParsingError(field.node, `Duplicate @index or @unique on field '${field.name}'`);
    }
    field.sortingIndex = {
      name: name || field.name,
      fields: {
        [field.name]: sort == null || sort === "asc" || sort === 1 ? "asc" : "desc"
      },
      unique
    };
  }),
  unique: createDecorator(import_zod4.z.object({
    sort: import_zod4.z.union([
      import_zod4.z.literal("asc"),
      import_zod4.z.literal("desc"),
      import_zod4.z.literal(1),
      import_zod4.z.literal(-1)
    ]).optional(),
    name: import_zod4.z.string().regex(StateIndexNameRegex).optional()
  }), (field, { sort, name }) => {
    if (field.type !== "ScalarField") {
      throw new import_states_parser12.ParsingError(field.node, `@unique can only be applied to scalar fields`);
    }
    if (field.sortingIndex) {
      throw new import_states_parser12.ParsingError(field.node, `Duplicate @unique or @index on field '${field.name}'`);
    }
    field.sortingIndex = {
      name: name || field.name,
      fields: {
        [field.name]: sort == null || sort === "asc" || sort === 1 ? "asc" : "desc"
      },
      unique: true
    };
  }),
  reference: createDecorator(import_zod4.z.object({
    field: import_zod4.z.string().regex(/^[_a-z]\w*$/i)
  }), (field, { field: referenceField }) => {
    if (field.type === "RelationField" && field.referenceField) {
      throw new import_states_parser12.ParsingError(field.node, `Duplicate @reference on field '${field.name}'`);
    }
    Object.assign(field, {
      type: "RelationField",
      referenceField
    });
  })
};

// src/state/state.ts
var import_states_parser13 = require("@neuledge/states-parser");
var import_zod5 = require("zod");
var parseState = /* @__PURE__ */ __name((node, fields, mutations, baseIndex) => {
  const state = {
    type: "State",
    node,
    name: node.id.name,
    description: node.description?.value,
    fields,
    primaryKey: {
      name: "",
      fields: {},
      unique: true
    },
    indexes: {},
    mutations,
    baseIndex
  };
  for (const field of Object.values(fields)) {
    if (field.type !== "ScalarField")
      continue;
    const { sortingIndex, primaryKey } = field;
    if (sortingIndex) {
      if (state.indexes[sortingIndex.name]) {
        throw new import_states_parser13.ParsingError(field.node, `Index '${sortingIndex.name}' already exists`);
      }
      state.indexes[sortingIndex.name] = sortingIndex;
    }
    if (primaryKey) {
      Object.assign(state.primaryKey.fields, primaryKey.fields);
      if (primaryKey.auto) {
        state.primaryKey.auto = primaryKey.auto;
      }
    }
  }
  applyDecorators(state, node.decorators, decorators5);
  applyPrimaryKey(state, node);
  return state;
}, "parseState");
var decorators5 = {
  deprecated: createDecorator(import_zod5.z.object({
    reason: import_zod5.z.string().optional()
  }), (state, args) => {
    state.deprecated = args.reason || true;
  }),
  id: createDecorator(import_zod5.z.object({
    fields: import_zod5.z.union([
      import_zod5.z.record(import_zod5.z.union([
        import_zod5.z.literal("asc"),
        import_zod5.z.literal("desc"),
        import_zod5.z.literal(1),
        import_zod5.z.literal(-1)
      ])),
      import_zod5.z.array(import_zod5.z.string())
    ]),
    auto: import_zod5.z.literal("increment").optional()
  }), (state, { fields, auto }, argsNodes) => {
    const fieldsEntries = Array.isArray(fields) ? fields.map((field) => [
      field,
      "asc"
    ]) : Object.entries(fields);
    for (const [key, sort] of fieldsEntries) {
      const field = state.fields[key];
      if (!field) {
        throw new import_states_parser13.ParsingError(argsNodes.fields.value, `Field ${key} does not exist`);
      }
      state.primaryKey.fields[field.name] = sort === 1 || sort === "asc" ? "asc" : "desc";
    }
    if (auto) {
      state.primaryKey.auto = auto;
    }
  }),
  index: createDecorator(import_zod5.z.object({
    fields: import_zod5.z.union([
      import_zod5.z.record(import_zod5.z.union([
        import_zod5.z.literal("asc"),
        import_zod5.z.literal("desc"),
        import_zod5.z.literal(1),
        import_zod5.z.literal(-1)
      ])),
      import_zod5.z.array(import_zod5.z.string())
    ]),
    unique: import_zod5.z.boolean().optional(),
    name: import_zod5.z.string().regex(StateIndexNameRegex).optional()
  }), (state, { fields, unique, name }, argsNodes, node) => {
    const fieldsEntries = Array.isArray(fields) ? fields.map((field) => [
      field,
      "asc"
    ]) : Object.entries(fields);
    const index = {
      name: name || fieldsEntries.map(([key]) => key).join("_"),
      fields: {},
      unique
    };
    for (const [key, sort] of fieldsEntries) {
      const field = state.fields[key];
      if (!field) {
        throw new import_states_parser13.ParsingError(argsNodes.fields.value, `Field ${key} does not exist`);
      }
      index.fields[field.name] = sort === 1 || sort === "asc" ? "asc" : "desc";
    }
    if (state.indexes[index.name]) {
      throw new import_states_parser13.ParsingError(node, `Duplicate index name: ${index.name}`);
    }
    state.indexes[index.name] = index;
    if (index.name) {
      state.indexes[index.name] = index;
    }
  })
};
var applyPrimaryKey = /* @__PURE__ */ __name((state, node) => {
  const { primaryKey, indexes, fields } = state;
  const primaryKeys = Object.keys(primaryKey.fields);
  if (!primaryKeys.length) {
    throw new import_states_parser13.ParsingError(node.id, "State must have at least one primary key field");
  }
  if (primaryKey.auto && primaryKeys.length > 1) {
    throw new import_states_parser13.ParsingError(node.id, "State with auto-incrementing primary key can only have one field");
  }
  for (const key of primaryKeys) {
    const field = fields[key];
    if (field.nullable) {
      throw new import_states_parser13.ParsingError(field.node, "Primary key field cannot be nullable");
    }
  }
  const primaryKeyName = primaryKeys.join("_");
  primaryKey.name = primaryKeyName;
  let i = 0;
  while (indexes[primaryKey.name]) {
    primaryKey.name = `${primaryKeyName}_${++i}`;
  }
  indexes[primaryKey.name] = primaryKey;
}, "applyPrimaryKey");

// src/context.ts
var ProcessingOrder;
(function(ProcessingOrder2) {
  ProcessingOrder2[ProcessingOrder2["Eithers"] = 10] = "Eithers";
  ProcessingOrder2[ProcessingOrder2["States"] = 20] = "States";
  ProcessingOrder2[ProcessingOrder2["StateRelations"] = 21] = "StateRelations";
  ProcessingOrder2[ProcessingOrder2["Mutations"] = 30] = "Mutations";
  ProcessingOrder2[ProcessingOrder2["EitherMutations"] = 31] = "EitherMutations";
  ProcessingOrder2[ProcessingOrder2["Transforms"] = 40] = "Transforms";
})(ProcessingOrder || (ProcessingOrder = {}));
var StatesContext = class {
  entityMap = {
    ...builtInScalars,
    Void
  };
  mutationMap = {};
  parent;
  processing = [];
  // iterators
  *scalars() {
    yield* this.entities("Scalar");
  }
  *states() {
    yield* this.entities("State");
  }
  *eithers() {
    yield* this.entities("Either");
  }
  *entities(type) {
    for (const key in this.entityMap) {
      const entity = this.entityMap[key];
      if (type == null || entity?.type === type) {
        yield entity;
      }
    }
  }
  // getters
  entity(name) {
    let self = this;
    do {
      const res = this.entityMap[name];
      if (res)
        return res;
    } while (self = self.parent);
    return void 0;
  }
  mutation(stateName, name) {
    const key = `${stateName || ""}.${name}`;
    let self = this;
    do {
      const res = this.mutationMap[key]?.[name];
      if (res)
        return res;
    } while (self = self.parent);
    return void 0;
  }
  // executors
  async exec(source, filepath) {
    const [document] = await this.load([
      {
        source,
        filepath
      }
    ]);
    return document;
  }
  async load(inputs) {
    const documents = inputs.map(({ source, filepath }) => (0, import_states_parser14.parseStates)(source, filepath));
    const child = new StatesContext();
    child.parent = this;
    for (const document of documents) {
      for (const item of document.body) {
        child.register(item);
      }
    }
    child.process();
    this.embed(child);
    return documents;
  }
  embed(child) {
    Object.assign(this.entityMap, child.entityMap);
    Object.assign(this.mutationMap, Object.fromEntries(Object.entries(child.mutationMap).map(([key, value]) => [
      key,
      Object.assign(this.mutationMap[key] ?? {}, value)
    ])));
  }
  // registerers
  register(node) {
    switch (node.type) {
      case "Either": {
        this.registerEither(node);
        break;
      }
      case "Scalar": {
        break;
      }
      case "State": {
        this.registerState(node);
        break;
      }
      case "Mutation": {
        this.registerMutation(node);
        break;
      }
      case "Migration": {
        break;
      }
      default: {
        throw new import_states_parser14.ParsingError(
          node,
          // @ts-expect-error `node.type` should be never
          `Unsupported document node '${node.type}'`
        );
      }
    }
  }
  registerEntity(node, order, process) {
    const { name } = node.id;
    if (this.entity(name)) {
      throw new import_states_parser14.ParsingError(node.id, `An entity name '${name}' already defined`);
    }
    const ref = {
      type: node.type,
      node
    };
    this.entityMap[name] = ref;
    this.processing.push({
      order,
      process: () => Object.assign(ref, process(ref))
    });
  }
  registerEither(node) {
    this.registerEntity(node, ProcessingOrder.Eithers, () => parseEither(this, node));
    this.registerEitherMutations(node);
  }
  registerState(node) {
    this.registerEntity(node, ProcessingOrder.States, (ref) => {
      const fields = {};
      const baseIndex = this.assignStateFields(node, ref, fields);
      let mutations = this.mutationMap[node.id.name];
      if (!mutations) {
        mutations = this.mutationMap[node.id.name] = {};
      }
      return parseState(node, fields, mutations, baseIndex);
    });
    this.registerStateRelations(node);
    this.registerStateTransforms(node);
  }
  registerStateRelations(node) {
    this.processing.push({
      order: ProcessingOrder.StateRelations,
      process: () => {
        const state = this.entity(node.id.name);
        for (const field of Object.values(state.fields)) {
          if (field.type !== "RelationField")
            continue;
          const { entity } = field.as;
          if (entity.type === "Scalar") {
            throw new import_states_parser14.ParsingError(field.node, `A relation field '${field.name}' must be a state or an either`);
          }
          const states = entity.type === "State" ? [
            entity
          ] : entity.states;
          const { referenceField } = field;
          for (const state2 of states) {
            if (state2.fields[referenceField])
              continue;
            throw new import_states_parser14.ParsingError(field.node, `A relation field '${field.name}' must reference a field '${referenceField}' in state '${state2.name}', but it does not exist`);
          }
        }
      }
    });
  }
  registerStateTransforms(node) {
    this.processing.push({
      order: ProcessingOrder.Transforms,
      process: () => {
        const state = this.entity(node.id.name);
        const mutations = this.mutationMap[node.id.name] ?? {};
        for (const mutation of Object.values(mutations)) {
          if (mutation?.mutation !== "update")
            continue;
          const returns = mutation.returns;
          if (returns.name !== state.name) {
            continue;
          }
          if (returns.type !== "State" || !isStateSortingIndexEquals(state, state.primaryKey, returns, returns.primaryKey)) {
            throw new import_states_parser14.ParsingError(mutation.node.key, `A mutation for state '${state.name}' must return a state with the same primary key as the original state`);
          }
        }
      }
    });
  }
  registerMutation(node) {
    const form = node.from ?? node.returns;
    if (this.mutation(form.name, node.key.name)) {
      throw new import_states_parser14.ParsingError(node.key, `The mutation name '${node.key.name}'${node.from ? ` for '${node.from.name}'` : ""} already defined`);
    }
    let entry = this.mutationMap[form.name];
    if (!entry) {
      entry = {};
      this.mutationMap[form.name] = entry;
    }
    const ref = {
      type: node.type,
      node
    };
    entry[node.key.name] = ref;
    this.processing.push({
      order: ProcessingOrder.Mutations,
      process: () => Object.assign(ref, parseMutation(this, node))
    });
  }
  registerEitherMutations(node) {
    this.processing.push({
      order: ProcessingOrder.EitherMutations,
      process: () => {
        const mutations = this.mutationMap[node.id.name] ?? {};
        for (const stateNode of node.states) {
          const state = this.entity(stateNode.name);
          let stateMutations = this.mutationMap[state.name];
          if (!stateMutations) {
            this.mutationMap[state.name] = stateMutations = {};
          }
          for (const name in mutations) {
            const mutation = mutations[name];
            if (stateMutations[name] || !mutation) {
              continue;
            }
            stateMutations[name] = {
              ...mutation,
              target: state,
              returns: !mutation.node.from || mutation.node.returns.name === mutation.node.from.name ? state : mutation.returns
            };
          }
        }
      }
    });
  }
  // processors
  process() {
    this.processing.sort((a, b) => a.order - b.order);
    for (const { process } of this.processing) {
      process();
    }
    this.processing = [];
  }
  /**
  * Assign the given `fields` dictionary with the fields of the given `node` state.
  * Return the calculated base index of the state.
  */
  assignStateFields(node, ref, fields) {
    if ("fields" in ref) {
      if (ref.baseIndex == null || ref.fields == null) {
        throw new import_states_parser14.ParsingError(node.id, `Circular dependency detected`);
      }
      Object.assign(fields, ref.fields);
      return ref.baseIndex;
    }
    ref.fields = void 0;
    let baseIndex = 0;
    if (node.from) {
      const parent = this.entity(node.from.name);
      if (parent?.type !== "State") {
        throw new import_states_parser14.ParsingError(node.from, `Unknown state name '${node.from.name}'`);
      }
      baseIndex += this.assignStateFields(parent.node, parent, fields) + import_states_parser14.STATE_FIELD_INDEX_MAX_INPUT_VALUE;
    }
    const sortedFields = [
      ...node.fields
    ].sort((a, b) => ("index" in a ? a.index.value : 0) - ("index" in b ? b.index.value : 0));
    for (const fieldNode of sortedFields) {
      const field = this.parseStateField(fieldNode, baseIndex);
      if (!field) {
        if (!fields[fieldNode.key.name]) {
          throw new import_states_parser14.ParsingError(fieldNode.key, `Unknown field name '${fieldNode.key.name}'`);
        }
        delete fields[fieldNode.key.name];
        continue;
      }
      fields[field.name] = field;
    }
    ref.fields = fields;
    ref.baseIndex = baseIndex;
    return baseIndex;
  }
  parseStateField(node, baseIndex) {
    switch (node.type) {
      case "Field": {
        return parseStateField(this, node, baseIndex);
      }
      case "ReferenceField": {
        const refState = this.entity(node.state.name);
        if (refState?.type !== "State") {
          throw new import_states_parser14.ParsingError(node.state, `Unknown state name '${node.state.name}'`);
        }
        const fields = {};
        this.assignStateFields(refState.node, refState, fields);
        const field = fields[node.key.name];
        if (!field) {
          throw new import_states_parser14.ParsingError(node.key, `Undefined field name '${node.key.name}' on state '${node.state.name}'`);
        }
        return {
          ...field,
          index: node.index.value + baseIndex
        };
      }
      case "ExcludedField": {
        return null;
      }
    }
  }
};
__name(StatesContext, "StatesContext");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  StateIndexNameRegex,
  StatesContext,
  Void,
  builtInScalars,
  isStateSortingIndexEquals,
  parseArguments,
  parseBinaryExpression,
  parseCallExpression,
  parseEither,
  parseEntity,
  parseExpression,
  parseIdentifierExpression,
  parseLiteral,
  parseLogicalExpression,
  parseMemberExpression,
  parseMutation,
  parseNonNullableEntity,
  parseNullLiteral,
  parseParameters,
  parseParametersContext,
  parseProperties,
  parseState,
  parseStateField,
  parseThisExpression,
  parseType,
  parseUnaryExpression
});
//# sourceMappingURL=index.js.map