/// <reference types="node" />
import { StateDefinition } from '../../definitions';
import { StateFieldSnapshot } from './field';
export type StateSnapshotHash = Buffer;
export interface StateRelationSnapshot {
    name: string;
    states: StateSnapshot[];
    path?: string;
    index: number;
}
export declare class StateSnapshot {
    collectionName: string;
    name: string;
    hash: StateSnapshotHash;
    fields: StateFieldSnapshot[];
    instance?: StateDefinition;
    relations: StateRelationSnapshot[];
    /**
     * Check that the origin state matches the current state signature.
     * The state can match if one of the following conditions is true:
     * - the hash is the same
     * - the current state has all the required fields of the origin state
     */
    matches(origin: StateSnapshot): boolean;
    /**
     * Sync the current state with the origin state.
     * This will update the collection name and store field names to match the
     * origin state representation on the store. This is useful when the state
     * rename a field and we want to keep the same name on the store for backward
     * compatibility.
     */
    sync(origin: StateSnapshot): void;
    clone(): this;
    assign(origin: Omit<StateSnapshot, 'matches' | 'sync' | 'clone' | 'assign'>): this;
}
export declare const generateStateHash: (state: Pick<StateSnapshot, 'fields' | 'relations'>) => StateSnapshotHash;
//# sourceMappingURL=snapshot.d.ts.map