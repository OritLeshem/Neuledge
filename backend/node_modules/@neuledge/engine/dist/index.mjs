var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "../../node_modules/tsup/assets/esm_shims.js"() {
  }
});

// ../../node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS({
  "../../node_modules/fast-deep-equal/es6/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = /* @__PURE__ */ __name(function equal2(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i]))
              return false;
          return true;
        }
        if (a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          for (i of a.entries())
            if (!b.has(i[0]))
              return false;
          for (i of a.entries())
            if (!equal2(i[1], b.get(i[0])))
              return false;
          return true;
        }
        if (a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          for (i of a.entries())
            if (!b.has(i[0]))
              return false;
          return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }, "equal");
  }
});

// src/index.ts
init_esm_shims();

// src/definitions/index.ts
init_esm_shims();

// src/definitions/either.ts
init_esm_shims();
var createEitherDefintion = /* @__PURE__ */ __name((name, states) => Object.assign([
  ...states
], {
  $name: name
}), "createEitherDefintion");

// src/definitions/mutations/index.ts
init_esm_shims();

// src/definitions/mutations/generator.ts
init_esm_shims();
function createMutation(type, mutation) {
  return Object.assign(mutation ?? (() => void 0), {
    mutation: type,
    virtual: !mutation
  });
}
__name(createMutation, "createMutation");

// src/definitions/mutations/mutation.ts
init_esm_shims();

// src/definitions/mutations/state-helpers.ts
init_esm_shims();

// src/definitions/state/index.ts
init_esm_shims();

// src/definitions/state/decorator.ts
init_esm_shims();

// src/error.ts
init_esm_shims();
import { StoreError } from "@neuledge/store";
var NeuledgeErrorCode;
(function(NeuledgeErrorCode2) {
  NeuledgeErrorCode2[
    // version checks
    "VERSION_MISMATCH"
  ] = "VERSION_MISMATCH";
  NeuledgeErrorCode2[
    // argument errors
    "INVALID_ARGUMENT"
  ] = "INVALID_ARGUMENT";
  NeuledgeErrorCode2[
    // document checks
    "DOCUMENT_NOT_FOUND"
  ] = "DOCUMENT_NOT_FOUND";
  NeuledgeErrorCode2[
    // collection checks
    "NO_COLLECTIONS"
  ] = "NO_COLLECTIONS";
  NeuledgeErrorCode2["MULTIPLE_COLLECTIONS"] = "MULTIPLE_COLLECTIONS";
  NeuledgeErrorCode2[
    // state checks
    "ENTITY_STATE_NOT_FOUND"
  ] = "ENTITY_STATE_NOT_FOUND";
  NeuledgeErrorCode2["RESERVED_FIELD_NAME"] = "RESERVED_FIELD_NAME";
  NeuledgeErrorCode2["DUPLICATE_STATE_NAME"] = "DUPLICATE_STATE_NAME";
  NeuledgeErrorCode2[
    // sort checks
    "UNKNOWN_SORT_DIRECTION"
  ] = "UNKNOWN_SORT_DIRECTION";
  NeuledgeErrorCode2["UNKNOWN_SORT_INDEX"] = "UNKNOWN_SORT_INDEX";
  NeuledgeErrorCode2["UNKNOWN_SORT_FIELD"] = "UNKNOWN_SORT_FIELD";
  NeuledgeErrorCode2[
    // relation checks
    "RELATION_FIELD_NOT_FOUND"
  ] = "RELATION_FIELD_NOT_FOUND";
  NeuledgeErrorCode2["RELATION_STATE_NOT_FOUND"] = "RELATION_STATE_NOT_FOUND";
  NeuledgeErrorCode2[
    // query checks
    "QUERY_PARSING_ERROR"
  ] = "QUERY_PARSING_ERROR";
  NeuledgeErrorCode2["QUERY_EXECUTION_ERROR"] = "QUERY_EXECUTION_ERROR";
  NeuledgeErrorCode2["INVALID_MUTATION"] = "INVALID_MUTATION";
  NeuledgeErrorCode2[
    // metadata checks
    "UNSUPPORTED_METADATA"
  ] = "UNSUPPORTED_METADATA";
  NeuledgeErrorCode2["CORRUPTED_METADATA"] = "CORRUPTED_METADATA";
  NeuledgeErrorCode2["METADATA_SAVE_ERROR"] = "METADATA_SAVE_ERROR";
  NeuledgeErrorCode2["METADATA_LOAD_ERROR"] = "METADATA_LOAD_ERROR";
  NeuledgeErrorCode2[
    // internal errors
    "INTERNAL_ERROR"
  ] = "INTERNAL_ERROR";
  NeuledgeErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
})(NeuledgeErrorCode || (NeuledgeErrorCode = {}));
var _NeuledgeError = class extends Error {
  code;
  static fromError(originalError, code, message, hideOriginalError) {
    if (originalError instanceof _NeuledgeError) {
      return originalError;
    }
    const orgMsg = String(originalError?.message ?? originalError);
    const error = new _NeuledgeError(originalError instanceof StoreError ? fromStoreErrorCode(originalError.code, code) : code ?? _NeuledgeError.Code.INTERNAL_ERROR, hideOriginalError ? message ?? "An unknown error occurred" : message == null ? orgMsg : `${message}: ${orgMsg}`);
    error.stack = originalError?.stack;
    error.originalError = originalError;
    return error;
  }
  constructor(code, message) {
    super(message);
    this.code = code;
    this.name = "NeuledgeError";
  }
  originalError;
};
var NeuledgeError = _NeuledgeError;
__name(NeuledgeError, "NeuledgeError");
__publicField(NeuledgeError, "Code", NeuledgeErrorCode);
__publicField(NeuledgeError, "wrap", (code, message, hideOriginalError) => (originalError) => {
  throw _NeuledgeError.fromError(originalError, code, message, hideOriginalError);
});
var fromStoreErrorCode = /* @__PURE__ */ __name((code, defaultCode) => {
  switch (code) {
    case StoreError.Code.INVALID_DATA: {
      return NeuledgeError.Code.CORRUPTED_METADATA;
    }
    case StoreError.Code.NOT_IMPLEMENTED: {
      return NeuledgeError.Code.NOT_IMPLEMENTED;
    }
    default: {
      return defaultCode ?? NeuledgeError.Code.INTERNAL_ERROR;
    }
  }
}, "fromStoreErrorCode");

// src/glob.ts
init_esm_shims();
var globKey = "__NeuledgeGlob__";
var glob = typeof globalThis === "undefined" ? typeof self === "undefined" ? typeof window === "undefined" ? typeof global === "undefined" ? {} : global : window : self : globalThis;
var neuledgeGlob = glob[globKey] = glob[globKey] ?? {
  stateDefinitions: /* @__PURE__ */ new Map()
};

// src/definitions/state/decorator.ts
var { stateDefinitions } = neuledgeGlob;
var State = /* @__PURE__ */ __name(() => (state) => {
  if (stateDefinitions.has(state.$name) && stateDefinitions.get(state.$name) !== state) {
    throw new NeuledgeError(NeuledgeError.Code.DUPLICATE_STATE_NAME, `State "${state.$name}" is already defined.`);
  }
  stateDefinitions.set(state.$name, state);
}, "State");

// src/definitions/state/indexes.ts
init_esm_shims();

// src/definitions/state/relations.ts
init_esm_shims();

// src/definitions/state/scalar.ts
init_esm_shims();
var isStateDefinitionScalarTypeScalar = /* @__PURE__ */ __name((type) => !Array.isArray(type), "isStateDefinitionScalarTypeScalar");
var isStateDefinitionScalarTypeStates = /* @__PURE__ */ __name((type) => Array.isArray(type), "isStateDefinitionScalarTypeStates");

// src/definitions/state/sort.ts
init_esm_shims();
var parseSortedField = /* @__PURE__ */ __name((field) => [
  field.slice(1),
  field[0] === "+" ? "asc" : "desc"
], "parseSortedField");
var fromSortedField = /* @__PURE__ */ __name((field) => field.slice(1), "fromSortedField");

// src/definitions/state/state.ts
init_esm_shims();

// src/definitions/state/find/index.ts
init_esm_shims();

// src/definitions/state/find/state-definition.ts
init_esm_shims();

// src/definitions/state/find/term.ts
init_esm_shims();

// src/definitions/defer.ts
init_esm_shims();
var resolveDefer = /* @__PURE__ */ __name((defer, def) => {
  if (typeof defer === "function") {
    return defer();
  }
  return defer ?? def;
}, "resolveDefer");

// src/queries/index.ts
init_esm_shims();

// src/queries/alter/index.ts
init_esm_shims();

// src/queries/alter/first.ts
init_esm_shims();

// src/queries/alter/first-or-throw.ts
init_esm_shims();

// src/queries/alter/many.ts
init_esm_shims();

// src/queries/alter/unique.ts
init_esm_shims();

// src/queries/alter/unique-or-throw.ts
init_esm_shims();

// src/queries/init/index.ts
init_esm_shims();

// src/queries/init/many.ts
init_esm_shims();

// src/queries/init/one.ts
init_esm_shims();

// src/queries/find/index.ts
init_esm_shims();

// src/queries/find/first.ts
init_esm_shims();

// src/queries/find/first-or-throw.ts
init_esm_shims();

// src/queries/find/many.ts
init_esm_shims();

// src/queries/find/unique.ts
init_esm_shims();

// src/queries/find/unique-or-throw.ts
init_esm_shims();

// src/queries/raw/index.ts
init_esm_shims();

// src/queries/raw/exec.ts
init_esm_shims();

// src/queries/raw/limit.ts
init_esm_shims();

// src/queries/raw/filter.ts
init_esm_shims();

// src/queries/raw/match/index.ts
init_esm_shims();

// src/queries/raw/match/refine.ts
init_esm_shims();

// src/queries/raw/match/match.ts
init_esm_shims();

// src/queries/raw/method.ts
init_esm_shims();

// src/queries/raw/offset.ts
init_esm_shims();

// src/queries/raw/populate/index.ts
init_esm_shims();

// src/queries/raw/populate/expand.ts
init_esm_shims();

// src/queries/raw/populate/populate.ts
init_esm_shims();

// src/queries/raw/populate/select-many.ts
init_esm_shims();

// src/queries/raw/populate/select-one.ts
init_esm_shims();

// src/queries/raw/return.ts
init_esm_shims();

// src/queries/raw/select.ts
init_esm_shims();

// src/queries/raw/sort.ts
init_esm_shims();

// src/queries/raw/type.ts
init_esm_shims();

// src/queries/raw/unique.ts
init_esm_shims();

// src/queries/raw/where.ts
init_esm_shims();

// src/queries/query.ts
init_esm_shims();

// src/queries/class.ts
init_esm_shims();
var QueryClass = class {
  options;
  constructor(options) {
    this.options = options;
    if ("unique" in options && options.unique === true) {
      this.then = null;
    }
  }
  return(returns) {
    this.options.returns = returns ?? "new";
    this.options.select = true;
    return this;
  }
  select(select) {
    this.options.select = select ?? true;
    return this;
  }
  expand(key, states, query) {
    if (states !== void 0 && !Array.isArray(states)) {
      query = states;
      states = void 0;
    }
    let rel = new QueryClass({
      type: "SelectOne",
      states
    });
    if (query) {
      rel = query(rel);
    } else {
      rel.select();
    }
    const options = this.options;
    if (!options.expand) {
      options.expand = {};
    }
    options.expand[key] = rel.options;
    return this;
  }
  populateOne(key, states, query) {
    if (states !== void 0 && !Array.isArray(states)) {
      query = states;
      states = void 0;
    }
    let rel = new QueryClass({
      type: "SelectOne",
      select: true,
      states
    });
    if (query) {
      rel = query(rel);
    }
    const options = this.options;
    if (!options.populateOne) {
      options.populateOne = {};
    }
    options.populateOne[key] = rel.options;
    return this;
  }
  //   populateMany<K extends StateManyRelations<O>>(
  //     key: K,
  //     states?:
  //       | StateRelationStates<O, K>[]
  //       | PopulateManyQueryParam<StateRelationStates<O, K>>,
  //     query?: PopulateManyQueryParam<StateRelationStates<O, K>>,
  //   ): this {
  //     if (states !== undefined && !Array.isArray(states)) {
  //       query = states;
  //       states = undefined;
  //     }
  //
  //     let rel = new QueryClass<
  //       'SelectMany',
  //       StateRelationStates<O, K>,
  //       StateRelationStates<O, K>
  //     >({
  //       type: 'SelectMany',
  //       select: true,
  //       states,
  //     });
  //
  //     if (query) {
  //       rel = query(rel) as typeof rel;
  //     }
  //
  //     const options = this.options as PopulateQueryOptions<O>;
  //
  //     if (!options.populateMany) {
  //       options.populateMany = {};
  //     }
  //     options.populateMany[key] = rel.options;
  //
  //     return this;
  //   }
  where(where) {
    this.options.where = where;
    return this;
  }
  unique(where) {
    this.options.unique = where;
    delete this.then;
    return this;
  }
  filter(filter) {
    this.options.filter = filter;
    return this;
  }
  match(key, states, query) {
    if (states !== void 0 && !Array.isArray(states)) {
      query = states;
      states = void 0;
    }
    let rel = new QueryClass({
      type: "Refine",
      states
    });
    if (query) {
      rel = query(rel);
    }
    const options = this.options;
    if (!options.match) {
      options.match = {};
    }
    options.match[key] = rel.options;
    return this;
  }
  sort(sort, ...fields) {
    this.options.sort = sort === "*" ? fields : sort;
    return this;
  }
  limit(limit) {
    this.options.limit = limit;
    return this;
  }
  offset(offset) {
    this.options.offset = offset;
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async exec() {
    if (!("exec" in this.options)) {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_EXECUTION_ERROR, `This query is not executable`);
    }
    if ("unique" in this.options && this.options.unique === true) {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_EXECUTION_ERROR, `Can't resolve a unique query without the '.unique()' clause`);
    }
    return this.options.exec(this.options);
  }
  // eslint-disable-next-line unicorn/no-thenable, @typescript-eslint/no-explicit-any
  then(onfulfilled, onrejected) {
    return this.exec().catch(NeuledgeError.wrap()).then(onfulfilled, onrejected);
  }
};
__name(QueryClass, "QueryClass");

// src/engine/index.ts
init_esm_shims();

// src/engine/engine.ts
init_esm_shims();

// src/engine/metadata/index.ts
init_esm_shims();

// src/engine/metadata/load.ts
init_esm_shims();

// src/metadata/index.ts
init_esm_shims();

// src/metadata/change.ts
init_esm_shims();

// src/metadata/collection.ts
init_esm_shims();

// src/metadata/schema.ts
init_esm_shims();
var getMetadataSchema = /* @__PURE__ */ __name((states, relationParent) => {
  const schemaMap = {};
  for (const state of states) {
    for (const field of (relationParent?.state ?? state).fields) {
      let { path } = field;
      if (relationParent) {
        if (!path.startsWith(`${relationParent.path}.`))
          continue;
        path = path.slice(relationParent.path.length + 1);
      }
      let pathChoices = schemaMap[path];
      if (!pathChoices) {
        pathChoices = schemaMap[path] = {};
      }
      const key = getFieldKey(field);
      if (pathChoices[key])
        continue;
      pathChoices[key] = {
        field
      };
    }
    for (const relation of state.relations) {
      let { path } = relation;
      if (relationParent) {
        if (!path.startsWith(`${relationParent.path}.`))
          continue;
        path = path.slice(relationParent.path.length + 1);
      }
      let pathChoices = schemaMap[path];
      if (!pathChoices) {
        pathChoices = schemaMap[path] = {};
      }
      const key = getSchemaKey(relation.states);
      if (pathChoices[key])
        continue;
      const childSchema = getMetadataSchema(relation.states, {
        state,
        path
      });
      pathChoices[key] = {
        schema: childSchema
      };
    }
  }
  return Object.fromEntries(Object.entries(schemaMap).map(([path, choices]) => [
    path,
    Object.values(choices)
  ]));
}, "getMetadataSchema");
var getFieldKey = /* @__PURE__ */ __name((field) => `${field.name}:${field.type.name}${field.nullable ? "?" : ""}`, "getFieldKey");
var getSchemaKey = /* @__PURE__ */ __name((states) => JSON.stringify(states.map((state) => `${state.name}#${state.hash.toString("base64url")}`).sort()), "getSchemaKey");

// src/metadata/collection.ts
var MetadataCollection = class {
  name;
  states;
  reservedNames;
  schema;
  primaryKey;
  indexes;
  fields;
  constructor(name, states) {
    this.name = name;
    this.states = states;
    this.fields = getStoreCollectionFields(states);
    this.schema = getMetadataSchema(this.states);
    const { indexes, primaryKey } = getStoreIndexes(this.schema, states);
    this.indexes = indexes;
    this.primaryKey = primaryKey;
    this.reservedNames = this.states[0].reservedNames;
  }
  /**
  * Traverse the collection schema and all fields under the given path.
  */
  getSchemaFields(rootPath) {
    let choices = this.schema[rootPath];
    if (!choices)
      return [];
    choices = [
      ...choices
    ].reverse();
    const res = [];
    while (choices.length) {
      const choice = choices.pop();
      if (choice.field) {
        res.push(choice.field);
        continue;
      }
      for (const schemaChoices of Object.values(choice.schema)) {
        if (!schemaChoices)
          continue;
        choices.push(...[
          ...schemaChoices
        ].reverse());
      }
    }
    return res;
  }
  /**
  * Traverse the collection schema and all field names under the given path.
  */
  getSchemaFieldNames(rootPath) {
    return this.getSchemaFields(rootPath).map((field) => field.name);
  }
};
__name(MetadataCollection, "MetadataCollection");
var getStoreCollectionFields = /* @__PURE__ */ __name((states) => {
  const fields = {};
  const refCount = /* @__PURE__ */ new Map();
  for (const state of states) {
    for (const field of state.fields) {
      const storeField = fields[field.name];
      if (!storeField) {
        fields[field.name] = getStoreField(field);
      } else if (field.nullable && !storeField.nullable) {
        storeField.nullable = true;
      }
      const count = refCount.get(field.name) ?? 0;
      refCount.set(field.name, count + 1);
    }
  }
  for (const [name, count] of refCount) {
    if (count === states.length)
      continue;
    const field = fields[name];
    field.nullable = true;
  }
  return fields;
}, "getStoreCollectionFields");
var getStoreField = /* @__PURE__ */ __name((field) => ({
  name: field.name,
  ...field.type.shape,
  nullable: field.nullable
}), "getStoreField");
var getStoreIndexes = /* @__PURE__ */ __name((schema, states) => {
  const indexes = {};
  const primaryKey = {
    name: "",
    fields: getStoreIndexFields(schema, states[0].instance.$id.fields),
    unique: "primary",
    auto: states[0].instance.$id.auto
  };
  for (const state of states) {
    for (const [name, index] of Object.entries(state.instance.$indexes ?? {})) {
      indexes[name] = {
        name,
        fields: getStoreIndexFields(schema, index.fields),
        unique: index.unique
      };
    }
  }
  applyPrimaryKey(indexes, primaryKey);
  return {
    indexes,
    primaryKey
  };
}, "getStoreIndexes");
var getStoreIndexFields = /* @__PURE__ */ __name((schema, sortDefinition) => {
  const fields = {};
  for (const sortField of sortDefinition) {
    const [name, sort] = parseSortedField(sortField);
    const indexField = {
      sort
    };
    const choices = schema[name];
    if (!choices) {
      throw new NeuledgeError(NeuledgeError.Code.UNKNOWN_SORT_FIELD, `Unknown sort field: '${name}'`);
    }
    assignStoreIndexField(fields, choices, indexField);
  }
  return fields;
}, "getStoreIndexFields");
var assignStoreIndexField = /* @__PURE__ */ __name((fields, choices, indexField) => {
  for (const choice of choices) {
    if (!choice)
      continue;
    if (choice.field) {
      fields[choice.field.name] = indexField;
      continue;
    }
    assignStoreIndexField(fields, Object.values(choice.schema).flatMap((item) => item ?? []), indexField);
  }
}, "assignStoreIndexField");
var applyPrimaryKey = /* @__PURE__ */ __name((indexes, primaryKey) => {
  const primaryKeyName = Object.keys(primaryKey.fields).join("_");
  primaryKey.name = primaryKeyName;
  for (let i = 2; indexes[primaryKey.name]; i++) {
    primaryKey.name = `${primaryKeyName}_${i}`;
  }
  indexes[primaryKey.name] = primaryKey;
}, "applyPrimaryKey");

// src/metadata/constants.ts
init_esm_shims();
var METADATA_HASH_BYTES = 8;

// src/metadata/metadata.ts
init_esm_shims();

// src/metadata/names/index.ts
init_esm_shims();

// src/metadata/names/collections.ts
init_esm_shims();
import pluralize from "pluralize";
var groupStatesByCollectionName = /* @__PURE__ */ __name((states) => {
  const groups = getStateGroups(states);
  const suggestions = [];
  for (const group of groups.values()) {
    suggestions.push(...suggestStatesCollectionNames(group));
  }
  suggestions.sort((a, b) => a.name.localeCompare(b.name) || b.rank - a.rank);
  const selectedName = /* @__PURE__ */ new Map();
  for (const [index, suggestion] of suggestions.entries()) {
    if (suggestions[index - 1]?.name === suggestion.name)
      continue;
    const best = selectedName.get(suggestion.states);
    if (best == null || best.rank < suggestion.rank) {
      selectedName.set(suggestion.states, suggestion);
    }
  }
  return new Map([
    ...selectedName.entries()
  ].map(([states2, suggestion]) => [
    suggestion.name,
    states2
  ]));
}, "groupStatesByCollectionName");
var getStateGroups = /* @__PURE__ */ __name((states) => {
  const groups = /* @__PURE__ */ new Map();
  for (const state of states) {
    let set = groups.get(state.$name);
    if (!set) {
      set = /* @__PURE__ */ new Set([
        state
      ]);
      groups.set(state.$name, set);
    }
    const relatedStates = resolveDefer(state.$transforms, []);
    for (const relatedState of relatedStates) {
      set.add(relatedState);
      for (const item of groups.get(relatedState.$name) ?? []) {
        set.add(item);
      }
    }
    for (const state2 of set) {
      groups.set(state2.$name, set);
    }
  }
  return new Set(groups.values());
}, "getStateGroups");
var suggestStatesCollectionNames = /* @__PURE__ */ __name((stateGroup) => {
  const suggestions = [];
  const sharedPhrase = [];
  let first = true;
  for (const state of stateGroup) {
    const words = state.$name.split(/(?=[A-Z])|_|(?<=[a-z])(?=\d)/).map((word) => word.toLowerCase());
    suggestions.push({
      states: stateGroup,
      name: formatCollectionName(words),
      rank: 0
    });
    if (first) {
      sharedPhrase.push(...words);
      first = false;
      continue;
    }
    const wordsSet = new Set(words);
    for (let i = 0; i < sharedPhrase.length; i++) {
      if (!wordsSet.has(sharedPhrase[i])) {
        sharedPhrase.splice(i, 1);
        i--;
      }
    }
  }
  suggestions.push({
    states: stateGroup,
    name: formatCollectionName(sharedPhrase),
    rank: 1e3
  });
  for (let i = sharedPhrase.length - 1; i > 0; i--) {
    suggestions.push({
      states: stateGroup,
      name: formatCollectionName(sharedPhrase.slice(i)),
      rank: (500 * sharedPhrase.length - i) / sharedPhrase.length
    }, {
      states: stateGroup,
      name: formatCollectionName(sharedPhrase.slice(0, i)),
      rank: 100 * i / sharedPhrase.length
    });
  }
  return suggestions;
}, "suggestStatesCollectionNames");
var formatCollectionName = /* @__PURE__ */ __name((words) => [
  ...words.slice(0, -1),
  pluralize.plural(words[words.length - 1])
].join("_"), "formatCollectionName");

// src/metadata/names/fields.ts
init_esm_shims();
var renameDuplicateFieldNames = /* @__PURE__ */ __name((states) => {
  const fieldMap = generateFieldMap(states);
  for (const [name, typeMap] of fieldMap) {
    if (typeMap.size === 1)
      continue;
    const hasTypeInName = typeMap.has(toSnakeCase(name.split("_").pop()));
    let index = 0;
    for (const [type, list] of typeMap) {
      let newName = `${name}_${type}`;
      if (hasTypeInName || fieldMap.has(newName)) {
        if (index === 0) {
          index = 1;
          continue;
        }
        do {
          newName = `${name}_${++index}`;
        } while (fieldMap.has(newName));
      }
      fieldMap.set(newName, /* @__PURE__ */ new Map([
        [
          type,
          list
        ]
      ]));
      typeMap.delete(type);
      for (const field of list) {
        field.name = newName;
      }
    }
  }
}, "renameDuplicateFieldNames");
var generateFieldMap = /* @__PURE__ */ __name((states) => {
  const fieldMap = /* @__PURE__ */ new Map();
  for (const { fields } of states) {
    for (const field of fields) {
      let typeMap = fieldMap.get(field.name);
      if (!typeMap) {
        typeMap = /* @__PURE__ */ new Map();
        fieldMap.set(field.name, typeMap);
      }
      const type = toSnakeCase(field.type.name);
      let list = typeMap.get(type);
      if (!list) {
        list = [];
        typeMap.set(type, list);
      }
      list.push(field);
    }
  }
  return fieldMap;
}, "generateFieldMap");
var toSnakeCase = /* @__PURE__ */ __name((str) => str.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase(), "toSnakeCase");

// src/metadata/state/index.ts
init_esm_shims();

// src/metadata/state/snapshot.ts
init_esm_shims();

// src/metadata/hash.ts
init_esm_shims();
import { createHash } from "node:crypto";
var HASH_ALGORITHM = "sha512";
var generateHash = /* @__PURE__ */ __name((payload) => createHash(HASH_ALGORITHM).update(JSON.stringify(payload)).digest().slice(0, METADATA_HASH_BYTES), "generateHash");

// src/metadata/state/field.ts
init_esm_shims();
var getMetadataStateFieldKey = /* @__PURE__ */ __name((field, strict) => `${field.indexes.join(":")}#${field.type}${strict && field.nullable ? "?" : ""}`, "getMetadataStateFieldKey");
var getScalarFields = /* @__PURE__ */ __name((name, path, scalarDef, parentIndexes = [], nullable) => {
  const { type, index } = scalarDef;
  if (!nullable && scalarDef.nullable) {
    nullable = true;
  }
  const indexes = [
    ...parentIndexes,
    index
  ];
  if (isStateDefinitionScalarTypeScalar(type)) {
    return [
      {
        name: toSnakeCase(name),
        path,
        indexes,
        type,
        nullable: nullable ?? false
      }
    ];
  }
  return getStateDefinitionFields(name, path, indexes, type, nullable);
}, "getScalarFields");
var getStateDefinitionFields = /* @__PURE__ */ __name((name, path, indexes, type, nullable) => {
  const fieldMap = /* @__PURE__ */ new Map();
  const refCount = /* @__PURE__ */ new Map();
  for (const childState of type) {
    const scalars = resolveDefer(childState.$scalars);
    for (const sortKey of childState.$id.fields) {
      const id = fromSortedField(sortKey);
      const childScalarDef = scalars[id];
      const scalarFields = getScalarFields(`${name}_${id}`, `${path}.${id}`, childScalarDef, indexes, nullable);
      for (const item of scalarFields) {
        const mapKey = getMetadataStateFieldKey(item);
        const value = fieldMap.get(mapKey);
        if (!value || !value.nullable && item.nullable) {
          fieldMap.set(mapKey, item);
        }
        refCount.set(mapKey, (refCount.get(mapKey) ?? 0) + 1);
      }
    }
  }
  for (const [key, field] of fieldMap) {
    if (field.nullable || refCount.get(key) === type.length) {
      continue;
    }
    field.nullable = true;
  }
  return [
    ...fieldMap.values()
  ];
}, "getStateDefinitionFields");

// src/metadata/state/snapshot.ts
var StateSnapshot = class {
  collectionName;
  name;
  hash;
  fields;
  instance;
  relations;
  /**
  * Check that the origin state matches the current state signature.
  * The state can match if one of the following conditions is true:
  * - the hash is the same
  * - the current state has all the required fields of the origin state
  */
  matches(origin) {
    if (this.hash.equals(origin.hash))
      return true;
    const existingFields = new Map(this.fields.map((item) => [
      getMetadataStateFieldKey(item),
      item
    ]));
    return Object.values(origin.fields).every((originField) => {
      const existsField = existingFields.get(getMetadataStateFieldKey(originField));
      if (!existsField) {
        return originField.nullable;
      }
      return !existsField.nullable || originField.nullable;
    });
  }
  /**
  * Sync the current state with the origin state.
  * This will update the collection name and store field names to match the
  * origin state representation on the store. This is useful when the state
  * rename a field and we want to keep the same name on the store for backward
  * compatibility.
  */
  sync(origin) {
    this.collectionName = origin.collectionName;
    const targetFields = new Map(this.fields.map((field) => [
      getMetadataStateFieldKey(field),
      field
    ]));
    const targetFieldNames = new Map(this.fields.map((field) => [
      field.name,
      field
    ]));
    for (const key in origin.fields) {
      const field = origin.fields[key];
      const targetField = targetFields.get(getMetadataStateFieldKey(field));
      if (!targetField || targetField.name === field.name)
        continue;
      const oldFieldName = targetField.name;
      const overrideField = targetFieldNames.get(field.name);
      targetField.name = field.name;
      targetFieldNames.set(targetField.name, targetField);
      if (overrideField) {
        overrideField.name = oldFieldName;
        targetFieldNames.set(overrideField.name, overrideField);
      }
    }
  }
  clone() {
    return Object.assign(Object.create(this), this);
  }
  assign(origin) {
    this.collectionName = origin.collectionName;
    this.name = origin.name;
    this.hash = origin.hash;
    this.fields = origin.fields;
    this.relations = origin.relations;
    return this;
  }
};
__name(StateSnapshot, "StateSnapshot");
var generateStateHash = /* @__PURE__ */ __name((state) => generateHash([
  state.fields.map((field) => getMetadataStateFieldKey(field, true)).sort(),
  state.relations.map((relation) => getMetadataStateRelationKey(relation)).sort()
]), "generateStateHash");
var getMetadataStateRelationKey = /* @__PURE__ */ __name((relation) => `${relation.index}#${relation.states.map((state) => generateStateHash({
  fields: state.fields,
  relations: []
}).toString("base64url")).join("|")}`, "getMetadataStateRelationKey");

// src/metadata/state/state.ts
init_esm_shims();
var METADATA_HASH_DEFAULT_FIELD = "__h";
var METADATA_VERSION_DEFAULT_FIELD = "__v";
var _MetadataState = class extends StateSnapshot {
  fields;
  instance;
  reservedNames;
  relations;
  transforms;
  constructor(ctx, state) {
    super();
    ctx[state.$name] = this;
    this.collectionName = state.$name;
    this.name = state.$name;
    this.hash = null;
    this.fields = [];
    this.instance = state;
    this.reservedNames = {
      hash: METADATA_HASH_DEFAULT_FIELD,
      version: METADATA_VERSION_DEFAULT_FIELD
    };
    this.relations = [];
    this.transforms = [];
    const scalars = Object.entries(resolveDefer(state.$scalars));
    const transforms = resolveDefer(state.$transforms, []);
    for (const [key, def] of scalars) {
      const fields = getScalarFields(key, key, def);
      for (const field of fields) {
        if (field.name === this.reservedNames.hash || field.name === this.reservedNames.version) {
          throw new NeuledgeError(NeuledgeError.Code.RESERVED_FIELD_NAME, `State "${this.name}" has a scalar field named "${field.name}" which is reserved for internal use.`);
        }
      }
      this.fields.push(...fields);
    }
    for (const [key, def] of scalars) {
      this.relations.push(...getScalarRelations(ctx, key, def));
    }
    for (const def of transforms) {
      this.transforms.push(_MetadataState.fromDefinition(ctx, def));
    }
    this.hash = generateStateHash(this);
  }
};
var MetadataState = _MetadataState;
__name(MetadataState, "MetadataState");
__publicField(MetadataState, "fromDefinition", (ctx, state, collectionName) => {
  let ref = ctx[state.$name];
  if (!ref) {
    ref = new _MetadataState(ctx, state);
  }
  if (collectionName) {
    ref.collectionName = collectionName;
  }
  return ref;
});
var getScalarRelations = /* @__PURE__ */ __name((ctx, key, def) => Array.isArray(def.type) ? [
  {
    name: key,
    states: def.type.map((state) => MetadataState.fromDefinition(ctx, state)),
    path: key,
    index: def.index
  }
] : [], "getScalarRelations");

// src/metadata/snapshot.ts
init_esm_shims();
var HASH_KEY_ENCODING = "base64url";
var MetadataSnapshot = class {
  typeMap;
  hashMap;
  keyMap;
  constructor(states) {
    this.typeMap = {};
    this.hashMap = {};
    this.keyMap = {};
    for (const entity of states) {
      this.hashMap[entity.hash.toString(HASH_KEY_ENCODING)] = entity;
      for (const { type } of entity.fields) {
        if (this.typeMap[type.name] == null) {
          this.typeMap[type.name] = type;
        }
      }
      this.keyMap[entity.name] = entity;
    }
  }
  get states() {
    return Object.values(this.keyMap);
  }
  findType(key) {
    return this.typeMap[key];
  }
  findStateByHash(hash) {
    return this.hashMap[hash.toString(HASH_KEY_ENCODING)];
  }
  findStateByKey(key) {
    return this.keyMap[key];
  }
  sync(snapshot) {
    const changes = [];
    for (const hashKey in snapshot.hashMap) {
      const origin = snapshot.hashMap[hashKey];
      if (!origin)
        continue;
      let entity = this.hashMap[hashKey];
      if (entity != null) {
        entity.sync(origin);
        continue;
      }
      entity = this.keyMap[origin.name];
      const deleted = origin.clone();
      if (entity != null) {
        if (entity.matches(origin)) {
          entity.sync(origin);
          this.hashMap[hashKey] = entity;
          changes.push({
            type: "updated",
            entity,
            origin
          });
        }
        deleted.name = `${entity.name}_old`;
        for (let i = 2; this.keyMap[deleted.name] != null; i += 1) {
          deleted.name = `${entity.name}_old${i}`;
        }
      }
      this.hashMap[hashKey] = deleted;
    }
    for (const hashKey in this.hashMap) {
      const entity = this.hashMap[hashKey];
      if (!entity)
        continue;
      const origin = snapshot.hashMap[hashKey];
      if (origin)
        continue;
      changes.push({
        type: "created",
        entity
      });
    }
    return changes;
  }
};
__name(MetadataSnapshot, "MetadataSnapshot");

// src/metadata/metadata.ts
var Metadata = class extends MetadataSnapshot {
  collections;
  constructor(states) {
    const stateGroups = groupStatesByCollectionName(states);
    const ctx = {};
    const collections = {};
    const allStates = [];
    for (const [name, states2] of stateGroups) {
      const metadataStates = [
        ...states2
      ].map((state) => MetadataState.fromDefinition(ctx, state, name));
      renameDuplicateFieldNames(metadataStates);
      collections[name] = new MetadataCollection(name, metadataStates);
      allStates.push(...metadataStates);
    }
    super(allStates);
    this.collections = collections;
  }
  get listCollections() {
    return Object.values(this.collections);
  }
  getCollectionByMetadataState(state) {
    const collection = this.collections[state.collectionName];
    if (!collection) {
      throw new NeuledgeError(NeuledgeError.Code.METADATA_LOAD_ERROR, `Collection "${state.collectionName}" not found in the engine metadata. Make sure you initialize the engine AFTER declaring the states.`);
    }
    return collection;
  }
  getCollections(states) {
    const collectionNames = /* @__PURE__ */ new Set();
    for (const def of states) {
      const state = this.findStateByKey(def.$name);
      if (!state) {
        throw new NeuledgeError(NeuledgeError.Code.METADATA_LOAD_ERROR, `State "${def.$name}" not found in the engine metadata. Make sure you initialize the engine AFTER declaring the states.`);
      }
      collectionNames.add(state.collectionName);
    }
    return [
      ...collectionNames
    ].map((name) => {
      const collection = this.collections[name];
      if (!collection) {
        throw new NeuledgeError(NeuledgeError.Code.METADATA_LOAD_ERROR, `Collection "${name}" not found in the engine metadata. Make sure you initialize the engine AFTER declaring the states.`);
      }
      return collection;
    });
  }
  sync(snapshot) {
    const changes = super.sync(snapshot);
    const collectionStates = {};
    for (const state of this.states) {
      let entry = collectionStates[state.collectionName];
      if (!entry) {
        entry = collectionStates[state.collectionName] = [];
      }
      entry.push(state);
    }
    const collections = {};
    for (const [name, states] of Object.entries(collectionStates)) {
      collections[name] = new MetadataCollection(name, states);
    }
    this.collections = collections;
    return changes;
  }
};
__name(Metadata, "Metadata");

// src/engine/metadata/collections.ts
init_esm_shims();
import pLimit from "p-limit";
var ensureStoreCollections = /* @__PURE__ */ __name(async (store, metadata) => {
  const asyncLimit = pLimit(1);
  await Promise.all(metadata.listCollections.map((collection) => asyncLimit(() => ensureStoreCollection(store, collection))));
}, "ensureStoreCollections");
var ensureStoreCollection = /* @__PURE__ */ __name(async (store, collection) => {
  await store.ensureCollection({
    collection,
    indexes: Object.values(collection.indexes),
    fields: Object.values(collection.fields)
  });
}, "ensureStoreCollection");

// src/engine/metadata/store.ts
init_esm_shims();
import pLimit2 from "p-limit";

// src/engine/metadata/state.ts
init_esm_shims();
var StoreMetadataStateVersion;
(function(StoreMetadataStateVersion2) {
  StoreMetadataStateVersion2[StoreMetadataStateVersion2["V0"] = 0] = "V0";
})(StoreMetadataStateVersion || (StoreMetadataStateVersion = {}));
var fromStoreMetadataState = /* @__PURE__ */ __name((getState, getType, doc) => {
  if (doc.v !== StoreMetadataStateVersion.V0) {
    throw new NeuledgeError(NeuledgeError.Code.UNSUPPORTED_METADATA, `Unsupported metadata version: ${doc.v}`);
  }
  return getState(doc.hash).assign({
    collectionName: doc.collectionName,
    name: doc.name,
    hash: doc.hash,
    fields: doc.fields.map((field) => fromStoreMetadataStateField(getType, field)),
    relations: doc.relations.map((relation) => fromStoreMetadataStateRelation(getState, relation))
  });
}, "fromStoreMetadataState");
var toStoreMetadataState = /* @__PURE__ */ __name((state) => ({
  collectionName: state.collectionName,
  name: state.name,
  hash: state.hash,
  fields: state.fields.map((field) => toStoreMetadataStateField(field)),
  relations: state.relations.map((relation) => toStoreMetadataStateRelation(relation)),
  v: StoreMetadataStateVersion.V0
}), "toStoreMetadataState");
var fromStoreMetadataStateField = /* @__PURE__ */ __name((getType, doc) => ({
  name: doc.name,
  type: getType(doc.type),
  indexes: doc.indexes,
  nullable: doc.nullable
}), "fromStoreMetadataStateField");
var toStoreMetadataStateField = /* @__PURE__ */ __name((field) => ({
  name: field.name,
  type: field.type.name,
  indexes: [
    ...field.indexes
  ],
  nullable: field.nullable
}), "toStoreMetadataStateField");
var fromStoreMetadataStateRelation = /* @__PURE__ */ __name((getState, relation) => ({
  name: relation.name,
  states: relation.stateHashes.map((hash) => getState(hash)),
  index: relation.index
}), "fromStoreMetadataStateRelation");
var toStoreMetadataStateRelation = /* @__PURE__ */ __name((relation) => ({
  name: relation.name,
  stateHashes: relation.states.map((state) => state.hash),
  index: relation.index
}), "toStoreMetadataStateRelation");

// src/engine/metadata/store.ts
var HASH_ENCODING = "base64url";
var COLLECTION_FIND_LIMIT = 1e3;
var getMetadataCollection = /* @__PURE__ */ __name((metadataCollectionName) => {
  const hash = {
    name: "hash",
    type: "binary",
    size: METADATA_HASH_BYTES
  };
  const primaryKey = {
    name: "hash",
    fields: {
      [hash.name]: {
        sort: "asc"
      }
    },
    unique: "primary"
  };
  return {
    name: metadataCollectionName,
    primaryKey,
    indexes: {
      [primaryKey.name]: primaryKey
    },
    fields: {
      [hash.name]: hash,
      key: {
        name: "key",
        type: "string"
      },
      payload: {
        name: "payload",
        type: "json"
      }
    }
  };
}, "getMetadataCollection");
var ensureMetadataCollection = /* @__PURE__ */ __name(async (store, metadataCollection) => {
  await store.ensureCollection({
    collection: metadataCollection,
    indexes: Object.values(metadataCollection.indexes),
    fields: Object.values(metadataCollection.fields)
  });
}, "ensureMetadataCollection");
var getStoreMetadataSnapshot = /* @__PURE__ */ __name(async (snapshot, store, metadataCollection) => {
  const entities = {};
  const getState = /* @__PURE__ */ __name((hash) => {
    const key = hash.toString(HASH_ENCODING);
    let res2 = entities[key];
    if (!res2) {
      res2 = new StateSnapshot();
      entities[key] = res2;
    }
    return res2;
  }, "getState");
  const getType = /* @__PURE__ */ __name((key) => {
    const type = snapshot.findType(key);
    if (!type) {
      throw new NeuledgeError(NeuledgeError.Code.CORRUPTED_METADATA, `Can't find reference for type: ${key}`);
    }
    return type;
  }, "getType");
  let res;
  do {
    res = await store.find({
      collection: metadataCollection,
      limit: COLLECTION_FIND_LIMIT,
      offset: res?.nextOffset
    });
    for (const doc of res) {
      if (!(doc.hash instanceof Buffer)) {
        throw new NeuledgeError(NeuledgeError.Code.CORRUPTED_METADATA, `Invalid state document: ${doc.hash}`);
      }
      const state = doc;
      entities[state.hash.toString(HASH_ENCODING)] = fromStoreMetadataState(getState, getType, state);
    }
  } while (res.length >= COLLECTION_FIND_LIMIT);
  return new MetadataSnapshot(Object.values(entities));
}, "getStoreMetadataSnapshot");
var syncStoreMetadata = /* @__PURE__ */ __name(async (store, metadataCollection, changes) => {
  const { inserts, updates } = getStoreMetadataChanges(changes);
  if (inserts.length > 0) {
    await store.insert({
      collection: metadataCollection,
      documents: inserts
    });
  }
  if (updates.length > 0) {
    const limit = pLimit2(10);
    await Promise.all(updates.map(({ hash, ...set }) => limit(() => store.update({
      collection: metadataCollection,
      where: {
        hash: {
          $eq: hash
        }
      },
      set,
      limit: 1
    }))));
  }
}, "syncStoreMetadata");
var getStoreMetadataChanges = /* @__PURE__ */ __name((changes) => {
  const inserts = [];
  const updates = [];
  for (const change of changes) {
    switch (change.type) {
      case "created": {
        inserts.push(toStoreMetadataState(change.entity));
        break;
      }
      case "updated": {
        updates.push(toStoreMetadataState(change.entity));
        break;
      }
      default: {
        throw new NeuledgeError(
          NeuledgeError.Code.METADATA_SAVE_ERROR,
          // @ts-expect-error change type is `never`
          `Unknown metadata change type: ${change.type}`
        );
      }
    }
  }
  return {
    inserts,
    updates
  };
}, "getStoreMetadataChanges");

// src/engine/metadata/load.ts
var DEFAULT_METADATA_COLLECTION_NAME = "__neuledge_metadata";
var loadMetadata = /* @__PURE__ */ __name(async (store, metadataCollectionName = DEFAULT_METADATA_COLLECTION_NAME) => {
  const metadataCollection = getMetadataCollection(metadataCollectionName);
  await ensureMetadataCollection(store, metadataCollection);
  const metadata = new Metadata(neuledgeGlob.stateDefinitions.values());
  const snapshot = await getStoreMetadataSnapshot(metadata, store, metadataCollection);
  const changes = metadata.sync(snapshot);
  await ensureStoreCollections(store, metadata);
  await syncStoreMetadata(store, metadataCollection, changes);
  return metadata;
}, "loadMetadata");

// src/engine/exec/index.ts
init_esm_shims();

// src/engine/exec/init.ts
init_esm_shims();

// src/engine/collection.ts
init_esm_shims();
var chooseStatesCollection = /* @__PURE__ */ __name((metadata, states) => {
  const collections = metadata.getCollections(states);
  if (collections.length !== 1) {
    if (!collections.length) {
      throw new NeuledgeError(NeuledgeError.Code.NO_COLLECTIONS, `No collections found for ${states.length} states`);
    }
    throw new NeuledgeError(NeuledgeError.Code.MULTIPLE_COLLECTIONS, `Engine operations can only be used with one collection, got request for ${collections.length} collections: ${collections.map((c) => c.name).join(", ")}`);
  }
  const collection = collections[0];
  const stateNames = new Set(states.map((s) => s.$name));
  const collectionStates = collection.states.filter((s) => stateNames.has(s.name));
  return {
    collection,
    states: collectionStates
  };
}, "chooseStatesCollection");

// src/engine/document.ts
init_esm_shims();
var toDocument = /* @__PURE__ */ __name((metadata, collection, entity) => {
  const { $state, $version } = entity;
  const state = metadata.findStateByKey($state);
  if (!state) {
    throw new NeuledgeError(NeuledgeError.Code.ENTITY_STATE_NOT_FOUND, `State metadata not found: ${$state}`);
  }
  const document = {
    [collection.reservedNames.hash]: state.hash,
    [collection.reservedNames.version]: $version
  };
  for (const field of state.fields) {
    document[field.name] = getEntityValue(entity, field.path);
  }
  return document;
}, "toDocument");
var getEntityValue = /* @__PURE__ */ __name((obj, path) => {
  const pathKeys = path.split(".");
  let value = obj;
  for (const key of pathKeys) {
    if (typeof value !== "object" || value === null) {
      return void 0;
    }
    value = value[key];
  }
  return value;
}, "getEntityValue");

// src/engine/entity.ts
init_esm_shims();
var toEntityList = /* @__PURE__ */ __name((metadata, collection, list) => Object.assign(list.map((document) => {
  const stateHash = document[collection.reservedNames.hash];
  return Buffer.isBuffer(stateHash) ? getStateEntity(metadata, collection, stateHash, document) : void 0;
}).filter((entity) => entity !== void 0), {
  nextOffset: list.nextOffset
}), "toEntityList");
var toEntityListOrThrow = /* @__PURE__ */ __name((metadata, collection, list) => {
  const entities = toEntityList(metadata, collection, list);
  if (!entities.length) {
    throw new NeuledgeError(NeuledgeError.Code.DOCUMENT_NOT_FOUND, "Document not found");
  }
  return entities;
}, "toEntityListOrThrow");
var toMaybeEntity = /* @__PURE__ */ __name((metadata, collection, document) => {
  const stateHash = document?.[collection.reservedNames.hash];
  return Buffer.isBuffer(stateHash) ? getStateEntity(metadata, collection, stateHash, document) : null;
}, "toMaybeEntity");
var toEntityOrThrow = /* @__PURE__ */ __name((metadata, collection, document) => {
  const stateHash = document?.[collection.reservedNames.hash];
  if (!Buffer.isBuffer(stateHash)) {
    throw new NeuledgeError(NeuledgeError.Code.DOCUMENT_NOT_FOUND, "Document not found");
  }
  return getStateEntity(metadata, collection, stateHash, document);
}, "toEntityOrThrow");
var getStateEntity = /* @__PURE__ */ __name((metadata, collection, stateHash, document) => {
  const state = metadata.findStateByHash(stateHash);
  if (!state) {
    throw new NeuledgeError(NeuledgeError.Code.ENTITY_STATE_NOT_FOUND, `Entity state not found: ${stateHash.toString("base64")}`);
  }
  const entity = {
    $state: state.name,
    $version: document[collection.reservedNames.version] ?? 0
  };
  for (const field of state.fields) {
    if (!(field.name in document) || !field.path)
      continue;
    const rawValue = document[field.name];
    const value = field.type.decode ? field.type.decode(rawValue) : rawValue;
    setEntityValue(entity, field.path, value);
  }
  for (const relation of state.relations) {
    if (!relation.path)
      continue;
    const childDocument = document[relation.name];
    if (childDocument == null)
      continue;
    const childStateHash = childDocument[collection.reservedNames.hash];
    if (!Buffer.isBuffer(childStateHash))
      continue;
    const childEntity = getStateEntity(metadata, collection, childStateHash, childDocument);
    setEntityValue(entity, relation.path, childEntity);
  }
  return entity;
}, "getStateEntity");
var setEntityValue = /* @__PURE__ */ __name((obj, path, value) => {
  const pathKeys = path.split(".");
  for (let i = 0; i < pathKeys.length - 1; i += 1) {
    const key = pathKeys[i];
    obj = key in obj ? obj[key] : obj[key] = {};
  }
  obj[pathKeys[pathKeys.length - 1]] = value;
}, "setEntityValue");

// src/engine/relations/index.ts
init_esm_shims();

// src/engine/relations/expand.ts
init_esm_shims();

// src/engine/relations/relation.ts
init_esm_shims();
var convertRelationQueryOptions = /* @__PURE__ */ __name((metadata, collection, relationQueries, convert) => {
  const res = {};
  const statesRelations = collection.states.map((state) => resolveDefer(state.instance.$relations, {}));
  for (const key in relationQueries) {
    const query = relationQueries[key];
    if (query == null)
      continue;
    const referenceCollectionMap = getRelationReferenceCollections(metadata, collection.states, statesRelations.map((stateRelations) => stateRelations[key] ?? {
      states: []
    }), key, query.states);
    const values = [];
    for (const [reference, collectionMap] of referenceCollectionMap) {
      for (const [targerCollection, refCollections] of collectionMap) {
        const fields = targerCollection.getSchemaFields(reference);
        values.push(...refCollections.map((relCollection) => {
          const reverse = relCollection === collection;
          return convert({
            collection: reverse ? targerCollection : relCollection,
            by: getStoreJoinBy(reference, fields, relCollection, reverse),
            query
          });
        }));
      }
    }
    res[key] = values;
  }
  return res;
}, "convertRelationQueryOptions");
var getRelationReferenceCollections = /* @__PURE__ */ __name((metadata, states, stateRelations, key, queryStates) => {
  const res = /* @__PURE__ */ new Map();
  for (const [i, state] of states.entries()) {
    const stateRelation = stateRelations[i];
    if (!stateRelation.states.length)
      continue;
    const path = stateRelation.reference ?? key;
    let entry = res.get(path);
    if (!entry) {
      entry = /* @__PURE__ */ new Map();
      res.set(path, entry);
    }
    let relStates;
    if (queryStates) {
      const queryStatesMap = new Map(queryStates.map((state2) => [
        state2.$name,
        state2
      ]));
      relStates = stateRelation.states.filter((state2) => queryStatesMap.get(state2.$name) === state2);
      if (relStates.length !== queryStates.length) {
        throw new NeuledgeError(NeuledgeError.Code.RELATION_STATE_NOT_FOUND, `Could not find matching states for '${key}': ${queryStates.map((state2) => state2.$name).join(", ")}`);
      }
    } else {
      relStates = stateRelation.states;
    }
    let collections = [
      metadata.getCollectionByMetadataState(state)
    ];
    let relCollections = metadata.getCollections(relStates);
    if (stateRelation.reference) {
      [collections, relCollections] = [
        relCollections,
        collections
      ];
    }
    for (const collection of collections) {
      entry.set(collection, relCollections);
    }
  }
  return res;
}, "getRelationReferenceCollections");
var getStoreJoinBy = /* @__PURE__ */ __name((reference, fields, relCollection, reverse) => {
  const res = {};
  const fieldMap = new Map(fields.map((field) => [
    field.path.slice(reference.length + 1),
    field
  ]));
  for (const state of relCollection.states) {
    for (const refField of state.fields) {
      const field = fieldMap.get(refField.path);
      if (!field)
        continue;
      if (reverse) {
        res[field.name] = {
          field: refField.name
        };
      } else {
        res[refField.name] = {
          field: field.name
        };
      }
      fieldMap.delete(refField.path);
      if (!fieldMap.size) {
        return res;
      }
    }
  }
  throw new NeuledgeError(NeuledgeError.Code.RELATION_FIELD_NOT_FOUND, `Could not find matching fields for '${reference}': ${[
    ...fieldMap.keys()
  ].join(", ")}`);
}, "getStoreJoinBy");

// src/engine/find/index.ts
init_esm_shims();

// src/engine/find/where.ts
init_esm_shims();

// src/engine/find/record.ts
init_esm_shims();

// src/engine/find/term.ts
init_esm_shims();
var import_es6 = __toESM(require_es6());
var applyWhereRecordTerm = /* @__PURE__ */ __name((records, field, term) => {
  const res = records.map((record) => ({
    ...record
  }));
  for (const record of res) {
    if (record[field.name] == null) {
      record[field.name] = convertWhereScalarTerm(field.type, term);
    } else {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Duplicate where key: '${field.path}'`);
    }
  }
  return res;
}, "applyWhereRecordTerm");
var convertWhereScalarTerm = /* @__PURE__ */ __name((scalar, term) => {
  const res = {};
  for (const [operator, value] of Object.entries(term)) {
    assignWhereScalarOperator(res, scalar, operator, value);
  }
  return res;
}, "convertWhereScalarTerm");
var applyWhereOperatorTerm = /* @__PURE__ */ __name((records, key, scalar, operator, value) => {
  const res = [];
  for (const origin of records) {
    const record = {
      ...origin
    };
    const scalarValue = scalar.encode(value);
    if (record[key] == null) {
      record[key] = {
        [operator]: scalarValue
      };
    } else {
      const term = {
        ...record[key]
      };
      record[key] = term;
      if (operator === "$ne") {
        if ("$eq" in term) {
          if ((0, import_es6.default)(term.$eq, scalarValue)) {
            continue;
          }
        } else if (Array.isArray(term.$nin)) {
          term.$nin = [
            ...term.$nin,
            scalarValue
          ];
        } else if ("$ne" in term) {
          term.$nin = [
            term.$ne,
            scalarValue
          ];
          delete term.$ne;
        } else {
          term.$ne = scalarValue;
        }
      } else if (!(operator in term)) {
        term[operator] = scalarValue;
        if (operator === "$eq") {
          delete term.$ne;
        }
      } else if (!(0, import_es6.default)(term[operator], scalarValue)) {
        continue;
      }
    }
    res.push(record);
  }
  return res;
}, "applyWhereOperatorTerm");
var assignWhereScalarOperator = /* @__PURE__ */ __name((res, scalar, operator, value) => {
  switch (operator) {
    case "$eq":
    case "$ne":
    case "$gt":
    case "$gte":
    case "$lt":
    case "$lte":
    case "$contains":
    case "$startsWith":
    case "$endsWith": {
      res[operator] = value == null ? null : scalar.encode(value);
      break;
    }
    case "$in":
    case "$nin": {
      if (!Array.isArray(value)) {
        throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Expected array for '${operator}' operator`);
      }
      res[operator] = value.map((v) => v == null ? null : scalar.encode(v));
      break;
    }
    default: {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Invalid operator: ${operator}`);
    }
  }
}, "assignWhereScalarOperator");

// src/engine/find/record.ts
var convertWhereRecord = /* @__PURE__ */ __name((states, collection, where) => applyFilterRecord([
  {
    [collection.reservedNames.hash]: {
      $in: states.map((s) => s.hash)
    }
  }
], collection, where), "convertWhereRecord");
var applyFilterRecord = /* @__PURE__ */ __name((records, collection, filter) => {
  for (const [key, term] of Object.entries(filter ?? {})) {
    if (term == null)
      continue;
    const choices = collection.schema[key] ?? [];
    if (!choices?.length) {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Unknown where key: '${key}'`);
    }
    const base = records;
    records = [];
    for (const choice of choices) {
      records.push(...choice.field ? applyWhereRecordTerm(base, choice.field, term) : applyWhereState(base, choice.schema, term));
    }
  }
  return records;
}, "applyFilterRecord");
var applyWhereState = /* @__PURE__ */ __name((records, schema, term) => {
  for (const [operator, where] of Object.entries(term)) {
    if (typeof where !== "object" || where == null) {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Invalid where operator: '${operator}'`);
    }
    records = applyWhereOperatorRecord(records, schema, operator, where);
  }
  return records;
}, "applyWhereState");
var applyWhereOperatorRecord = /* @__PURE__ */ __name((records, schema, operator, where) => {
  switch (operator) {
    case "$eq":
    case "$gt":
    case "$gte":
    case "$lt":
    case "$lte":
    case "$contains":
    case "$startsWith":
    case "$endsWith": {
      return applyWhereEveryOperatorRecord(records, schema, operator, where);
    }
    case "$ne": {
      return applyWhereNotEqualRecord(records, schema, where);
    }
    case "$in": {
      return applyWhereInOperatorRecord(records, schema, where);
    }
    case "$nin": {
      return applyWhereNotInOperatorRecord(records, schema, where);
    }
    default: {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Invalid operator: ${operator}`);
    }
  }
}, "applyWhereOperatorRecord");
var applyWhereEveryOperatorRecord = /* @__PURE__ */ __name((records, schema, operator, where) => {
  for (const [key, value] of Object.entries(where)) {
    records = applyWhereOperatorRecordValue(records, schema, operator, key, value);
  }
  return records;
}, "applyWhereEveryOperatorRecord");
var applyWhereNotEqualRecord = /* @__PURE__ */ __name((records, schema, where) => {
  let base = records;
  const res = [];
  for (const [key, value] of Object.entries(where)) {
    res.push(...applyWhereOperatorRecordValue(base, schema, "$ne", key, value));
    base = applyWhereOperatorRecordValue(base, schema, "$eq", key, value);
  }
  return res;
}, "applyWhereNotEqualRecord");
var applyWhereInOperatorRecord = /* @__PURE__ */ __name((records, schema, where) => {
  if (!Array.isArray(where)) {
    throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Invalid where operator: '$in'`);
  }
  const res = [];
  for (const value of where) {
    res.push(...applyWhereEveryOperatorRecord(records, schema, "$eq", value));
  }
  return res;
}, "applyWhereInOperatorRecord");
var applyWhereNotInOperatorRecord = /* @__PURE__ */ __name((records, schema, where) => {
  if (!Array.isArray(where)) {
    throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Invalid where operator: '$nin'`);
  }
  for (const value of where) {
    records = applyWhereNotEqualRecord(records, schema, value);
  }
  return records;
}, "applyWhereNotInOperatorRecord");
var applyWhereOperatorRecordValue = /* @__PURE__ */ __name((records, schema, operator, key, value) => {
  const choices = Object.values(schema[key] ?? {});
  if (!choices?.length) {
    throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Unknown where key: '${key}'`);
  }
  const res = [];
  for (const choice of choices) {
    if (choice.field) {
      res.push(...applyWhereOperatorTerm(records, choice.field.name, choice.field.type, operator, value));
    } else if (typeof value === "object" && value != null) {
      res.push(...applyWhereOperatorRecord(records, choice.schema, operator, value));
    } else {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Invalid where operator: '${operator}'`);
    }
  }
  return res;
}, "applyWhereOperatorRecordValue");

// src/engine/find/filter.ts
init_esm_shims();
var applyFilter = /* @__PURE__ */ __name((records, collection, filter) => Array.isArray(filter.$or) ? filter.$or.flatMap((w) => applyFilterRecord(records, collection, w)) : applyFilterRecord(records, collection, filter), "applyFilter");

// src/engine/find/where.ts
var convertWhereFilterQuery = /* @__PURE__ */ __name((states, collection, { where, filter }) => ({
  where: convertWhereFilter(states, collection, where, filter)
}), "convertWhereFilterQuery");
var convertFilterQuery = /* @__PURE__ */ __name((states, collection, { filter }) => ({
  where: convertWhereFilter(states, collection, null, filter)
}), "convertFilterQuery");
var convertWhereFilter = /* @__PURE__ */ __name((states, collection, where, filter) => {
  let res = convertWhere(states, collection, where);
  if (filter != null) {
    res = applyFilter(res, collection, filter);
  }
  return res.length === 1 ? res[0] : {
    $or: res
  };
}, "convertWhereFilter");
var convertWhere = /* @__PURE__ */ __name((states, collection, where) => where && Array.isArray(where.$or) ? where.$or.flatMap((w) => convertWhereRecord(states, collection, w)) : convertWhereRecord(states, collection, where), "convertWhere");

// src/engine/find/unique.ts
init_esm_shims();
var convertUniqueFilterQuery = /* @__PURE__ */ __name((states, collection, { unique, filter }) => ({
  where: convertUniqueFilter(states, collection, unique, filter)
}), "convertUniqueFilterQuery");
var convertUniqueFilter = /* @__PURE__ */ __name((states, collection, unique, filter) => {
  let res = convertUnique(states, collection, unique);
  if (filter != null) {
    res = applyFilter(res, collection, filter);
  }
  return res.length === 1 ? res[0] : {
    $or: res
  };
}, "convertUniqueFilter");
var convertUnique = /* @__PURE__ */ __name((states, collection, unique) => {
  if (unique === true) {
    throw new NeuledgeError(NeuledgeError.Code.QUERY_EXECUTION_ERROR, `This query is not executable`);
  }
  let records = [
    {
      [collection.reservedNames.hash]: {
        $in: states.map((s) => s.hash)
      }
    }
  ];
  for (const [key, value] of Object.entries(unique)) {
    const choices = collection.schema[key] ?? [];
    if (!choices?.length) {
      throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Unknown unique key: '${key}'`);
    }
    const base = records;
    records = [];
    for (const choice of choices) {
      if (!choice.field) {
        throw new NeuledgeError(NeuledgeError.Code.QUERY_PARSING_ERROR, `Unknown unique scalar: '${key}'`);
      }
      records.push(...applyWhereRecordTerm(base, choice.field, {
        $eq: value
      }));
    }
  }
  return records;
}, "convertUnique");

// src/engine/select.ts
init_esm_shims();
var convertSelectQuery = /* @__PURE__ */ __name((collection, { select }) => ({
  ...select != null && select !== true ? {
    select: convertSelect(collection, select)
  } : null
}), "convertSelectQuery");
var convertJoinSelectQuery = /* @__PURE__ */ __name((collection, { select }) => ({
  ...select == null ? null : {
    select: select === true ? true : convertSelect(collection, select)
  }
}), "convertJoinSelectQuery");
var convertLeftJoinSelectQuery = /* @__PURE__ */ __name((collection, { select }) => ({
  select: select != null && select !== true ? convertSelect(collection, select) : true
}), "convertLeftJoinSelectQuery");
var convertSelect = /* @__PURE__ */ __name((collection, select) => {
  const res = {
    [collection.reservedNames.hash]: true,
    [collection.reservedNames.version]: true
  };
  for (const key in select) {
    if (!select[key])
      continue;
    for (const fieldName of collection.getSchemaFieldNames(key)) {
      res[fieldName] = true;
    }
  }
  return res;
}, "convertSelect");

// src/engine/relations/populate.ts
init_esm_shims();
var convertPopulateOneQuery = /* @__PURE__ */ __name((metadata, collection, { populateOne }) => ({
  ...populateOne == null ? null : {
    leftJoin: convertPopulateOne(metadata, collection, populateOne)
  }
}), "convertPopulateOneQuery");
var convertPopulateOne = /* @__PURE__ */ __name((metadata, collection, populateOne) => convertRelationQueryOptions(metadata, collection, populateOne, ({ collection: collection2, by, query }) => ({
  collection: collection2,
  by,
  ...convertLeftJoinSelectQuery(collection2, query),
  ...convertFilterQuery(collection2.states, collection2, query),
  ...convertExpandQuery(metadata, collection2, query),
  ...convertPopulateOneQuery(metadata, collection2, query)
})), "convertPopulateOne");

// src/engine/relations/expand.ts
var convertExpandQuery = /* @__PURE__ */ __name((metadata, collection, { expand }) => ({
  ...expand == null ? null : {
    innerJoin: convertExpand(metadata, collection, expand)
  }
}), "convertExpandQuery");
var convertExpand = /* @__PURE__ */ __name((metadata, collection, expand) => convertRelationQueryOptions(metadata, collection, expand, ({ collection: collection2, by, query }) => ({
  collection: collection2,
  by,
  ...convertJoinSelectQuery(collection2, query),
  ...convertFilterQuery(collection2.states, collection2, query),
  ...convertExpandQuery(metadata, collection2, query),
  ...convertPopulateOneQuery(metadata, collection2, query)
})), "convertExpand");

// src/engine/relations/match.ts
init_esm_shims();
var convertMatchQuery = /* @__PURE__ */ __name((metadata, collection, { match }) => ({
  ...match == null ? null : {
    innerJoin: convertMatch(metadata, collection, match)
  }
}), "convertMatchQuery");
var convertMatch = /* @__PURE__ */ __name((metadata, collection, match) => convertRelationQueryOptions(metadata, collection, match, ({ collection: collection2, by, query }) => ({
  collection: collection2,
  by,
  ...convertFilterQuery(collection2.states, collection2, query),
  ...convertMatchQuery(metadata, collection2, query)
})), "convertMatch");

// src/engine/relations/retrieve.ts
init_esm_shims();
var retrieveEntities = /* @__PURE__ */ __name(async (entities, { returns, select }) => {
  if (!select)
    return;
  if (returns === "old") {
    return Object.assign(entities.map((entity) => entity.oldEntity), {
      nextOffset: entities.nextOffset
    });
  }
  if (select == true) {
    return Object.assign(entities.map((entity) => entity.entity), {
      nextOffset: entities.nextOffset
    });
  }
  return Object.assign(entities.map((entity) => projectEntity(entity.entity, select)), {
    nextOffset: entities.nextOffset
  });
}, "retrieveEntities");
var projectEntity = /* @__PURE__ */ __name((entity, select) => {
  const projectedEntity = {
    $state: entity.$state,
    $version: entity.$version
  };
  for (const [key, value] of Object.entries(select)) {
    if (!value)
      continue;
    projectedEntity[key] = entity[key];
  }
  return projectedEntity;
}, "projectEntity");

// src/engine/exec/init.ts
var execInitMany = /* @__PURE__ */ __name(async (engine, options) => {
  const metadata = await engine.metadata;
  const { collection } = chooseStatesCollection(metadata, options.states);
  const [state] = options.states;
  const fn = state[options.method];
  if (fn?.mutation !== "create") {
    throw new NeuledgeError(NeuledgeError.Code.INVALID_MUTATION, `Mutation ${String(options.method)} is not an init mutation`);
  }
  const newEntities = await Promise.all(options.args.map((args) => fn(args)));
  const entities = newEntities.map((entity) => ({
    ...entity,
    $version: 0
  }));
  const documents = entities.map((entity) => toDocument(metadata, collection, entity));
  const { insertedIds } = await engine.store.insert({
    collection,
    documents
  });
  const updatedEntities = documents.map((oldDoc, i) => {
    const document = {
      ...oldDoc,
      ...insertedIds[i]
    };
    const entity = toEntityOrThrow(metadata, collection, document);
    return {
      entity,
      document,
      oldEntity: null
    };
  });
  return retrieveEntities(updatedEntities, options);
}, "execInitMany");
var execInitOne = /* @__PURE__ */ __name(async (engine, options) => {
  const res = await execInitMany(engine, options);
  return res && res[0];
}, "execInitOne");

// src/engine/exec/find.ts
init_esm_shims();

// src/engine/pagination/index.ts
init_esm_shims();

// src/engine/pagination/limit.ts
init_esm_shims();
var DEFAULT_QUERY_LIMIT = 1e3;
var convertLimitQuery = /* @__PURE__ */ __name((options) => ({
  limit: options.limit ?? DEFAULT_QUERY_LIMIT
}), "convertLimitQuery");
var checkLimitedList = /* @__PURE__ */ __name((options, list) => {
  if (options.limit == null && list.length >= DEFAULT_QUERY_LIMIT && typeof process === "object" && process?.env?.NODE_ENV !== "production") {
    console.warn(`Warning: Too many documents found without an explicit limit. A default limit of ${DEFAULT_QUERY_LIMIT} 
    was applied. Consider adding a limit to your query.`);
    console.trace(`Your query can be found here:`);
  }
  return list;
}, "checkLimitedList");

// src/engine/pagination/offset.ts
init_esm_shims();
var convertOffsetQuery = /* @__PURE__ */ __name(({ offset }) => offset == null ? {} : {
  offset
}, "convertOffsetQuery");

// src/engine/pagination/sort.ts
init_esm_shims();
var convertSortQuery = /* @__PURE__ */ __name((collection, { sort }) => {
  let reverse = false;
  if (typeof sort === "string") {
    reverse = sort[0] === "-";
    const indexKey = sort.slice(1);
    for (const state of collection.states) {
      const index = state.instance.$indexes?.[indexKey];
      if (index != null) {
        sort = index.fields;
        break;
      }
    }
    if (typeof sort === "string") {
      throw new NeuledgeError(NeuledgeError.Code.UNKNOWN_SORT_INDEX, `Unknown sort index: ${indexKey}`);
    }
  } else if (sort == null) {
    return {};
  }
  const res = {};
  for (const key of sort) {
    let sort2;
    switch (key[0]) {
      case "+": {
        sort2 = reverse ? "desc" : "asc";
        break;
      }
      case "-": {
        sort2 = reverse ? "asc" : "desc";
        break;
      }
      default: {
        throw new NeuledgeError(NeuledgeError.Code.UNKNOWN_SORT_DIRECTION, `Unknown sort direction: '${key}'`);
      }
    }
    const field = key.slice(1);
    for (const name of collection.getSchemaFieldNames(field)) {
      res[name] = sort2;
    }
  }
  return {
    sort: res
  };
}, "convertSortQuery");

// src/engine/exec/find.ts
var execFindMany = /* @__PURE__ */ __name(async (engine, options) => {
  const metadata = await engine.metadata;
  const { states, collection } = chooseStatesCollection(metadata, options.states);
  const list = checkLimitedList(options, await engine.store.find({
    collection,
    ...convertSelectQuery(collection, options),
    ...convertExpandQuery(metadata, collection, options),
    ...convertPopulateOneQuery(metadata, collection, options),
    ...convertWhereFilterQuery(states, collection, options),
    ...convertOffsetQuery(options),
    ...convertLimitQuery(options),
    ...convertSortQuery(collection, options)
  }));
  return toEntityList(metadata, collection, list);
}, "execFindMany");
var execFindUnique = /* @__PURE__ */ __name(async (engine, options) => {
  const metadata = await engine.metadata;
  const { states, collection } = chooseStatesCollection(metadata, options.states);
  const [document] = await engine.store.find({
    collection,
    ...convertSelectQuery(collection, options),
    ...convertExpandQuery(metadata, collection, options),
    ...convertPopulateOneQuery(metadata, collection, options),
    ...convertUniqueFilterQuery(states, collection, options),
    limit: 1
  });
  return toMaybeEntity(metadata, collection, document);
}, "execFindUnique");
var execFindUniqueOrThrow = /* @__PURE__ */ __name(async (engine, options) => {
  const metadata = await engine.metadata;
  const { states, collection } = chooseStatesCollection(metadata, options.states);
  const [document] = await engine.store.find({
    collection,
    ...convertSelectQuery(collection, options),
    ...convertExpandQuery(metadata, collection, options),
    ...convertPopulateOneQuery(metadata, collection, options),
    ...convertUniqueFilterQuery(states, collection, options),
    limit: 1
  });
  return toEntityOrThrow(metadata, collection, document);
}, "execFindUniqueOrThrow");
var execFindFirst = /* @__PURE__ */ __name(async (engine, options) => {
  const metadata = await engine.metadata;
  const { states, collection } = chooseStatesCollection(metadata, options.states);
  const [document] = await engine.store.find({
    collection,
    ...convertSelectQuery(collection, options),
    ...convertExpandQuery(metadata, collection, options),
    ...convertPopulateOneQuery(metadata, collection, options),
    ...convertWhereFilterQuery(states, collection, options),
    ...convertOffsetQuery(options),
    limit: 1,
    ...convertSortQuery(collection, options)
  });
  return toMaybeEntity(metadata, collection, document);
}, "execFindFirst");
var execFindFirstOrThrow = /* @__PURE__ */ __name(async (engine, options) => {
  const metadata = await engine.metadata;
  const { states, collection } = chooseStatesCollection(metadata, options.states);
  const [document] = await engine.store.find({
    collection,
    ...convertSelectQuery(collection, options),
    ...convertExpandQuery(metadata, collection, options),
    ...convertPopulateOneQuery(metadata, collection, options),
    ...convertWhereFilterQuery(states, collection, options),
    ...convertOffsetQuery(options),
    limit: 1,
    ...convertSortQuery(collection, options)
  });
  return toEntityOrThrow(metadata, collection, document);
}, "execFindFirstOrThrow");

// src/engine/exec/alter.ts
init_esm_shims();

// src/engine/mutations/index.ts
init_esm_shims();

// src/engine/mutations/entities.ts
init_esm_shims();
import pLimit3 from "p-limit";
var alterEntityList = /* @__PURE__ */ __name(async (states, entities, method, args) => {
  const asyncLimit = pLimit3(10);
  return Promise.all(entities.map((entity) => asyncLimit(() => alterEntity(states, entity, method, args))));
}, "alterEntityList");
var alterEntity = /* @__PURE__ */ __name(async (states, entity, method, args) => {
  const { $state, $version, ...thisArg } = entity;
  const state = states[$state];
  if (!state) {
    throw new NeuledgeError(NeuledgeError.Code.INTERNAL_ERROR, `State ${$state} not found`);
  }
  const fn = state[method];
  switch (fn?.mutation) {
    case "update": {
      const mutated = await fn.call(thisArg, args);
      return {
        ...mutated,
        $version: $version + 1
      };
    }
    case "delete": {
      await fn.call(thisArg, args);
      return null;
    }
    default: {
      break;
    }
  }
  throw new NeuledgeError(NeuledgeError.Code.INVALID_MUTATION, `Mutation ${String(method)} is not an alter mutation`);
}, "alterEntity");

// src/engine/mutations/store.ts
init_esm_shims();
import pLimit4 from "p-limit";
var alterStoreDocuments = /* @__PURE__ */ __name(async (store, collection, documents, updates) => {
  const asyncLimit = pLimit4(10);
  const deleteDocuments2 = [];
  const res = await Promise.all(documents.map((document, index) => {
    const updated = updates[index];
    if (updated == null) {
      deleteDocuments2.push(document);
      return true;
    }
    return asyncLimit(() => updateStoreDocument(store, collection, document, updated));
  }));
  if (deleteDocuments2.length) {
    await deleteStoreDocuments(store, collection, deleteDocuments2);
  }
  return res;
}, "alterStoreDocuments");
var updateStoreDocument = /* @__PURE__ */ __name(async (store, collection, document, updated) => {
  const setEntries = Object.entries(updated).filter(([key, value]) => value !== document[key]);
  if (!setEntries.length) {
    return true;
  }
  const res = await store.update({
    collection,
    where: getWhereRecordByPrimaryKeys(collection, document),
    set: Object.fromEntries(setEntries),
    limit: 1
  });
  return !!res.affectedCount;
}, "updateStoreDocument");
var deleteStoreDocuments = /* @__PURE__ */ __name(async (store, collection, documents) => {
  await store.delete({
    collection,
    where: getWhereByPrimaryKeys(collection, documents),
    limit: documents.length
  });
}, "deleteStoreDocuments");
var getWhereByPrimaryKeys = /* @__PURE__ */ __name((collection, documents) => ({
  $or: documents.map((document) => getWhereRecordByPrimaryKeys(collection, document))
}), "getWhereByPrimaryKeys");
var getWhereRecordByPrimaryKeys = /* @__PURE__ */ __name((collection, document) => Object.fromEntries([
  ...Object.keys(collection.primaryKey.fields).map((key) => [
    key,
    {
      $eq: document[key] ?? null
    }
  ]),
  [
    collection.reservedNames.hash,
    {
      $eq: document[collection.reservedNames.hash] ?? null
    }
  ],
  [
    collection.reservedNames.version,
    {
      $eq: document[collection.reservedNames.version] ?? 0
    }
  ]
]), "getWhereRecordByPrimaryKeys");

// src/engine/mutations/states.ts
init_esm_shims();
var getStateDefinitionMap = /* @__PURE__ */ __name((states) => {
  const map = {};
  for (const state of states) {
    map[state.$name] = state;
  }
  return map;
}, "getStateDefinitionMap");

// src/engine/exec/alter.ts
var ALTER_VERSION_RETRIES = 3;
var execAlterMany = /* @__PURE__ */ __name(async (engine, options) => {
  const ctx = await preprareAlter(engine, options);
  if (!ctx)
    return;
  let documents = await engine.store.find(ctx.storeFilters);
  await alterDocuments(ctx, documents);
  for (let retries = 1; retries < ALTER_VERSION_RETRIES; retries++) {
    let leftDocs;
    if (ctx.entities.size < documents.length) {
      documents = await engine.store.find(ctx.storeFilters);
      leftDocs = documents.filter((document) => !ctx.entities.has(getDocumentKey(ctx.collection, document)));
    }
    if (!leftDocs?.length) {
      return retrieveEntities([
        ...ctx.entities.values()
      ], options);
    }
    await alterDocuments(ctx, leftDocs);
  }
  throw new NeuledgeError(NeuledgeError.Code.VERSION_MISMATCH, `Version mismatch while altering ${documents.length > 1 ? "entities" : "entity"}`);
}, "execAlterMany");
var execAlterOne = /* @__PURE__ */ __name(async (engine, options) => {
  const res = await execAlterMany(engine, options);
  return res?.[0];
}, "execAlterOne");
var preprareAlter = /* @__PURE__ */ __name(async (engine, options) => {
  const metadata = await engine.metadata;
  const { states, collection } = chooseStatesCollection(metadata, options.states);
  const storeFilters = createStoreFilters(metadata, states, collection, options);
  if (isAlterDeleteOnly(options)) {
    return deleteDocuments(engine.store, storeFilters, options);
  }
  const res = /* @__PURE__ */ new Map();
  return {
    entities: res,
    metadata,
    store: engine.store,
    collection,
    states: getStateDefinitionMap(options.states),
    options,
    storeFilters
  };
}, "preprareAlter");
var createStoreFilters = /* @__PURE__ */ __name((metadata, states, collection, options) => ({
  collection,
  // we don't use select here, because we need to get all fields to validate the
  // current state of the entity. we will use select later to project the result
  // to the user
  ..."unique" in options ? convertUniqueFilterQuery(states, collection, options) : convertWhereFilterQuery(states, collection, options),
  ...convertMatchQuery(metadata, collection, options),
  ...options.type === "AlterMany" ? convertLimitQuery(options) : {
    limit: 1
  }
}), "createStoreFilters");
var isAlterDeleteOnly = /* @__PURE__ */ __name((options) => {
  if (options.select || options.match) {
    return false;
  }
  for (const state of options.states) {
    const mutation = state[options.method];
    if (mutation?.mutation !== "delete" || !mutation.virtual) {
      return false;
    }
  }
  return true;
}, "isAlterDeleteOnly");
var deleteDocuments = /* @__PURE__ */ __name(async (store, storeFilters, options) => {
  let res;
  do {
    res = await store.delete(storeFilters);
  } while (options.type === "AlterMany" && (!("limit" in options) || options.limit == null) && res.affectedCount >= DEFAULT_QUERY_LIMIT);
}, "deleteDocuments");
var alterDocuments = /* @__PURE__ */ __name(async (ctx, documents) => {
  const convert = ctx.options.type.endsWith("OrThrow") ? toEntityListOrThrow : toEntityList;
  const list = ctx.options.type === "AlterMany" ? checkLimitedList(ctx.options, documents) : documents;
  const entities = convert(ctx.metadata, ctx.collection, list);
  const updated = await alterEntityList(ctx.states, entities, ctx.options.method, ctx.options.args[0]);
  const updatedDocs = updated.map((entity) => entity && toDocument(ctx.metadata, ctx.collection, entity));
  const success = await alterStoreDocuments(ctx.store, ctx.collection, documents, updatedDocs);
  for (const [i, flag] of success.entries()) {
    if (!flag)
      continue;
    const document = updatedDocs[i] ?? documents[i];
    const entity = updated[i] ?? entities[i];
    const key = getDocumentKey(ctx.collection, document);
    ctx.entities.set(key, {
      document,
      entity,
      oldEntity: entities[i]
    });
  }
}, "alterDocuments");
var getDocumentKey = /* @__PURE__ */ __name((collection, document) => JSON.stringify(Object.keys(collection.primaryKey.fields).map((key) => document[key] ?? null)), "getDocumentKey");

// src/mutations/index.ts
init_esm_shims();

// src/mutations/alter.ts
init_esm_shims();

// src/mutations/init.ts
init_esm_shims();

// src/mutations/mutation.ts
init_esm_shims();

// src/mutations/generator.ts
init_esm_shims();
var MutationGenerator = /* @__PURE__ */ __name((type, states, generator) => new Proxy({}, {
  get: (_, method) => hasMutation(type, states, method) ? (...args) => generator({
    type,
    states,
    method,
    args: typeof args[0] === "number" ? Array.from({
      length: args[0]
    }).fill({}) : [
      args[0] ?? {},
      ...args.slice(1)
    ]
  }) : void 0,
  ownKeys: () => {
    if (!states.length) {
      return [];
    }
    return Object.keys(states[0]).filter((method) => hasMutation(type, states, method));
  },
  has: (_, method) => hasMutation(type, states, method)
}), "MutationGenerator");
var hasMutation = /* @__PURE__ */ __name((type, states, method) => states.every((state) => {
  const fn = state[method];
  switch (fn?.mutation) {
    case "create": {
      return type.startsWith("Init");
    }
    case "update":
    case "delete": {
      return type.startsWith("Alter");
    }
    default: {
      return false;
    }
  }
}), "hasMutation");

// src/engine/engine.ts
var NeuledgeEngine = class {
  store;
  metadata;
  constructor(options) {
    this.store = options.store;
    this.metadata = loadMetadata(this.store, options.metadataCollectionName).catch(NeuledgeError.wrap());
    this.metadata.catch(() => {
    });
  }
  // finds
  /**
  * Find many entities that match the given states.
  * It's not possible to query multiple states from different collections at
  * once.
  */
  findMany(...states) {
    return new QueryClass({
      type: "FindMany",
      states,
      select: true,
      exec: (options) => execFindMany(this, options)
    });
  }
  /**
  * Find a unique entity that matches the given states.
  * Use the `.unique()` method to provide the unique where clause. Returns null
  * if no entity was found. It's not possible to query multiple states from
  * different collections at once.
  */
  findUnique(...states) {
    return new QueryClass({
      type: "FindUnique",
      states,
      select: true,
      unique: true,
      exec: (options) => execFindUnique(this, options)
    });
  }
  /**
  * Find a unique entity that matches the given states.
  * Use the `.unique()` method to provide the unique where clause. Throws an
  * error if no entity was found. It's not possible to query multiple states
  * from different collections at once.
  */
  findUniqueOrThrow(...states) {
    return new QueryClass({
      type: "FindUniqueOrThrow",
      states,
      select: true,
      unique: true,
      exec: (options) => execFindUniqueOrThrow(this, options)
    });
  }
  /**
  * Find the first entity that matches the given states.
  * Returns null if no entity was found. It's not possible to query multiple
  * states from different collections at once.
  */
  findFirst(...states) {
    return new QueryClass({
      type: "FindFirst",
      states,
      select: true,
      exec: (options) => execFindFirst(this, options)
    });
  }
  /**
  * Find the first entity that matches the given states.
  * Throws an error if no entity was found. It's not possible to query multiple
  * states from different collections at once.
  */
  findFirstOrThrow(...states) {
    return new QueryClass({
      type: "FindFirstOrThrow",
      states,
      select: true,
      exec: (options) => execFindFirstOrThrow(this, options)
    });
  }
  // init
  /**
  * Call a create mutation for the given state and create multiple new
  * entities.
  * Returns void by default. Use the `.select()` method to return the created
  * entities.
  *
  * For example, for a state `DraftPost` with the create mutation `create`:
  * ```
  * engine.initMany(DraftPost).create({ title: 'Hello' }, { title: 'World' })
  * ```
  */
  initMany(state) {
    return MutationGenerator("InitMany", [
      state
    ], (options) => new QueryClass({
      ...options,
      exec: (options2) => execInitMany(this, options2)
    }));
  }
  /**
  * Call a create mutation for the given state and create a new entity.
  * Returns void by default. Use the `.select()` method to return the created
  * entity.
  *
  * For example, for a state `DraftPost` with the create mutation `create`:
  * ```
  * engine.initOne(DraftPost).create({ title: 'Hello' })
  * ```
  */
  initOne(state) {
    return MutationGenerator("InitOne", [
      state
    ], (options) => new QueryClass({
      ...options,
      exec: (options2) => execInitOne(this, options2)
    }));
  }
  // alter
  /**
  * Call an update or delete mutation for the given states and alter multiple
  * entities at once.
  * Returns void by default. Use the `.return()` method to return the original
  * or altered entities. You may filter and limit the entities that are altered
  * by using `.where()` or other methods.
  *
  * For example, for a state `DraftPost` with the update mutation `update`:
  * ```
  * engine.alterMany(DraftPost).update({ title: 'Hello' })
  * ```
  */
  alterMany(...states) {
    return MutationGenerator("AlterMany", states, (options) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      new QueryClass({
        returns: "new",
        ...options,
        exec: (options2) => execAlterMany(this, options2)
      })
    ));
  }
  /**
  * Call an update or delete mutation for the given states and alter the first
  * matching entity.
  * Returns void by default. Use the `.return()` method to return the original
  * or altered entities. You may filter and limit the entities that are altered
  * by using `.where()` or other methods.
  *
  * For example, for a state `DraftPost` with the update mutation `update`:
  * ```
  * engine.alterFirst(DraftPost).update({ title: 'Hello' })
  * ```
  */
  alterFirst(...states) {
    return MutationGenerator("AlterFirst", states, (options) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      new QueryClass({
        returns: "new",
        ...options,
        exec: (options2) => execAlterOne(this, options2)
      })
    ));
  }
  /**
  * Call an update or delete mutation for the given states and alter the first
  * matching entity.
  * Returns void by default. Throws an error if no entity was found. Use the
  * `.return()` method to return the original or altered entities. You may
  * filter and limit the entities that are altered by using `.where()` or other
  * methods.
  *
  * For example, for a state `DraftPost` with the update mutation `update`:
  * ```
  * engine.alterFirstOrThrow(DraftPost).update({ title: 'Hello' })
  * ```
  */
  alterFirstOrThrow(...states) {
    return MutationGenerator("AlterFirstOrThrow", states, (options) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      new QueryClass({
        returns: "new",
        ...options,
        exec: (options2) => execAlterOne(this, options2)
      })
    ));
  }
  /**
  * Call an update or delete mutation for the given states and alter the
  * uniquely matching entity.
  * Returns void by default. Use the `.return()` method to return the original
  * or altered entity. Use the `.unique()` method to specify the unique fields.
  *
  * For example, for a state `DraftPost` with the update mutation `update`:
  * ```
  * engine.alterUnique(DraftPost).update({ title: 'Hello' }).unique({ id: 1 })
  * ```
  */
  alterUnique(...states) {
    return MutationGenerator("AlterUnique", states, (options) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      new QueryClass({
        returns: "new",
        ...options,
        unique: true,
        exec: (options2) => execAlterOne(this, options2)
      })
    ));
  }
  /**
  * Call an update or delete mutation for the given states and alter the
  * uniquely matching entity.
  * Returns void by default. Throws an error if no entity was found. Use the
  * `.return()` method to return the original or altered entity. Use the
  * `.unique()` method to specify the unique fields.
  *
  * For example, for a state `DraftPost` with the update mutation `update`:
  * ```
  * engine.alterUniqueOrThrow(DraftPost).update({ title: 'Hello' }).unique({ id: 1 })
  * ```
  */
  alterUniqueOrThrow(...states) {
    return MutationGenerator("AlterUniqueOrThrow", states, (options) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      new QueryClass({
        returns: "new",
        ...options,
        unique: true,
        exec: (options2) => execAlterOne(this, options2)
      })
    ));
  }
  // utils
  /**
  * Return a promise that resolves when the engine is ready.
  * The engine is ready when the metadata is loaded and the database is
  * connected. This is useful when you want to wait for the engine to be ready
  * before starting your server. If you query the engine before it is ready,
  * the queries will be queued and executed when the engine is ready or throw
  * if there is an error while loading the engine.
  */
  async ready() {
    await this.metadata;
    return this;
  }
};
__name(NeuledgeEngine, "NeuledgeEngine");

// src/entity.ts
init_esm_shims();

// src/list.ts
init_esm_shims();
var createEntityList = /* @__PURE__ */ __name((entries, nextOffset) => Object.assign(entries, {
  nextOffset
}), "createEntityList");

// src/escaped.ts
var escaped_exports = {};
__export(escaped_exports, {
  State: () => State,
  either: () => createEitherDefintion,
  mutation: () => createMutation,
  runtime: () => runtime,
  scalars: () => types
});
init_esm_shims();
import { types, runtime } from "@neuledge/scalars";
export {
  escaped_exports as $,
  NeuledgeEngine,
  NeuledgeError,
  QueryClass,
  State,
  createEitherDefintion,
  createEntityList,
  createMutation,
  fromSortedField,
  isStateDefinitionScalarTypeScalar,
  isStateDefinitionScalarTypeStates,
  parseSortedField,
  resolveDefer
};
//# sourceMappingURL=index.mjs.map