{"version":3,"sources":["../../../node_modules/tsup/assets/cjs_shims.js","../../../node_modules/fast-deep-equal/es6/index.js","../src/index.ts","../src/definitions/index.ts","../src/definitions/either.ts","../src/definitions/mutations/index.ts","../src/definitions/mutations/generator.ts","../src/definitions/mutations/mutation.ts","../src/definitions/mutations/state-helpers.ts","../src/definitions/state/index.ts","../src/definitions/state/decorator.ts","../src/error.ts","../src/glob.ts","../src/definitions/state/indexes.ts","../src/definitions/state/relations.ts","../src/definitions/state/scalar.ts","../src/definitions/state/sort.ts","../src/definitions/state/state.ts","../src/definitions/state/find/index.ts","../src/definitions/state/find/state-definition.ts","../src/definitions/state/find/term.ts","../src/definitions/defer.ts","../src/queries/index.ts","../src/queries/alter/index.ts","../src/queries/alter/first.ts","../src/queries/alter/first-or-throw.ts","../src/queries/alter/many.ts","../src/queries/alter/unique.ts","../src/queries/alter/unique-or-throw.ts","../src/queries/init/index.ts","../src/queries/init/many.ts","../src/queries/init/one.ts","../src/queries/find/index.ts","../src/queries/find/first.ts","../src/queries/find/first-or-throw.ts","../src/queries/find/many.ts","../src/queries/find/unique.ts","../src/queries/find/unique-or-throw.ts","../src/queries/raw/index.ts","../src/queries/raw/exec.ts","../src/queries/raw/limit.ts","../src/queries/raw/filter.ts","../src/queries/raw/match/index.ts","../src/queries/raw/match/refine.ts","../src/queries/raw/match/match.ts","../src/queries/raw/method.ts","../src/queries/raw/offset.ts","../src/queries/raw/populate/index.ts","../src/queries/raw/populate/expand.ts","../src/queries/raw/populate/populate.ts","../src/queries/raw/populate/select-many.ts","../src/queries/raw/populate/select-one.ts","../src/queries/raw/return.ts","../src/queries/raw/select.ts","../src/queries/raw/sort.ts","../src/queries/raw/type.ts","../src/queries/raw/unique.ts","../src/queries/raw/where.ts","../src/queries/query.ts","../src/queries/class.ts","../src/engine/index.ts","../src/engine/engine.ts","../src/engine/metadata/index.ts","../src/engine/metadata/load.ts","../src/metadata/index.ts","../src/metadata/change.ts","../src/metadata/collection.ts","../src/metadata/schema.ts","../src/metadata/constants.ts","../src/metadata/metadata.ts","../src/metadata/names/index.ts","../src/metadata/names/collections.ts","../src/metadata/names/fields.ts","../src/metadata/state/index.ts","../src/metadata/state/snapshot.ts","../src/metadata/hash.ts","../src/metadata/state/field.ts","../src/metadata/state/state.ts","../src/metadata/snapshot.ts","../src/engine/metadata/collections.ts","../src/engine/metadata/store.ts","../src/engine/metadata/state.ts","../src/engine/exec/index.ts","../src/engine/exec/init.ts","../src/engine/collection.ts","../src/engine/document.ts","../src/engine/entity.ts","../src/engine/relations/index.ts","../src/engine/relations/expand.ts","../src/engine/relations/relation.ts","../src/engine/find/index.ts","../src/engine/find/where.ts","../src/engine/find/record.ts","../src/engine/find/term.ts","../src/engine/find/filter.ts","../src/engine/find/unique.ts","../src/engine/select.ts","../src/engine/relations/populate.ts","../src/engine/relations/match.ts","../src/engine/relations/retrieve.ts","../src/engine/exec/find.ts","../src/engine/pagination/index.ts","../src/engine/pagination/limit.ts","../src/engine/pagination/offset.ts","../src/engine/pagination/sort.ts","../src/engine/exec/alter.ts","../src/engine/mutations/index.ts","../src/engine/mutations/entities.ts","../src/engine/mutations/store.ts","../src/engine/mutations/states.ts","../src/mutations/index.ts","../src/mutations/alter.ts","../src/mutations/init.ts","../src/mutations/mutation.ts","../src/mutations/generator.ts","../src/entity.ts","../src/list.ts","../src/escaped.ts"],"sourcesContent":["// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL('file:' + __filename).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","export * from './definitions';\nexport * from './queries';\nexport * from './engine';\nexport * from './entity';\nexport * from './error';\nexport * from './list';\n\nexport * as $ from './escaped';\n","export * from './either';\nexport * from './mutations';\nexport * from './state';\nexport * from './defer';\n","import { StateDefinition } from './state';\n\nexport interface EitherDefintion<\n  N extends string = string,\n  S extends StateDefinition = StateDefinition,\n> extends Array<S> {\n  $name: N;\n}\n\nexport const createEitherDefintion = <\n  N extends string,\n  S extends StateDefinition,\n>(\n  name: N,\n  states: readonly S[],\n): EitherDefintion<N, S> => Object.assign([...states], { $name: name });\n","export * from './generator';\nexport * from './mutation';\nexport * from './state-helpers';\n","import { InitiatedEntity, AlteredEntity } from '@/entity';\nimport { StateDefinition, StateType } from '../state';\nimport {\n  CreateWithArgsMutationDefinition,\n  CreateWithoutArgsMutationDefinition,\n  DeleteWithArgsMutationDefinition,\n  DeleteWithoutArgsMutationDefinition,\n  MutationDefinition,\n  MutationDefinitionArguments,\n  UpdateWithArgsMutationDefinition,\n  UpdateWithoutArgsMutationDefinition,\n} from './mutation';\nimport { Resolveable } from './utils';\n\nexport function createMutation<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments,\n>(\n  type: 'create',\n  mutation: (this: void, args: A) => Resolveable<InitiatedEntity<S>>,\n): CreateWithArgsMutationDefinition<S, A>;\nexport function createMutation<S extends StateDefinition>(\n  type: 'create',\n  mutation: (this: void) => Resolveable<InitiatedEntity<S>>,\n): CreateWithoutArgsMutationDefinition<S>;\nexport function createMutation<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments,\n  R extends StateDefinition,\n>(\n  type: 'update',\n  mutation: (this: StateType<S>, args: A) => Resolveable<AlteredEntity<R>>,\n): UpdateWithArgsMutationDefinition<S, A, R>;\nexport function createMutation<\n  S extends StateDefinition,\n  R extends StateDefinition,\n>(\n  type: 'update',\n  mutation: (\n    this: StateType<S>,\n    args?: object,\n  ) => Resolveable<AlteredEntity<R>>,\n): UpdateWithoutArgsMutationDefinition<S, R>;\nexport function createMutation<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments,\n>(\n  type: 'delete',\n  mutation: (this: StateType<S>, args: A) => Resolveable<void>,\n): DeleteWithArgsMutationDefinition<S, A>;\nexport function createMutation<S extends StateDefinition>(\n  type: 'delete',\n  mutation?: (this: StateType<S>) => Resolveable<void>,\n): DeleteWithoutArgsMutationDefinition<S>;\n// eslint-disable-next-line func-style, prefer-arrow/prefer-arrow-functions\nexport function createMutation<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments,\n  R extends StateDefinition,\n>(\n  type: 'create' | 'update' | 'delete',\n  mutation?: (\n    this: StateType<S> | void,\n    args?: A,\n  ) => Resolveable<AlteredEntity<R> | InitiatedEntity<R> | void>,\n): MutationDefinition<S, A, R> {\n  return Object.assign(mutation ?? ((): void => undefined), {\n    mutation: type,\n    virtual: !mutation,\n  }) as MutationDefinition<S, A, R>;\n}\n","import { AlteredEntity, InitiatedEntity } from '@/entity';\nimport { StateDefinition, StateType } from '../state';\nimport { Resolveable } from './utils';\n\nexport type MutationDefinitionArguments = Record<string, unknown>;\n\n// top level\n\nexport type MutationDefinition<\n  S extends StateDefinition = StateDefinition,\n  A extends MutationDefinitionArguments = MutationDefinitionArguments,\n  R extends StateDefinition = StateDefinition,\n> =\n  | CreateMutationDefinition<R, A>\n  | UpdateMutationDefinition<S, A, R>\n  | DeleteMutationDefinition<S>;\n\n// create\n\nexport type CreateMutationDefinition<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments = MutationDefinitionArguments,\n> =\n  | CreateWithArgsMutationDefinition<S, A>\n  | CreateWithoutArgsMutationDefinition<S>;\n\nexport interface CreateWithArgsMutationDefinition<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments = MutationDefinitionArguments,\n> {\n  readonly mutation: 'create';\n  (this: void, args: A): Resolveable<InitiatedEntity<S>>;\n}\n\nexport interface CreateWithoutArgsMutationDefinition<\n  S extends StateDefinition,\n> {\n  readonly mutation: 'create';\n  (this: void): Resolveable<InitiatedEntity<S>>;\n}\n\n// update\n\nexport type UpdateMutationDefinition<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments = MutationDefinitionArguments,\n  R extends StateDefinition = StateDefinition,\n> =\n  | UpdateWithArgsMutationDefinition<S, A, R>\n  | UpdateWithoutArgsMutationDefinition<S, R>;\n\nexport interface UpdateWithArgsMutationDefinition<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments = MutationDefinitionArguments,\n  R extends StateDefinition = StateDefinition,\n> {\n  readonly mutation: 'update';\n  (this: StateType<S>, args: A): Resolveable<AlteredEntity<R>>;\n}\n\nexport interface UpdateWithoutArgsMutationDefinition<\n  S extends StateDefinition,\n  R extends StateDefinition = StateDefinition,\n> {\n  readonly mutation: 'update';\n  (this: StateType<S>): Resolveable<AlteredEntity<R>>;\n}\n\n// delete\n\nexport type DeleteMutationDefinition<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments = MutationDefinitionArguments,\n> =\n  | DeleteWithArgsMutationDefinition<S, A>\n  | DeleteWithoutArgsMutationDefinition<S>;\n\nexport interface DeleteWithArgsMutationDefinition<\n  S extends StateDefinition,\n  A extends MutationDefinitionArguments = MutationDefinitionArguments,\n> {\n  readonly mutation: 'delete';\n  readonly virtual?: false;\n  (this: StateType<S>, args: A): Resolveable<void>;\n}\n\nexport interface DeleteWithoutArgsMutationDefinition<\n  S extends StateDefinition,\n> {\n  readonly mutation: 'delete';\n  readonly virtual?: boolean;\n  (this: StateType<S>): Resolveable<void>;\n}\n","import { StateDefinition, StateName } from '../state';\nimport {\n  CreateMutationDefinition,\n  CreateWithArgsMutationDefinition,\n  CreateWithoutArgsMutationDefinition,\n  DeleteMutationDefinition,\n  DeleteWithArgsMutationDefinition,\n  DeleteWithoutArgsMutationDefinition,\n  UpdateWithArgsMutationDefinition,\n  UpdateWithoutArgsMutationDefinition,\n} from './mutation';\n\n// methods\n\nexport type StateDefinitionMethods<S extends StateDefinition> =\n  | StateDefinitionInitMethods<S>\n  | StateDefinitionAlterMethods<S>;\n\n// init methods\n\nexport type StateDefinitionInitMethods<S extends StateDefinition> =\n  | StateDefinitionInitWithArgsMethods<S>\n  | StateDefinitionInitWithoutArgsMethods<S>;\n\nexport type StateDefinitionInitWithArgsMethods<S extends StateDefinition> =\n  StateDefinitionCreateWithArgsMethods<S>;\n\nexport type StateDefinitionInitWithoutArgsMethods<S extends StateDefinition> =\n  StateDefinitionCreateWithoutArgsMethods<S>;\n\n// alter methods\n\nexport type StateDefinitionAlterMethods<S extends StateDefinition> =\n  | StateDefinitionAlterWithArgsMethods<S>\n  | StateDefinitionAlterWithoutArgsMethods<S>;\n\nexport type StateDefinitionAlterWithArgsMethods<S extends StateDefinition> =\n  | StateDefinitionUpdateWithArgsMethods<S>\n  | StateDefinitionDeleteWithArgsMethods<S>;\n\nexport type StateDefinitionAlterWithoutArgsMethods<S extends StateDefinition> =\n  | StateDefinitionUpdateWithoutArgsMethods<S>\n  | StateDefinitionDeleteWithoutArgsMethods<S>;\n\n// create methods\n\ntype StateDefinitionCreateWithArgsMethods<S extends StateDefinition> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [M in keyof S]: S[M] extends CreateWithArgsMutationDefinition<S, any>\n    ? M\n    : never;\n}[keyof S];\n\ntype StateDefinitionCreateWithoutArgsMethods<S extends StateDefinition> = {\n  [M in keyof S]: S[M] extends CreateWithoutArgsMutationDefinition<S>\n    ? M\n    : never;\n}[keyof S];\n\n// update methods\n\ntype StateDefinitionUpdateWithArgsMethods<S extends StateDefinition> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [M in keyof S]: S[M] extends UpdateWithArgsMutationDefinition<S, any, any>\n    ? M\n    : never;\n}[keyof S];\n\ntype StateDefinitionUpdateWithoutArgsMethods<S extends StateDefinition> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [M in keyof S]: S[M] extends UpdateWithoutArgsMutationDefinition<S, any>\n    ? M\n    : never;\n}[keyof S];\n\n// delete methods\n\ntype StateDefinitionDeleteWithArgsMethods<S extends StateDefinition> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [M in keyof S]: S[M] extends DeleteWithArgsMutationDefinition<S, any>\n    ? M\n    : never;\n}[keyof S];\n\ntype StateDefinitionDeleteWithoutArgsMethods<S extends StateDefinition> = {\n  [M in keyof S]: S[M] extends DeleteWithoutArgsMutationDefinition<S>\n    ? M\n    : never;\n}[keyof S];\n\n// arguments type\n\nexport type StateDefinitionMutationArguments<\n  S extends StateDefinition,\n  M extends keyof S,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n> = S[M] extends (this: any, args: infer A) => any\n  ? unknown extends A\n    ? Record<string, never>\n    : A\n  : Record<string, never>;\n\n// return state\n\nexport type StateDefinitionMutationsReturn<\n  S extends StateDefinition,\n  M extends keyof S,\n> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [N in StateName<S>]: S extends StateDefinition<N, any>\n    ? S[M] extends DeleteMutationDefinition<S>\n      ? never\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      S[M] extends CreateMutationDefinition<S, any>\n      ? S\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      S[M] extends UpdateWithArgsMutationDefinition<S, any, infer R>\n      ? R\n      : S[M] extends UpdateWithoutArgsMutationDefinition<S, infer R>\n      ? R\n      : never\n    : never;\n}[StateName<S>];\n","export * from './decorator';\nexport * from './indexes';\nexport * from './relations';\nexport * from './scalar';\nexport * from './sort';\nexport * from './state';\nexport * from './find';\n","import { NeuledgeError } from '@/error';\nimport { neuledgeGlob } from '@/glob';\nimport { StateDefinition } from './state';\n\nconst { stateDefinitions } = neuledgeGlob;\n\nexport const State =\n  <N extends string, T>() =>\n  <S extends StateDefinition<N, T>>(state: S): void => {\n    if (\n      stateDefinitions.has(state.$name) &&\n      stateDefinitions.get(state.$name) !== state\n    ) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.DUPLICATE_STATE_NAME,\n        `State \"${state.$name}\" is already defined.`,\n      );\n    }\n\n    stateDefinitions.set(state.$name, state);\n  };\n","import { StoreError } from '@neuledge/store';\n\nenum NeuledgeErrorCode {\n  // version checks\n  VERSION_MISMATCH = 'VERSION_MISMATCH',\n\n  // argument errors\n  INVALID_ARGUMENT = 'INVALID_ARGUMENT',\n\n  // document checks\n  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',\n\n  // collection checks\n  NO_COLLECTIONS = 'NO_COLLECTIONS',\n  MULTIPLE_COLLECTIONS = 'MULTIPLE_COLLECTIONS',\n\n  // state checks\n  ENTITY_STATE_NOT_FOUND = 'ENTITY_STATE_NOT_FOUND',\n  RESERVED_FIELD_NAME = 'RESERVED_FIELD_NAME',\n  DUPLICATE_STATE_NAME = 'DUPLICATE_STATE_NAME',\n\n  // sort checks\n  UNKNOWN_SORT_DIRECTION = 'UNKNOWN_SORT_DIRECTION',\n  UNKNOWN_SORT_INDEX = 'UNKNOWN_SORT_INDEX',\n  UNKNOWN_SORT_FIELD = 'UNKNOWN_SORT_FIELD',\n\n  // relation checks\n  RELATION_FIELD_NOT_FOUND = 'RELATION_FIELD_NOT_FOUND',\n  RELATION_STATE_NOT_FOUND = 'RELATION_STATE_NOT_FOUND',\n\n  // query checks\n  QUERY_PARSING_ERROR = 'QUERY_PARSING_ERROR',\n  QUERY_EXECUTION_ERROR = 'QUERY_EXECUTION_ERROR',\n  INVALID_MUTATION = 'INVALID_MUTATION',\n\n  // metadata checks\n  UNSUPPORTED_METADATA = 'UNSUPPORTED_METADATA',\n  CORRUPTED_METADATA = 'CORRUPTED_METADATA',\n  METADATA_SAVE_ERROR = 'METADATA_SAVE_ERROR',\n  METADATA_LOAD_ERROR = 'METADATA_LOAD_ERROR',\n\n  // internal errors\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n  NOT_IMPLEMENTED = 'NOT_IMPLEMENTED',\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace NeuledgeError {\n  export type Code = NeuledgeErrorCode;\n}\n\nexport class NeuledgeError extends Error {\n  static Code = NeuledgeErrorCode;\n\n  static wrap =\n    (code?: NeuledgeErrorCode, message?: string, hideOriginalError?: boolean) =>\n    (originalError: Error): never => {\n      throw NeuledgeError.fromError(\n        originalError,\n        code,\n        message,\n        hideOriginalError,\n      );\n    };\n\n  static fromError(\n    originalError: Error | unknown,\n    code?: NeuledgeError.Code,\n    message?: string,\n    hideOriginalError?: boolean,\n  ): NeuledgeError {\n    if (originalError instanceof NeuledgeError) {\n      return originalError;\n    }\n\n    const orgMsg = String((originalError as Error)?.message ?? originalError);\n\n    const error = new NeuledgeError(\n      originalError instanceof StoreError\n        ? fromStoreErrorCode(originalError.code, code)\n        : code ?? NeuledgeError.Code.INTERNAL_ERROR,\n      hideOriginalError\n        ? message ?? 'An unknown error occurred'\n        : message == null\n        ? orgMsg\n        : `${message}: ${orgMsg}`,\n    );\n\n    error.stack = (originalError as Error)?.stack;\n    error.originalError = originalError as Error;\n\n    return error;\n  }\n\n  constructor(public readonly code: NeuledgeError.Code, message: string) {\n    super(message);\n    this.name = 'NeuledgeError';\n  }\n\n  public originalError?: Error;\n}\n\nconst fromStoreErrorCode = (\n  code: StoreError.Code,\n  defaultCode?: NeuledgeError.Code,\n): NeuledgeError.Code => {\n  switch (code) {\n    case StoreError.Code.INVALID_DATA: {\n      return NeuledgeError.Code.CORRUPTED_METADATA;\n    }\n\n    case StoreError.Code.NOT_IMPLEMENTED: {\n      return NeuledgeError.Code.NOT_IMPLEMENTED;\n    }\n\n    // case StoreError.Code.INVALID_INPUT:\n    // case StoreError.Code.INTERNAL_ERROR:\n    default: {\n      return defaultCode ?? NeuledgeError.Code.INTERNAL_ERROR;\n    }\n  }\n};\n","import type { StateDefinition, StateName } from './definitions';\n\nexport interface NeuledgeGlob {\n  stateDefinitions: Map<StateName, StateDefinition>;\n}\n\nconst globKey = '__NeuledgeGlob__';\n\nconst glob = (\n  typeof globalThis === 'undefined'\n    ? typeof self === 'undefined'\n      ? typeof window === 'undefined'\n        ? typeof global === 'undefined'\n          ? {}\n          : global\n        : window\n      : self\n    : globalThis\n) as typeof globalThis & { [globKey]?: NeuledgeGlob };\n\nexport const neuledgeGlob = (glob[globKey] = glob[globKey] ?? {\n  stateDefinitions: new Map<StateName, StateDefinition>(),\n});\n","import { SortDefinition, SortDefinitionKey } from './sort';\n\nexport interface StateDefinitionId<T> {\n  auto?: 'increment';\n  fields: SortDefinition<T>;\n}\n\nexport interface StateDefinitionIndex<T> {\n  fields: SortDefinition<T>;\n  unique?: boolean;\n}\n\nexport type InitiatedState<\n  ID extends StateDefinitionId<T>,\n  T,\n> = ID['auto'] extends string\n  ? {\n      [K in Exclude<keyof T, SortDefinitionKey<ID['fields'][number]>>]: T[K];\n    } & {\n      [K in keyof T & SortDefinitionKey<ID['fields'][number]>]?: T[K] | null;\n    }\n  : T;\n","import { StateDefinition, StateRelations } from './state';\n\nexport interface StateDefinitionRelation {\n  states: readonly StateDefinition[];\n  list?: boolean | null;\n  reference?: string;\n}\n\nexport type StateAllRelations<S extends StateDefinition> =\n  keyof StateRelations<S>;\n\nexport type StateManyRelations<S extends StateDefinition> = {\n  [K in keyof StateRelations<S>]: StateRelations<S>[K] extends {\n    states: readonly StateDefinition[];\n    list: true;\n  }\n    ? K\n    : never;\n}[keyof StateRelations<S>];\n\nexport type StateOneRelations<S extends StateDefinition> = {\n  [K in keyof StateRelations<S>]: StateRelations<S>[K] extends {\n    states: readonly StateDefinition[];\n    list?: false | null;\n  }\n    ? K\n    : never;\n}[keyof StateRelations<S>];\n\nexport type StateRelationStates<\n  S extends StateDefinition,\n  K extends StateAllRelations<S>,\n> = StateRelations<S>[K] extends { states: readonly StateDefinition[] }\n  ? StateRelations<S>[K]['states'][number]\n  : never;\n","import { Scalar } from '@neuledge/scalars';\nimport { StateDefinition } from './state';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type StateDefintionScalar<V = any> = {\n  type: StateDefinitionScalarType<NonNullable<V>>;\n  index: number;\n  nullable?: boolean;\n};\n\nexport type StateDefinitionScalarType<V> =\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Scalar<V, any, any> | readonly StateDefinition<string, V>[];\n\nexport const isStateDefinitionScalarTypeScalar = <V>(\n  type: StateDefinitionScalarType<V>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): type is Scalar<V, any, any> => !Array.isArray(type);\n\nexport const isStateDefinitionScalarTypeStates = <V>(\n  type: StateDefinitionScalarType<V>,\n): type is readonly StateDefinition<string, V>[] => Array.isArray(type);\n","export type SortDefinition<T> = readonly SortedField<keyof T & string>[];\n\nexport type SortDefinitionKey<K extends SortedField<string>> =\n  K extends SortedField<infer R> ? R : never;\n\ntype SortedField<K extends string> = `${'+' | '-'}${K}`;\n\nexport const parseSortedField = <K extends string>(\n  field: SortedField<K>,\n): [name: K, sort: 'asc' | 'desc'] => [\n  field.slice(1) as K,\n  field[0] === '+' ? 'asc' : 'desc',\n];\n\nexport const fromSortedField = <K extends string>(\n  field: SortedField<K>,\n): string => field.slice(1);\n","import { Defer, Deferred } from '../defer';\nimport {\n  StateDefinitionId as StateDefinitionId,\n  StateDefinitionIndex,\n} from './indexes';\nimport { StateDefinitionRelation } from './relations';\nimport { StateDefintionScalar } from './scalar';\nimport { SortDefinitionKey } from './sort';\nimport { StateDefinitionUnique, StateDefinitionWhereRecord } from './find';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface StateDefinition<N extends string = string, T = any> {\n  $name: N;\n  $id: StateDefinitionId<T>;\n  $scalars: Defer<{ [K in keyof T]: StateDefintionScalar<T[K]> }>;\n  $filter: StateDefinitionWhereRecord<T>;\n  $where: StateDefinitionWhereRecord<T>;\n  $unique: StateDefinitionUnique<T>;\n  $relations?: Defer<Record<string, StateDefinitionRelation>>;\n  $transforms?: Defer<readonly StateDefinition[]>;\n  $indexes?: Record<string, StateDefinitionIndex<T>>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any): T;\n}\n\nexport type StateType<S extends StateDefinition> = S extends new (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any\n) => infer R\n  ? R\n  : never;\n\nexport type StateName<S extends StateDefinition = StateDefinition> = S['$name'];\n// export type StateScalars<S extends State> = Deferred<S['$scalars']>;\nexport type StateId<S extends StateDefinition> = Pick<\n  StateType<S>,\n  SortDefinitionKey<S['$id']['fields'][number]>\n>;\nexport type StateFilter<S extends StateDefinition> = S['$filter'];\nexport type StateWhere<S extends StateDefinition> = S['$where'];\nexport type StateUnique<S extends StateDefinition> = S['$unique'];\nexport type StateIndexes<S extends StateDefinition> = NonNullable<\n  S['$indexes']\n>;\nexport type StateRelations<S extends StateDefinition> = Deferred<\n  S['$relations'],\n  Record<never, never>\n>;\n\n// export type StateDefinitionStates<S extends State> = Deferred<S['$transforms']>;\n","export * from './state-definition';\nexport * from './term';\n","import { StateDefinitionWhereTerm } from './term';\n\nexport type StateDefinitionWhere<Record extends StateDefinitionWhereRecord> =\n  | Record\n  | StateDefinitionWhereOr<Record>;\n\ninterface StateDefinitionWhereOr<Record> {\n  $or: Record[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type StateDefinitionWhereRecord<T = any> = {\n  [K in keyof T]?: StateDefinitionWhereTerm<NonNullable<T[K]>> | null;\n};\n\nexport type StateDefinitionUnique<T> = { [K in keyof T]?: T[K] };\n","import { StateDefinition, StateId } from '../state';\nimport { ComparableFilters } from './comparable';\nimport { EqualableFilters } from './equalable';\nimport { SequenceFilters } from './sequence';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type StateDefinitionWhereTerm<V = any> =\n  | EqualableFilters<V | null>\n  | ComparableFilters<V>\n  | SequenceFilters<V>;\n\nexport type StateDefinitionWhereId<V extends object> = EqualableFilters<V>;\n\nexport type StateDefinitionWhereNullableId<V extends object> =\n  EqualableFilters<V | null>;\n\nexport type StateDefinitionWhereState<S extends StateDefinition> =\n  EqualableFilters<StateId<S>>;\n\nexport type StateDefinitionWhereNullableState<S extends StateDefinition> =\n  EqualableFilters<StateId<S> | null>;\n\nexport type StateDefinitionWhereListState<S extends StateDefinition> =\n  EqualableFilters<StateId<S>[]>;\n\nexport type StateDefinitionWhereNullableListState<S extends StateDefinition> =\n  EqualableFilters<StateId<S>[] | null>;\n\nexport type StateDefinitionWhereUnknown<V extends NonNullable<unknown>> =\n  | EqualableFilters<V>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereNullableUnknown<V extends object> =\n  | EqualableFilters<V | null>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereNumber<V extends number> =\n  | EqualableFilters<V>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereNullableNumber<V extends number> =\n  | EqualableFilters<V | null>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereEnum<V extends string> =\n  | EqualableFilters<V>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereNullableEnum<V extends string> =\n  | EqualableFilters<V | null>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereString<V extends string> =\n  | EqualableFilters<V>\n  | ComparableFilters<V>\n  | SequenceFilters<V>;\n\nexport type StateDefinitionWhereNullableString<V extends string> =\n  | EqualableFilters<V | null>\n  | ComparableFilters<V>\n  | SequenceFilters<V>;\n\nexport type StateDefinitionWhereBoolean<V extends boolean> =\n  EqualableFilters<V>;\n\nexport type StateDefinitionWhereNullableBoolean<V extends boolean> =\n  EqualableFilters<V | null>;\n\nexport type StateDefinitionWhereDateTime<V extends Date> =\n  | EqualableFilters<V>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereNullableDateTime<V extends Date> =\n  | EqualableFilters<V | null>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereBuffer<V extends Buffer> =\n  | EqualableFilters<V>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereNullableBuffer<V extends Buffer> =\n  | EqualableFilters<V | null>\n  | ComparableFilters<V>;\n\nexport type StateDefinitionWhereArray<V> =\n  | EqualableFilters<V[]>\n  | ComparableFilters<V[]>;\n\nexport type StateDefinitionWhereNullableArray<V> =\n  | EqualableFilters<V[] | null>\n  | ComparableFilters<V[]>;\n","export type Defer<T> = (() => T) | T;\nexport type Deferred<T, N = never> = T extends Defer<infer R> ? R : N;\n\nexport const resolveDefer: {\n  <T>(defer: Defer<T>): T;\n  <T>(defer: Defer<T> | undefined | null, def: T): T;\n} = <T>(defer: Defer<T> | undefined | null, def?: T): T => {\n  if (typeof defer === 'function') {\n    return (defer as () => T)();\n  }\n\n  return defer ?? (def as T);\n};\n","export * from './alter';\nexport * from './init';\nexport * from './find';\nexport * from './raw';\nexport * from './raw';\nexport * from './raw';\nexport * from './query';\nexport * from './class';\nexport * from './raw';\nexport * from './raw';\nexport * from './raw';\nexport * from './raw';\nexport * from './raw';\nexport * from './raw';\n","export * from './first';\nexport * from './first-or-throw';\nexport * from './many';\nexport * from './unique';\nexport * from './unique-or-throw';\n","import { StateDefinition, StateDefinitionAlterMethods } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  MatchQuery,\n  MatchQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  ReturnQuery,\n  ReturnQueryOptions,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SingleArgsQueryOptions,\n  WhereQuery,\n  WhereQueryOptions,\n} from '../raw';\n\nexport interface AlterFirstQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends ReturnQuery<'AlterFirstAndReturn', I, O>,\n    SelectQuery<'AlterFirstAndReturn', I, O>,\n    WhereQuery<I>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<void> {}\n\n// TODO enable populate support for alterFirst query\n\nexport interface AlterFirstAndReturnQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends SelectQuery<'AlterFirstAndReturn', I, O, R>,\n    // PopulateQuery<'AlterFirstAndReturn', I, O, P, R>,\n    WhereQuery<I>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<QueryEntity<O, P, R> | null> {}\n\nexport interface AlterFirstQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'AlterFirst', I>,\n    SingleArgsQueryOptions<I, StateDefinitionAlterMethods<I>>,\n    ReturnQueryOptions,\n    SelectQueryOptions<O>,\n    // PopulateQueryOptions<O>,\n    WhereQueryOptions<I>,\n    FilterQueryOptions<I>,\n    MatchQueryOptions<I>,\n    ExecQueryOptions<'AlterFirst', I, O> {}\n","import { StateDefinition, StateDefinitionAlterMethods } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  MatchQuery,\n  MatchQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  ReturnQuery,\n  ReturnQueryOptions,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SingleArgsQueryOptions,\n  WhereQuery,\n  WhereQueryOptions,\n} from '../raw';\n\nexport interface AlterFirstOrThrowQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends ReturnQuery<'AlterFirstAndReturnOrThrow', I, O>,\n    SelectQuery<'AlterFirstAndReturnOrThrow', I, O>,\n    WhereQuery<I>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<void> {}\n\n// TODO enable populate support for alterFirstOrThrow query\n\nexport interface AlterFirstAndReturnOrThrowQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends SelectQuery<'AlterFirstAndReturnOrThrow', I, O, R>,\n    // PopulateQuery<'AlterFirstAndReturnOrThrow', I, O, P, R>,\n    WhereQuery<I>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<QueryEntity<O, P, R>> {}\n\nexport interface AlterFirstOrThrowQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'AlterFirstOrThrow', I>,\n    SingleArgsQueryOptions<I, StateDefinitionAlterMethods<I>>,\n    ReturnQueryOptions,\n    SelectQueryOptions<O>,\n    // PopulateQueryOptions<O>,\n    WhereQueryOptions<I>,\n    FilterQueryOptions<I>,\n    MatchQueryOptions<I>,\n    ExecQueryOptions<'AlterFirstOrThrow', I, O> {}\n","import { StateDefinition, StateDefinitionAlterMethods } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  LimitQuery,\n  LimitQueryOptions,\n  MatchQuery,\n  MatchQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  ReturnQuery,\n  ReturnQueryOptions,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SingleArgsQueryOptions,\n  WhereQuery,\n  WhereQueryOptions,\n} from '../raw';\n\nexport interface AlterManyQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends ReturnQuery<'AlterManyAndReturn', I, O>,\n    SelectQuery<'AlterManyAndReturn', I, O>,\n    WhereQuery<I>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    LimitQuery,\n    ExecQuery<void> {}\n\n// TODO enable populate support for alterMany query\n\nexport interface AlterManyAndReturnQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends SelectQuery<'AlterManyAndReturn', I, O, R>,\n    // PopulateQuery<'AlterManyAndReturn', I, O, P, R>,\n    WhereQuery<I>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    LimitQuery,\n    ExecQuery<QueryEntity<O, P, R>[]> {}\n\nexport interface AlterManyQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'AlterMany', I>,\n    SingleArgsQueryOptions<I, StateDefinitionAlterMethods<I>>,\n    ReturnQueryOptions,\n    SelectQueryOptions<O>,\n    // PopulateQueryOptions<O>,\n    WhereQueryOptions<I>,\n    FilterQueryOptions<I>,\n    MatchQueryOptions<I>,\n    LimitQueryOptions,\n    ExecQueryOptions<'AlterMany', I, O> {}\n","import { StateDefinition, StateDefinitionAlterMethods } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  MatchQuery,\n  MatchQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  ReturnQuery,\n  ReturnQueryOptions,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SingleArgsQueryOptions,\n  UniqueQuery,\n  UniqueQueryOptions,\n} from '../raw';\n\nexport interface AlterUniqueQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends ReturnQuery<'AlterUniqueAndReturn', I, O>,\n    SelectQuery<'AlterUniqueAndReturn', I, O>,\n    UniqueQuery<'AlterUniqueWhere', I, O>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<void> {}\n\n// TODO enable populate support for alterUnique query\n\nexport interface AlterUniqueAndReturnQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends SelectQuery<'AlterUniqueAndReturn', I, O, R>,\n    // PopulateQuery<'AlterUniqueAndReturn', I, O, P, R>,\n    UniqueQuery<'AlterUniqueWhereAndReturn', I, O, P, R>,\n    FilterQuery<I>,\n    MatchQuery<I> {}\n\nexport interface AlterUniqueWhereQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends ReturnQuery<'AlterUniqueWhereAndReturn', I, O>,\n    SelectQuery<'AlterUniqueWhereAndReturn', I, O, R>,\n    UniqueQuery<'AlterUniqueWhere', I, O, P, R>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<void> {}\n\nexport interface AlterUniqueWhereAndReturnQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends SelectQuery<'AlterUniqueWhereAndReturn', I, O, R>,\n    // PopulateQuery<'AlterUniqueWhereAndReturn', I, O, P, R>,\n    UniqueQuery<'AlterUniqueWhereAndReturn', I, O, P, R>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<QueryEntity<O, P, R> | null> {}\n\nexport interface AlterUniqueQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'AlterUnique', I>,\n    SingleArgsQueryOptions<I, StateDefinitionAlterMethods<I>>,\n    ReturnQueryOptions,\n    SelectQueryOptions<O>,\n    // PopulateQueryOptions<O>,\n    UniqueQueryOptions<I>,\n    FilterQueryOptions<I>,\n    MatchQueryOptions<I>,\n    ExecQueryOptions<'AlterUnique', I, O> {}\n","import { StateDefinition, StateDefinitionAlterMethods } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  MatchQuery,\n  MatchQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  ReturnQuery,\n  ReturnQueryOptions,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SingleArgsQueryOptions,\n  UniqueQuery,\n  UniqueQueryOptions,\n} from '../raw';\n\nexport interface AlterUniqueOrThrowQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends ReturnQuery<'AlterUniqueAndReturnOrThrow', I, O>,\n    SelectQuery<'AlterUniqueAndReturnOrThrow', I, O>,\n    UniqueQuery<'AlterUniqueWhereOrThrow', I, O>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<void> {}\n\n// TODO enable populate support for alterUniqueOrThrow query\n\nexport interface AlterUniqueAndReturnOrThrowQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends SelectQuery<'AlterUniqueAndReturnOrThrow', I, O, R>,\n    // PopulateQuery<'AlterUniqueAndReturnOrThrow', I, O, P, R>,\n    UniqueQuery<'AlterUniqueWhereAndReturnOrThrow', I, O, P, R>,\n    FilterQuery<I>,\n    MatchQuery<I> {}\n\nexport interface AlterUniqueWhereOrThrowQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends ReturnQuery<'AlterUniqueWhereAndReturnOrThrow', I, O>,\n    SelectQuery<'AlterUniqueWhereAndReturnOrThrow', I, O, R>,\n    UniqueQuery<'AlterUniqueWhereOrThrow', I, O, P, R>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<void> {}\n\nexport interface AlterUniqueWhereAndReturnOrThrowQuery<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> extends SelectQuery<'AlterUniqueWhereAndReturnOrThrow', I, O, R>,\n    // PopulateQuery<'AlterUniqueWhereAndReturnOrThrow', I, O, P, R>,\n    UniqueQuery<'AlterUniqueWhereAndReturnOrThrow', I, O, P, R>,\n    FilterQuery<I>,\n    MatchQuery<I>,\n    ExecQuery<QueryEntity<O, P, R>> {}\n\nexport interface AlterUniqueOrThrowQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'AlterUniqueOrThrow', I>,\n    SingleArgsQueryOptions<I, StateDefinitionAlterMethods<I>>,\n    ReturnQueryOptions,\n    SelectQueryOptions<O>,\n    // PopulateQueryOptions<O>,\n    UniqueQueryOptions<I>,\n    FilterQueryOptions<I>,\n    MatchQueryOptions<I>,\n    ExecQueryOptions<'AlterUniqueOrThrow', I, O> {}\n","export * from './many';\nexport * from './one';\n","import { StateDefinition, StateDefinitionInitMethods } from '@/definitions';\nimport { EntityList } from '@/list';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  MultiArgsQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n} from '../raw';\n\nexport interface InitManyQuery<S extends StateDefinition>\n  extends SelectQuery<'InitManyAndReturn', S, S>,\n    ExecQuery<void> {}\n\n// TODO enable populate support for initMany query\n\nexport interface InitManyAndReturnQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = true,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'InitManyAndReturn', S, S, R>,\n    // PopulateQuery<'InitManyAndReturn', S, S, P, R>,\n    ExecQuery<EntityList<QueryEntity<S, P, R>>> {}\n\nexport interface InitManyQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'InitMany', I>,\n    MultiArgsQueryOptions<I, StateDefinitionInitMethods<I>>,\n    SelectQueryOptions<O>,\n    // PopulateQueryOptions<O>,\n    ExecQueryOptions<'InitMany', I, O> {\n  states: [I];\n}\n","import { StateDefinition, StateDefinitionInitMethods } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SingleArgsQueryOptions,\n} from '../raw';\n\nexport interface InitOneQuery<S extends StateDefinition>\n  extends SelectQuery<'InitOneAndReturn', S, S>,\n    ExecQuery<void> {}\n\n// TODO enable populate support for initOne query\n\nexport interface InitOneAndReturnQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'InitOneAndReturn', S, S, R>,\n    // PopulateQuery<'InitOneAndReturn', S, S, P, R>,\n    ExecQuery<QueryEntity<S, P, R>> {}\n\nexport interface InitOneQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'InitOne', I>,\n    SingleArgsQueryOptions<I, StateDefinitionInitMethods<I>>,\n    SelectQueryOptions<O>,\n    // PopulateQueryOptions<O>,\n    ExecQueryOptions<'InitOne', I, O> {\n  states: [I];\n}\n","export * from './first';\nexport * from './first-or-throw';\nexport * from './many';\nexport * from './unique';\nexport * from './unique-or-throw';\n","import { StateDefinition } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  ExpandQuery,\n  ExpandQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  OffsetQuery,\n  OffsetQueryOptions,\n  PopulateQuery,\n  PopulateQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SortQuery,\n  SortQueryOptions,\n  WhereQuery,\n  WhereQueryOptions,\n} from '../raw';\n\nexport interface FindFirstQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'FindFirst', S, S, R>,\n    ExpandQuery<'FindFirst', S, S, P, R>,\n    PopulateQuery<'FindFirst', S, S, P, R>,\n    WhereQuery<S>,\n    FilterQuery<S>,\n    SortQuery<S>,\n    OffsetQuery,\n    ExecQuery<QueryEntity<S, P, R> | null> {}\n\nexport interface FindFirstQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'FindFirst', I>,\n    SelectQueryOptions<O>,\n    ExpandQueryOptions<O>,\n    PopulateQueryOptions<O>,\n    WhereQueryOptions<I>,\n    FilterQueryOptions<I>,\n    SortQueryOptions<O>,\n    OffsetQueryOptions,\n    ExecQueryOptions<'FindFirst', I, O> {}\n","import { StateDefinition } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  ExpandQuery,\n  ExpandQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  OffsetQuery,\n  OffsetQueryOptions,\n  PopulateQuery,\n  PopulateQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SortQuery,\n  SortQueryOptions,\n  WhereQuery,\n  WhereQueryOptions,\n} from '../raw';\n\nexport interface FindFirstOrThrowQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'FindFirstOrThrow', S, S, R>,\n    ExpandQuery<'FindFirstOrThrow', S, S, P, R>,\n    PopulateQuery<'FindFirstOrThrow', S, S, P, R>,\n    WhereQuery<S>,\n    FilterQuery<S>,\n    SortQuery<S>,\n    OffsetQuery,\n    ExecQuery<QueryEntity<S, P, R>> {}\n\nexport interface FindFirstOrThrowQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'FindFirstOrThrow', I>,\n    SelectQueryOptions<O>,\n    ExpandQueryOptions<O>,\n    PopulateQueryOptions<O>,\n    WhereQueryOptions<I>,\n    FilterQueryOptions<I>,\n    SortQueryOptions<O>,\n    OffsetQueryOptions,\n    ExecQueryOptions<'FindFirstOrThrow', I, O> {}\n","import { StateDefinition } from '@/definitions';\nimport { EntityList } from '@/list';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  ExpandQuery,\n  ExpandQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  LimitQuery,\n  LimitQueryOptions,\n  OffsetQuery,\n  OffsetQueryOptions,\n  PopulateQuery,\n  PopulateQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  SortQuery,\n  SortQueryOptions,\n  WhereQuery,\n  WhereQueryOptions,\n} from '../raw';\n\nexport interface FindManyQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'FindMany', S, S, R>,\n    ExpandQuery<'FindMany', S, S, P, R>,\n    PopulateQuery<'FindMany', S, S, P, R>,\n    WhereQuery<S>,\n    FilterQuery<S>,\n    SortQuery<S>,\n    LimitQuery,\n    OffsetQuery,\n    ExecQuery<EntityList<QueryEntity<S, P, R>>> {}\n\nexport interface FindManyQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'FindMany', I>,\n    SelectQueryOptions<O>,\n    ExpandQueryOptions<O>,\n    PopulateQueryOptions<O>,\n    WhereQueryOptions<I>,\n    FilterQueryOptions<I>,\n    SortQueryOptions<O>,\n    LimitQueryOptions,\n    OffsetQueryOptions,\n    ExecQueryOptions<'FindMany', I, O> {}\n","import { StateDefinition } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  ExpandQuery,\n  ExpandQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  PopulateQuery,\n  PopulateQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  UniqueQuery,\n  UniqueQueryOptions,\n} from '../raw';\n\nexport interface FindUniqueQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'FindUnique', S, S, R>,\n    ExpandQuery<'FindUnique', S, S, P, R>,\n    PopulateQuery<'FindUnique', S, S, P, R>,\n    UniqueQuery<'FindUniqueWhere', S, S, P, R>,\n    FilterQuery<S> {}\n\nexport interface FindUniqueWhereQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'FindUniqueWhere', S, S, R>,\n    ExpandQuery<'FindUniqueWhere', S, S, P, R>,\n    PopulateQuery<'FindUniqueWhere', S, S, P, R>,\n    UniqueQuery<'FindUniqueWhere', S, S, P, R>,\n    FilterQuery<S>,\n    ExecQuery<QueryEntity<S, P, R> | null> {}\n\nexport interface FindUniqueQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'FindUnique', I>,\n    SelectQueryOptions<O>,\n    ExpandQueryOptions<O>,\n    PopulateQueryOptions<O>,\n    UniqueQueryOptions<I>,\n    FilterQueryOptions<I>,\n    ExecQueryOptions<'FindUnique', I, O> {}\n","import { StateDefinition } from '@/definitions';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  ExpandQuery,\n  ExpandQueryOptions,\n  FilterQuery,\n  FilterQueryOptions,\n  PopulateQuery,\n  PopulateQueryOptions,\n  QueryEntity,\n  QueryProjection,\n  RootQueryOptions,\n  SelectQuery,\n  SelectQueryOptions,\n  UniqueQuery,\n  UniqueQueryOptions,\n} from '../raw';\n\nexport interface FindUniqueOrThrowQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'FindUniqueOrThrow', S, S, R>,\n    ExpandQuery<'FindUniqueOrThrow', S, S, P, R>,\n    PopulateQuery<'FindUniqueOrThrow', S, S, P, R>,\n    UniqueQuery<'FindUniqueWhereOrThrow', S, S, P, R>,\n    FilterQuery<S> {}\n\nexport interface FindUniqueWhereOrThrowQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> extends SelectQuery<'FindUniqueWhereOrThrow', S, S, R>,\n    FilterQuery<S>,\n    ExpandQuery<'FindUniqueWhereOrThrow', S, S, P, R>,\n    PopulateQuery<'FindUniqueWhereOrThrow', S, S, P, R>,\n    UniqueQuery<'FindUniqueWhereOrThrow', S, S, P, R>,\n    ExecQuery<QueryEntity<S, P, R>> {}\n\nexport interface FindUniqueOrThrowQueryOptions<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> extends RootQueryOptions<'FindUniqueOrThrow', I>,\n    SelectQueryOptions<O>,\n    ExpandQueryOptions<O>,\n    PopulateQueryOptions<O>,\n    UniqueQueryOptions<I>,\n    FilterQueryOptions<I>,\n    ExecQueryOptions<'FindUniqueOrThrow', I, O> {}\n","export * from './exec';\nexport * from './limit';\nexport * from './filter';\nexport * from './match';\nexport * from './method';\nexport * from './offset';\nexport * from './populate';\nexport * from './return';\nexport * from './select';\nexport * from './sort';\nexport * from './type';\nexport * from './unique';\nexport * from './where';\n","import { StateDefinition } from '@/definitions';\nimport { QueryOptions, QueryType } from '../query';\n\nexport interface ExecQuery<T> {\n  /**\n   * Execute query and return result as promise.\n   */\n  exec(): Promise<T>;\n\n  /**\n   *  A shorthand for `exec()`, making the query thenable by appling `await` or\n   * `.then()` directly to the query without calling `exec()` first.\n   */\n  then: Promise<T>['then'];\n}\n\nexport interface ExecQueryOptions<\n  T extends QueryType,\n  I extends StateDefinition,\n  O extends StateDefinition,\n  R = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n> {\n  exec(options: QueryOptions<T, I, O>): Promise<R>;\n}\n","export interface LimitQuery {\n  /**\n   * Limit the number of returned entities.\n   */\n  limit(limit: number | null): this;\n}\n\nexport interface LimitQueryOptions {\n  limit?: number | null;\n}\n","import {\n  StateDefinition,\n  StateDefinitionWhere,\n  StateFilter,\n  StateName,\n} from '@/definitions';\nimport { AllKeys } from './utils';\n\n// This query is very similar to the `UniqueQuery`, if you make changes here,\n// you probably want to make the same changes there.\n\nexport interface FilterQuery<S extends StateDefinition> {\n  /**\n   * Filter the returned entities by a where clause without using the indexes.\n   * This is useful when you want to filter by a field that is not indexed.\n   * Please note that this will be much slower (and sometimes costly) than using\n   * the index.\n   */\n  filter(filter: Filter<S> | null): this;\n}\n\nexport interface FilterQueryOptions<S extends StateDefinition> {\n  filter?: Filter<S> | null;\n}\n\nexport type Filter<S extends StateDefinition> = StateDefinitionWhere<\n  NonCommonFilterKeys<S> extends never\n    ? StateFilter<S>\n    : StateFilter<S> & {\n        [K in NonCommonFilterKeys<S>]?: null;\n      }\n>;\n\n// Forbidden all non-common keys between the given states.\n// Effectively doing an AND operator between all state values.\n//\n// For example, assume we have 2 states:\n//   A. `{ id: number } | { category: number }`\n//   B. `{ id: number }`\n//\n// We want to have only `{ id: number }` as a result so we run the following\n// logic:\n//   1. For each state:\n//   1.1. Get all state keys (`id|category` and `id`)\n//   1.2. Deduct it from states keys (`never` and `category`)\n//   2. Combine result with an OR operator (`category`)\n//   3. Forbidden the result from all keys (`id`)\n\ntype NonCommonFilterKeys<S extends StateDefinition> = {\n  [K in StateName<S>]: Exclude<\n    AllKeys<StateFilter<S>>,\n    S extends StateDefinition<K> ? AllKeys<StateFilter<S>> : never\n  >;\n}[StateName<S>];\n","export * from './refine';\nexport * from './match';\n","import { StateDefinition } from '@/definitions';\nimport { MatchQuery, MatchQueryOptions } from './match';\nimport { ChildQueryOptions } from '../type';\nimport { FilterQuery, FilterQueryOptions } from '../filter';\n\nexport interface RefineQuery<S extends StateDefinition>\n  extends FilterQuery<S>,\n    MatchQuery<S> {}\n\nexport interface RefineQueryOptions<S extends StateDefinition>\n  extends ChildQueryOptions<'Refine', S>,\n    FilterQueryOptions<S>,\n    MatchQueryOptions<S> {}\n","import {\n  StateAllRelations,\n  StateDefinition,\n  StateRelationStates,\n} from '@/definitions';\nimport { RefineQuery, RefineQueryOptions } from './refine';\n\nexport interface MatchQuery<S extends StateDefinition> {\n  /**\n   * Filter the returned entities by relation.\n   * Return only entities with a related entity that matches the given relation\n   * states.\n   */\n  match<K extends StateAllRelations<S>>(\n    key: K,\n    states: StateRelationStates<S, K>[],\n  ): this;\n\n  /**\n   * Filter the returned entities by relation.\n   * Return only entities with a related entity that matches the given query.\n   */\n  match<K extends StateAllRelations<S>>(\n    key: K,\n    query: MatchQueryParam<StateRelationStates<S, K>>,\n  ): this;\n\n  /**\n   * Filter the returned entities by relation.\n   * Return only entities with a related entity that matches the given relation\n   * states and query.\n   */\n  match<K extends StateAllRelations<S>, RS extends StateRelationStates<S, K>>(\n    key: K,\n    states: RS[],\n    query: MatchQueryParam<RS>,\n  ): this;\n}\n\nexport interface MatchQueryOptions<S extends StateDefinition> {\n  match?: {\n    [K in StateAllRelations<S>]?: RefineQueryOptions<StateRelationStates<S, K>>;\n  };\n}\n\nexport type MatchQueryParam<S extends StateDefinition> = (\n  query: RefineQuery<S>,\n) => RefineQuery<S>;\n","import {\n  StateDefinition,\n  StateDefinitionMutationArguments,\n  StateDefinitionMethods,\n} from '@/definitions';\n\nexport interface MethodQueryOptions<M extends string | number | symbol> {\n  method: M;\n}\n\nexport interface SingleArgsQueryOptions<\n  I extends StateDefinition,\n  M extends StateDefinitionMethods<I>,\n> extends MethodQueryOptions<M> {\n  args: [StateDefinitionMutationArguments<I, M>];\n}\n\nexport interface MultiArgsQueryOptions<\n  I extends StateDefinition,\n  M extends StateDefinitionMethods<I>,\n> extends MethodQueryOptions<M> {\n  args: StateDefinitionMutationArguments<I, M>[];\n}\n","import { EntityListOffset } from '@/list';\n\nexport interface OffsetQuery {\n  /**\n   * Skip previous entities and start returning entities from the given offset.\n   * Use the `nextOffset` property of the previously returned entity list to get\n   * the next offset.\n   */\n  offset(offset: EntityListOffset | null): this;\n}\n\nexport interface OffsetQueryOptions {\n  offset?: EntityListOffset | null;\n}\n","export * from './expand';\nexport * from './populate';\nexport * from './select-many';\nexport * from './select-one';\n","import { Entity } from '@/entity';\nimport {\n  StateDefinition,\n  StateOneRelations,\n  StateRelationStates,\n  StateType,\n} from '@/definitions';\nimport { Query, QueryMode } from '../../query';\nimport { QueryEntity, QueryProjection } from '../select';\nimport { SelectOneQuery, SelectOneQueryOptions } from './select-one';\n\nexport interface ExpandQuery<\n  M extends QueryMode,\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R = NonNullable<unknown>,\n> {\n  /**\n   * Expand and return a relation of a single entity.\n   * If the relation is optional, the relation will be returned as an entity or\n   * null.\n   */\n  expand<K extends StateOneRelations<O>>(\n    key: K,\n  ): Query<M, I, O, P, R & ExpandQueryResult<O, K>>;\n\n  /**\n   * Expand and return a relation of a single entity.\n   * Filter and return parent entities that have a relation to the given related\n   * states.\n   */\n  expand<K extends StateOneRelations<O>, QS extends StateRelationStates<O, K>>(\n    key: K,\n    states: QS[],\n  ): Query<M, I, O, P, R & { [k in K]: Entity<QS> }>;\n\n  /**\n   * Query and expand a relation of a single entity.\n   * Any filter applied to the query will be applied to the parent entity as\n   * well and the parent entity will be returned if the relation matches the\n   * query. If no `.select()` is applied to the query, the relation will not be\n   * returned and only filter the parent entity.\n   */\n  expand<\n    K extends StateOneRelations<O>,\n    QP extends QueryProjection<StateRelationStates<O, K>>,\n    QR,\n  >(\n    key: K,\n    query: ExpandQueryParam<StateRelationStates<O, K>, QP, QR>,\n  ): Query<\n    M,\n    I,\n    O,\n    P,\n    QP extends null\n      ? R\n      : R &\n          ExpandQueryResult<\n            O,\n            K,\n            QueryEntity<StateRelationStates<O, K>, QP, QR>\n          >\n  >;\n\n  /**\n   * Query and expand a relation of a single entity.\n   * Filter and return parent entities that have a relation to the given related\n   * states. Any filter applied to the query will be applied to the parent\n   * entity as well and the parent entity will be returned if the relation\n   * matches the query. If no `.select()` is applied to the query, the relation\n   * will not be returned and only filter the parent entity.\n   */\n  expand<\n    K extends StateOneRelations<O>,\n    QS extends StateRelationStates<O, K>,\n    QP extends QueryProjection<QS>,\n    QR,\n  >(\n    key: K,\n    states: QS[],\n    query: ExpandQueryParam<QS, QP, QR>,\n  ): Query<\n    M,\n    I,\n    O,\n    P,\n    QP extends null ? R : R & { [k in K]: QueryEntity<QS, QP, QR> }\n  >;\n}\n\nexport interface ExpandQueryOptions<S extends StateDefinition> {\n  expand?: {\n    [K in StateOneRelations<S>]?: SelectOneQueryOptions<\n      StateRelationStates<S, K>\n    >;\n  };\n}\n\nexport type ExpandQueryParam<\n  S extends StateDefinition,\n  P extends QueryProjection<S> = null,\n  R = NonNullable<unknown>,\n> = (\n  query: SelectOneQuery<S, null, NonNullable<unknown>>,\n) => SelectOneQuery<S, P, R>;\n\nexport type ExpandQueryResult<\n  S extends StateDefinition,\n  K extends StateOneRelations<S>,\n  T extends Entity<StateDefinition> = Entity<StateRelationStates<S, K>>,\n> = undefined extends StateType<S>[K]\n  ? { [k in K]?: T | null }\n  : { [k in K]: T };\n","import { StateDefinition } from '@/definitions';\nimport { QueryMode } from '../../query';\nimport { QueryProjection } from '../select';\nimport { PopulateOneQuery, PopulateOneQueryOptions } from './one';\n\n// TODO enable populate many support\n\nexport type PopulateQuery<\n  M extends QueryMode,\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O> = true,\n  R = NonNullable<unknown>,\n> = PopulateOneQuery<M, I, O, P, R>;\n// , PopulateManyQuery<M, I, O, P, R> {}\n\nexport type PopulateQueryOptions<S extends StateDefinition> =\n  PopulateOneQueryOptions<S>;\n// ,  PopulateManyQueryOptions<S> {}\n\nexport type { PopulateOneQueryParam } from './one';\nexport type { PopulateManyQueryParam } from './many';\n","import { StateDefinition } from '@/definitions';\nimport { LimitQuery, LimitQueryOptions } from '../limit';\nimport { OffsetQuery, OffsetQueryOptions } from '../offset';\nimport { SortQuery, SortQueryOptions } from '../sort';\nimport { ChildQueryOptions } from '../type';\nimport { QueryProjection, SelectQuery, SelectQueryOptions } from '../select';\nimport { PopulateQuery, PopulateQueryOptions } from './populate';\nimport { ExpandQuery, ExpandQueryOptions } from './expand';\nimport { FilterQuery, FilterQueryOptions } from '../filter';\n\nexport interface SelectManyQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S>,\n  R,\n> extends SelectQuery<'SelectMany', S, S, R>,\n    ExpandQuery<'SelectMany', S, S, P, R>,\n    PopulateQuery<'SelectMany', S, S, P, R>,\n    FilterQuery<S>,\n    SortQuery<S>,\n    LimitQuery,\n    OffsetQuery {}\n\nexport interface SelectManyQueryOptions<S extends StateDefinition>\n  extends ChildQueryOptions<'SelectMany', S>,\n    SelectQueryOptions<S>,\n    ExpandQueryOptions<S>,\n    PopulateQueryOptions<S>,\n    FilterQueryOptions<S>,\n    SortQueryOptions<S>,\n    LimitQueryOptions,\n    OffsetQueryOptions {}\n","import { StateDefinition } from '@/definitions';\nimport { ChildQueryOptions } from '../type';\nimport { QueryProjection, SelectQuery, SelectQueryOptions } from '../select';\nimport { PopulateQuery, PopulateQueryOptions } from './populate';\nimport { ExpandQuery, ExpandQueryOptions } from './expand';\nimport { FilterQuery, FilterQueryOptions } from '../filter';\n\nexport interface SelectOneQuery<\n  S extends StateDefinition,\n  P extends QueryProjection<S>,\n  R,\n> extends SelectQuery<'SelectOne', S, S, R>,\n    ExpandQuery<'SelectOne', S, S, P, R>,\n    PopulateQuery<'SelectOne', S, S, P, R>,\n    FilterQuery<S> {}\n\nexport interface SelectOneQueryOptions<S extends StateDefinition>\n  extends ChildQueryOptions<'SelectOne', S>,\n    SelectQueryOptions<S>,\n    ExpandQueryOptions<S>,\n    PopulateQueryOptions<S>,\n    FilterQueryOptions<S> {}\n","import { StateDefinition } from '@/definitions';\nimport { Query, QueryMode } from '../query';\n\nexport interface ReturnQuery<\n  M extends QueryMode,\n  I extends StateDefinition,\n  O extends StateDefinition,\n> {\n  /**\n   * Return the new state of the entity after the update.\n   * This is the default behavior if no return option is specified.\n   */\n  return(returns?: 'new'): Query<M, I, O, true, null>;\n\n  /**\n   * Return the old state of the entity before the update.\n   */\n  return(returns: 'old'): Query<M, I, I, true, null>;\n}\n\nexport interface ReturnQueryOptions {\n  returns: Return;\n}\n\nexport type Return = 'old' | 'new';\n","import { StateDefinition, StateType } from '@/definitions';\nimport { Entity, ProjectedEntity } from '@/entity';\nimport { Query, QueryMode } from '../query';\nimport { Merge, Subset } from './utils';\n\nexport interface SelectQuery<\n  M extends QueryMode,\n  I extends StateDefinition,\n  O extends StateDefinition,\n  R = NonNullable<unknown>,\n> {\n  /**\n   * Select and return all properties of the entity.\n   * The return type will be the entity itself.\n   */\n  select(select?: true): Query<M, I, O, true, R>;\n\n  /**\n   * Select and return a subset of the entity's properties.\n   * The return type will be a projected entity.\n   */\n  select<P extends Select<O>>(select: SelectParam<O, P>): Query<M, I, O, P, R>;\n}\n\nexport interface SelectQueryOptions<\n  S extends StateDefinition,\n  P extends Select<S> = Select<S>,\n> {\n  select?: P | true | null;\n}\n\nexport type Select<S extends StateDefinition> = {\n  [K in keyof Merge<StateType<S>>]?: boolean;\n};\n\nexport type SelectParam<\n  S extends StateDefinition,\n  P extends Select<S>,\n> = Subset<P, Select<S>>;\n\nexport type QueryProjection<S extends StateDefinition> =\n  | Select<S>\n  | true\n  | null;\n\nexport type QueryEntity<\n  S extends StateDefinition,\n  P extends QueryProjection<S>,\n  R,\n> = (P extends Select<S> ? ProjectedEntity<S, P> : Entity<S>) & R;\n","import { StateDefinition, StateIndexes, StateType } from '@/definitions';\n\nexport interface SortQuery<S extends StateDefinition> {\n  /**\n   * Sort the returned entities by a sort index.\n   * The index name must be prefixed with a '+' or '-' to indicate the sort\n   * direction. For example: `sort('+name')` or `sort('-name')`.\n   * Only the predefined indexes on the states can be used here, use \"*\" to sort\n   * by arbitrary fields.\n   */\n  sort(sort: SortIndex<S> | null): this;\n\n  /**\n   * Sort the returned entities by arbitrary fields.\n   * The field name must be prefixed with a '+' or '-' to indicate the sort\n   * direction. For example: `sort('*', '+firstName', '-lastVisit')`.\n   */\n  sort(sort: '*', ...fields: SortField<S>[]): this;\n}\n\nexport interface SortQueryOptions<S extends StateDefinition> {\n  sort?: Sort<S> | null;\n}\n\nexport type Sort<S extends StateDefinition> =\n  | SortIndex<S>\n  | readonly SortField<S>[];\n\nexport type SortIndex<S extends StateDefinition> = SortedField<\n  {\n    [K in keyof StateIndexes<S>]: StateIndexes<S>[K]['unique'] extends true\n      ? never\n      : K;\n  }[keyof StateIndexes<S>] &\n    string\n>;\n\nexport type SortField<S extends StateDefinition> = SortedField<\n  keyof StateType<S> & string\n>;\n\ntype SortedField<K extends string> = `${'+' | '-'}${K}`;\n","import { StateDefinition } from '@/definitions';\nimport { QueryType } from '../query';\n\nexport interface RootQueryOptions<\n  T extends QueryType,\n  S extends StateDefinition,\n> {\n  type: T;\n  states: S[];\n}\n\nexport interface ChildQueryOptions<\n  T extends QueryType,\n  S extends StateDefinition,\n> {\n  type: T;\n  states?: S[] | null;\n}\n","import { StateDefinition, StateName, StateUnique } from '@/definitions';\nimport { QueryMode } from '../query';\nimport { Query } from '../query';\nimport { QueryProjection } from './select';\nimport { AllKeys } from './utils';\n\n// This query is very similar to the `WhereQuery`, if you make changes here, you\n// probably want to make the same changes there.\n\nexport interface UniqueQuery<\n  M extends QueryMode,\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O> = null,\n  R = NonNullable<unknown>,\n> {\n  /**\n   * Filter the returned entities by a unique where clause.\n   * The where clause must match exactly one entity. Only uniquely identifiable\n   * indexes can be used in the where clause.\n   */\n  unique(where: Unique<I>): Query<M, I, O, P, R>;\n}\n\nexport interface UniqueQueryOptions<S extends StateDefinition> {\n  unique: Unique<S> | true;\n}\n\nexport type Unique<S extends StateDefinition> = StateUnique<S> & {\n  [K in NonCommonUniqueKeys<S>]?: never;\n};\n\n// Forbidden all non-common keys between the given states.\n// @see NonCommonWhereKeys on \"\"./where.ts\" for more details.\ntype NonCommonUniqueKeys<S extends StateDefinition> = {\n  [K in StateName<S>]: Exclude<\n    AllKeys<StateUnique<S>>,\n    S extends StateDefinition<K> ? AllKeys<StateUnique<S>> : never\n  >;\n}[StateName<S>];\n","import {\n  StateDefinition,\n  StateDefinitionWhere,\n  StateName,\n  StateWhere,\n} from '@/definitions';\nimport { AllKeys } from './utils';\n\n// This query is very similar to the `UniqueQuery`, if you make changes here,\n// you probably want to make the same changes there.\n\nexport interface WhereQuery<S extends StateDefinition> {\n  /**\n   * Filter the returned entities by a where clause using an index.\n   * This is the fastest way to filter entities but you can only filter by\n   * indexed fields. If you want to filter by a field that is not indexed, you\n   * should use the `.filter()` method.\n   */\n  where(where: Where<S> | null): this;\n}\n\nexport interface WhereQueryOptions<S extends StateDefinition> {\n  where?: Where<S> | null;\n}\n\nexport type Where<S extends StateDefinition> = StateDefinitionWhere<\n  NonCommonWhereKeys<S> extends never\n    ? StateWhere<S>\n    : StateWhere<S> & {\n        [K in NonCommonWhereKeys<S>]?: null;\n      }\n>;\n\n// Forbidden all non-common keys between the given states.\n// Effectively doing an AND operator between all state values.\n//\n// For example, assume we have 2 states:\n//   A. `{ id: number } | { category: number }`\n//   B. `{ id: number }`\n//\n// We want to have only `{ id: number }` as a result so we run the following\n// logic:\n//   1. For each state:\n//   1.1. Get all state keys (`id|category` and `id`)\n//   1.2. Deduct it from states keys (`never` and `category`)\n//   2. Combine result with an OR operator (`category`)\n//   3. Forbidden the result from all keys (`id`)\n\ntype NonCommonWhereKeys<S extends StateDefinition> = {\n  [N in StateName<S>]: Exclude<\n    AllKeys<StateWhere<S>>,\n    S extends StateDefinition<N> ? AllKeys<StateWhere<S>> : never\n  >;\n}[StateName<S>];\n","import { StateDefinition } from '@/definitions';\nimport {\n  InitManyAndReturnQuery,\n  InitManyQueryOptions,\n  InitOneAndReturnQuery,\n  InitOneQueryOptions,\n} from './init';\nimport {\n  AlterFirstAndReturnOrThrowQuery,\n  AlterFirstAndReturnQuery,\n  AlterFirstOrThrowQueryOptions,\n  AlterFirstQueryOptions,\n  AlterManyAndReturnQuery,\n  AlterManyQueryOptions,\n  AlterUniqueAndReturnOrThrowQuery,\n  AlterUniqueAndReturnQuery,\n  AlterUniqueOrThrowQueryOptions,\n  AlterUniqueQueryOptions,\n  AlterUniqueWhereAndReturnOrThrowQuery,\n  AlterUniqueWhereAndReturnQuery,\n  AlterUniqueWhereOrThrowQuery,\n  AlterUniqueWhereQuery,\n} from './alter';\nimport {\n  FindFirstOrThrowQuery,\n  FindFirstOrThrowQueryOptions,\n  FindFirstQuery,\n  FindFirstQueryOptions,\n  FindManyQuery,\n  FindManyQueryOptions,\n  FindUniqueOrThrowQuery,\n  FindUniqueOrThrowQueryOptions,\n  FindUniqueQuery,\n  FindUniqueQueryOptions,\n  FindUniqueWhereOrThrowQuery,\n  FindUniqueWhereQuery,\n} from './find';\nimport {\n  RefineQueryOptions,\n  QueryProjection,\n  SelectManyQuery,\n  SelectManyQueryOptions,\n  SelectOneQuery,\n  SelectOneQueryOptions,\n} from './raw';\n\nexport type Query<\n  M extends QueryMode,\n  I extends StateDefinition, // input state\n  O extends StateDefinition, // output state\n  P extends QueryProjection<O>, // projection\n  R, // relations\n> = QueryModes<I, O, P, R>[M];\n\nexport type QueryOptions<\n  T extends QueryType,\n  I extends StateDefinition,\n  O extends StateDefinition,\n> = QueryOptionsTypes<I, O>[T];\n\nexport type QueryType = keyof QueryOptionsTypes<never, never>;\nexport type QueryMode = keyof QueryModes<never, never, never, never>;\n\ninterface QueryModes<\n  I extends StateDefinition,\n  O extends StateDefinition,\n  P extends QueryProjection<O>,\n  R,\n> {\n  // AlterMany: never;\n  AlterManyAndReturn: AlterManyAndReturnQuery<I, O, P, R>;\n  // AlterFirst: never,\n  AlterFirstAndReturn: AlterFirstAndReturnQuery<I, O, P, R>;\n  // AlterFirstOrThrow: never,\n  AlterFirstAndReturnOrThrow: AlterFirstAndReturnOrThrowQuery<I, O, P, R>;\n  // AlterUnique: never;\n  AlterUniqueAndReturn: AlterUniqueAndReturnQuery<I, O, P, R>;\n  AlterUniqueWhere: AlterUniqueWhereQuery<I, O, P, R>;\n  AlterUniqueWhereAndReturn: AlterUniqueWhereAndReturnQuery<I, O, P, R>;\n  // AlterUniqueOrThrow: never;\n  AlterUniqueAndReturnOrThrow: AlterUniqueAndReturnOrThrowQuery<I, O, P, R>;\n  AlterUniqueWhereOrThrow: AlterUniqueWhereOrThrowQuery<I, O, P, R>;\n  AlterUniqueWhereAndReturnOrThrow: AlterUniqueWhereAndReturnOrThrowQuery<\n    I,\n    O,\n    P,\n    R\n  >;\n  FindMany: FindManyQuery<O, P, R>;\n  FindFirst: FindFirstQuery<O, P, R>;\n  FindFirstOrThrow: FindFirstOrThrowQuery<O, P, R>;\n  FindUnique: FindUniqueQuery<O, P, R>;\n  FindUniqueWhere: FindUniqueWhereQuery<O, P, R>;\n  FindUniqueOrThrow: FindUniqueOrThrowQuery<O, P, R>;\n  FindUniqueWhereOrThrow: FindUniqueWhereOrThrowQuery<O, P, R>;\n  // InitMany: never,\n  InitManyAndReturn: InitManyAndReturnQuery<O, P, R>;\n  // InitOne: never;\n  InitOneAndReturn: InitOneAndReturnQuery<O, P, R>;\n  SelectMany: SelectManyQuery<O, P, R>;\n  SelectOne: SelectOneQuery<O, P, R>;\n}\n\ninterface QueryOptionsTypes<\n  I extends StateDefinition,\n  O extends StateDefinition,\n> {\n  AlterFirstOrThrow: AlterFirstOrThrowQueryOptions<I, O>;\n  AlterFirst: AlterFirstQueryOptions<I, O>;\n  AlterMany: AlterManyQueryOptions<I, O>;\n  AlterUniqueOrThrow: AlterUniqueOrThrowQueryOptions<I, O>;\n  AlterUnique: AlterUniqueQueryOptions<I, O>;\n  InitMany: InitManyQueryOptions<I, O>;\n  InitOne: InitOneQueryOptions<I, O>;\n  Refine: RefineQueryOptions<I>;\n  FindFirstOrThrow: FindFirstOrThrowQueryOptions<I, O>;\n  FindFirst: FindFirstQueryOptions<I, O>;\n  FindMany: FindManyQueryOptions<I, O>;\n  FindUniqueOrThrow: FindUniqueOrThrowQueryOptions<I, O>;\n  FindUnique: FindUniqueQueryOptions<I, O>;\n  SelectMany: SelectManyQueryOptions<O>;\n  SelectOne: SelectOneQueryOptions<O>;\n}\n","import {\n  StateAllRelations,\n  StateDefinition,\n  StateOneRelations,\n  StateRelationStates,\n} from '@/definitions';\nimport { EntityListOffset } from '@/list';\nimport {\n  ExecQuery,\n  ExecQueryOptions,\n  ExpandQuery,\n  ExpandQueryOptions,\n  ExpandQueryParam,\n  RefineQueryOptions,\n  LimitQuery,\n  LimitQueryOptions,\n  MatchQuery,\n  MatchQueryParam,\n  OffsetQuery,\n  OffsetQueryOptions,\n  PopulateOneQueryParam,\n  PopulateQuery,\n  PopulateQueryOptions,\n  Return,\n  ReturnQuery,\n  ReturnQueryOptions,\n  Select,\n  SelectParam,\n  SelectQuery,\n  SelectQueryOptions,\n  SortField,\n  SortIndex,\n  SortQueryOptions,\n  Unique,\n  UniqueQuery,\n  UniqueQueryOptions,\n  Where,\n  WhereQuery,\n  Filter,\n  FilterQueryOptions,\n  FilterQuery,\n  WhereQueryOptions,\n} from './raw';\nimport { QueryOptions, QueryType } from './query';\nimport { NeuledgeError } from '@/error';\n\nexport class QueryClass<\n  T extends QueryType,\n  I extends StateDefinition,\n  O extends StateDefinition,\n> implements\n    ReturnQuery<any, I, O>, // eslint-disable-line @typescript-eslint/no-explicit-any\n    SelectQuery<any, I, O, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n    ExpandQuery<any, I, O, any, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n    PopulateQuery<any, I, O, any, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n    WhereQuery<I>,\n    UniqueQuery<any, I, O, any, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n    FilterQuery<I>,\n    MatchQuery<I>,\n    LimitQuery,\n    OffsetQuery,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ExecQuery<any>\n{\n  constructor(private readonly options: QueryOptions<T, I, O>) {\n    if ('unique' in options && options.unique === true) {\n      // prevent resolve this query until unique clause provided\n      // eslint-disable-next-line unicorn/no-thenable\n      this.then = null as never;\n    }\n  }\n\n  return(returns?: Return) {\n    (this.options as ReturnQueryOptions).returns = returns ?? 'new';\n    (this.options as SelectQueryOptions<O>).select = true;\n\n    return this;\n  }\n\n  select<P extends Select<O>>(select?: SelectParam<O, P> | true): this {\n    (this.options as SelectQueryOptions<O>).select = select ?? true;\n    return this;\n  }\n\n  expand<K extends StateOneRelations<O>>(\n    key: K,\n    states?:\n      | StateRelationStates<O, K>[]\n      | ExpandQueryParam<StateRelationStates<O, K>>,\n    query?: ExpandQueryParam<StateRelationStates<O, K>>,\n  ): this {\n    if (states !== undefined && !Array.isArray(states)) {\n      query = states;\n      states = undefined;\n    }\n\n    let rel = new QueryClass<\n      'SelectOne',\n      StateRelationStates<O, K>,\n      StateRelationStates<O, K>\n    >({\n      type: 'SelectOne',\n      states,\n    });\n\n    if (query) {\n      rel = query(rel) as typeof rel;\n    } else {\n      rel.select();\n    }\n\n    const options = this.options as ExpandQueryOptions<O>;\n\n    if (!options.expand) {\n      options.expand = {};\n    }\n    options.expand[key] = rel.options;\n\n    return this;\n  }\n\n  populateOne<K extends StateOneRelations<O>>(\n    key: K,\n    states?:\n      | StateRelationStates<O, K>[]\n      | PopulateOneQueryParam<StateRelationStates<O, K>>,\n    query?: PopulateOneQueryParam<StateRelationStates<O, K>>,\n  ): this {\n    if (states !== undefined && !Array.isArray(states)) {\n      query = states;\n      states = undefined;\n    }\n\n    let rel = new QueryClass<\n      'SelectOne',\n      StateRelationStates<O, K>,\n      StateRelationStates<O, K>\n    >({\n      type: 'SelectOne',\n      select: true,\n      states,\n    });\n\n    if (query) {\n      rel = query(rel) as typeof rel;\n    }\n\n    const options = this.options as PopulateQueryOptions<O>;\n\n    if (!options.populateOne) {\n      options.populateOne = {};\n    }\n    options.populateOne[key] = rel.options;\n\n    return this;\n  }\n\n  //   populateMany<K extends StateManyRelations<O>>(\n  //     key: K,\n  //     states?:\n  //       | StateRelationStates<O, K>[]\n  //       | PopulateManyQueryParam<StateRelationStates<O, K>>,\n  //     query?: PopulateManyQueryParam<StateRelationStates<O, K>>,\n  //   ): this {\n  //     if (states !== undefined && !Array.isArray(states)) {\n  //       query = states;\n  //       states = undefined;\n  //     }\n  //\n  //     let rel = new QueryClass<\n  //       'SelectMany',\n  //       StateRelationStates<O, K>,\n  //       StateRelationStates<O, K>\n  //     >({\n  //       type: 'SelectMany',\n  //       select: true,\n  //       states,\n  //     });\n  //\n  //     if (query) {\n  //       rel = query(rel) as typeof rel;\n  //     }\n  //\n  //     const options = this.options as PopulateQueryOptions<O>;\n  //\n  //     if (!options.populateMany) {\n  //       options.populateMany = {};\n  //     }\n  //     options.populateMany[key] = rel.options;\n  //\n  //     return this;\n  //   }\n\n  where(where: Where<I> | null): this {\n    (this.options as WhereQueryOptions<I>).where = where;\n    return this;\n  }\n\n  unique(where: Unique<I>): this {\n    (this.options as UniqueQueryOptions<I>).unique = where;\n\n    // re-enable resolve for this query\n    delete (this as Partial<this>).then;\n\n    return this;\n  }\n\n  filter(filter: Filter<I> | null): this {\n    (this.options as FilterQueryOptions<I>).filter = filter;\n    return this;\n  }\n\n  match<K extends StateAllRelations<I>>(\n    key: K,\n    states?:\n      | StateRelationStates<I, K>[]\n      | MatchQueryParam<StateRelationStates<I, K>>,\n    query?: MatchQueryParam<StateRelationStates<I, K>>,\n  ): this {\n    if (states !== undefined && !Array.isArray(states)) {\n      query = states;\n      states = undefined;\n    }\n\n    let rel: QueryClass<\n      'Refine',\n      StateRelationStates<I, K>,\n      StateRelationStates<I, K>\n    > = new QueryClass({\n      type: 'Refine',\n      states,\n    });\n\n    if (query) {\n      rel = query(rel) as typeof rel;\n    }\n\n    const options = this.options as RefineQueryOptions<I>;\n\n    if (!options.match) {\n      options.match = {};\n    }\n    options.match[key] = rel.options;\n\n    return this;\n  }\n\n  sort(sort: '*' | SortIndex<O> | null, ...fields: SortField<O>[]): this {\n    (this.options as SortQueryOptions<O>).sort = sort === '*' ? fields : sort;\n    return this;\n  }\n\n  limit(limit: number | null): this {\n    (this.options as LimitQueryOptions).limit = limit;\n    return this;\n  }\n\n  offset(offset: EntityListOffset | null): this {\n    (this.options as OffsetQueryOptions).offset = offset;\n    return this;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async exec(): Promise<any> {\n    if (!('exec' in this.options)) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_EXECUTION_ERROR,\n        `This query is not executable`,\n      );\n    }\n\n    if ('unique' in this.options && this.options.unique === true) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_EXECUTION_ERROR,\n        `Can't resolve a unique query without the '.unique()' clause`,\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this.options as ExecQueryOptions<any, any, any>).exec(this.options);\n  }\n\n  // eslint-disable-next-line unicorn/no-thenable, @typescript-eslint/no-explicit-any\n  then<TResult1 = any, TResult2 = never>(\n    onfulfilled?: // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ((value: any) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.exec()\n      .catch(NeuledgeError.wrap())\n      .then(onfulfilled, onrejected);\n  }\n}\n","export * from './engine';\n","import { Metadata } from '@/metadata/metadata';\nimport { StateDefinition } from '../definitions';\nimport {\n  FindFirstOrThrowQuery,\n  FindFirstQuery,\n  FindManyQuery,\n  FindUniqueOrThrowQuery,\n  FindUniqueQuery,\n  QueryClass,\n} from '../queries';\nimport { Store } from '@neuledge/store';\nimport { loadMetadata } from './metadata';\nimport {\n  execAlterMany,\n  execAlterOne,\n  execFindFirst,\n  execFindFirstOrThrow,\n  execFindMany,\n  execFindUnique,\n  execFindUniqueOrThrow,\n  execInitMany,\n  execInitOne,\n} from './exec';\nimport {\n  AlterFirstMutation,\n  AlterFirstOrThrowMutation,\n  AlterManyMutation,\n  AlterUniqueMutation,\n  AlterUniqueOrThrowMutation,\n  InitManyMutation,\n  InitOneMutation,\n  MutationGenerator,\n} from '@/mutations';\nimport { NeuledgeError } from '@/error';\n\nexport interface NeuledgeEngineOptions {\n  store: Store;\n  metadataCollectionName?: string;\n}\n\n/**\n * The main class of the Neuledge engine.\n * It provides methods to query and mutate state entities. To create an instance\n * of this class, you will need to provide a store instance. The store is used\n * to persist the state entities on the database.\n *\n * ```ts\n * import { NeuledgeEngine } from '@neuledge/engine';\n * import { MongoDBStore } from '@neuledge/mongodb-store';\n *\n * const store = new MongoDBStore({ ... });\n * const engine = new NeuledgeEngine({ store });\n */\nexport class NeuledgeEngine {\n  public readonly store: Store;\n  public readonly metadata: Promise<Metadata>;\n\n  constructor(options: NeuledgeEngineOptions) {\n    this.store = options.store;\n\n    this.metadata = loadMetadata(\n      this.store,\n      options.metadataCollectionName,\n    ).catch(NeuledgeError.wrap());\n\n    this.metadata.catch(() => {\n      // ignore errors here and let the user handle them via the exec methods\n    });\n  }\n\n  // finds\n\n  /**\n   * Find many entities that match the given states.\n   * It's not possible to query multiple states from different collections at\n   * once.\n   */\n  findMany<S extends StateDefinition>(...states: S[]): FindManyQuery<S> {\n    return new QueryClass({\n      type: 'FindMany',\n      states,\n      select: true,\n      exec: (options) => execFindMany(this, options),\n    });\n  }\n\n  /**\n   * Find a unique entity that matches the given states.\n   * Use the `.unique()` method to provide the unique where clause. Returns null\n   * if no entity was found. It's not possible to query multiple states from\n   * different collections at once.\n   */\n  findUnique<S extends StateDefinition>(...states: S[]): FindUniqueQuery<S> {\n    return new QueryClass({\n      type: 'FindUnique',\n      states,\n      select: true,\n      unique: true,\n      exec: (options) => execFindUnique(this, options),\n    });\n  }\n\n  /**\n   * Find a unique entity that matches the given states.\n   * Use the `.unique()` method to provide the unique where clause. Throws an\n   * error if no entity was found. It's not possible to query multiple states\n   * from different collections at once.\n   */\n  findUniqueOrThrow<S extends StateDefinition>(\n    ...states: S[]\n  ): FindUniqueOrThrowQuery<S> {\n    return new QueryClass({\n      type: 'FindUniqueOrThrow',\n      states,\n      select: true,\n      unique: true,\n      exec: (options) => execFindUniqueOrThrow(this, options),\n    });\n  }\n\n  /**\n   * Find the first entity that matches the given states.\n   * Returns null if no entity was found. It's not possible to query multiple\n   * states from different collections at once.\n   */\n  findFirst<S extends StateDefinition>(...states: S[]): FindFirstQuery<S> {\n    return new QueryClass({\n      type: 'FindFirst',\n      states,\n      select: true,\n      exec: (options) => execFindFirst(this, options),\n    });\n  }\n\n  /**\n   * Find the first entity that matches the given states.\n   * Throws an error if no entity was found. It's not possible to query multiple\n   * states from different collections at once.\n   */\n  findFirstOrThrow<S extends StateDefinition>(\n    ...states: S[]\n  ): FindFirstOrThrowQuery<S> {\n    return new QueryClass({\n      type: 'FindFirstOrThrow',\n      states,\n      select: true,\n      exec: (options) => execFindFirstOrThrow(this, options),\n    });\n  }\n\n  // init\n\n  /**\n   * Call a create mutation for the given state and create multiple new\n   * entities.\n   * Returns void by default. Use the `.select()` method to return the created\n   * entities.\n   *\n   * For example, for a state `DraftPost` with the create mutation `create`:\n   * ```\n   * engine.initMany(DraftPost).create({ title: 'Hello' }, { title: 'World' })\n   * ```\n   */\n  initMany<S extends StateDefinition>(state: S): InitManyMutation<S> {\n    return MutationGenerator(\n      'InitMany',\n      [state],\n      (options) =>\n        new QueryClass<'InitMany', S, S>({\n          ...options,\n          exec: (options) => execInitMany(this, options),\n        }),\n    );\n  }\n\n  /**\n   * Call a create mutation for the given state and create a new entity.\n   * Returns void by default. Use the `.select()` method to return the created\n   * entity.\n   *\n   * For example, for a state `DraftPost` with the create mutation `create`:\n   * ```\n   * engine.initOne(DraftPost).create({ title: 'Hello' })\n   * ```\n   */\n  initOne<S extends StateDefinition>(state: S): InitOneMutation<S> {\n    return MutationGenerator(\n      'InitOne',\n      [state],\n      (options) =>\n        new QueryClass<'InitOne', S, S>({\n          ...options,\n          exec: (options) => execInitOne(this, options),\n        }),\n    );\n  }\n\n  // alter\n\n  /**\n   * Call an update or delete mutation for the given states and alter multiple\n   * entities at once.\n   * Returns void by default. Use the `.return()` method to return the original\n   * or altered entities. You may filter and limit the entities that are altered\n   * by using `.where()` or other methods.\n   *\n   * For example, for a state `DraftPost` with the update mutation `update`:\n   * ```\n   * engine.alterMany(DraftPost).update({ title: 'Hello' })\n   * ```\n   */\n  alterMany<S extends StateDefinition>(...states: S[]): AlterManyMutation<S> {\n    return MutationGenerator(\n      'AlterMany',\n      states,\n      (options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        new QueryClass<'AlterMany', S, any>({\n          returns: 'new',\n          ...options,\n          exec: (options) => execAlterMany(this, options),\n        }),\n    );\n  }\n\n  /**\n   * Call an update or delete mutation for the given states and alter the first\n   * matching entity.\n   * Returns void by default. Use the `.return()` method to return the original\n   * or altered entities. You may filter and limit the entities that are altered\n   * by using `.where()` or other methods.\n   *\n   * For example, for a state `DraftPost` with the update mutation `update`:\n   * ```\n   * engine.alterFirst(DraftPost).update({ title: 'Hello' })\n   * ```\n   */\n  alterFirst<S extends StateDefinition>(...states: S[]): AlterFirstMutation<S> {\n    return MutationGenerator(\n      'AlterFirst',\n      states,\n      (options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        new QueryClass<'AlterFirst', S, any>({\n          returns: 'new',\n          ...options,\n          exec: (options) => execAlterOne(this, options),\n        }),\n    );\n  }\n\n  /**\n   * Call an update or delete mutation for the given states and alter the first\n   * matching entity.\n   * Returns void by default. Throws an error if no entity was found. Use the\n   * `.return()` method to return the original or altered entities. You may\n   * filter and limit the entities that are altered by using `.where()` or other\n   * methods.\n   *\n   * For example, for a state `DraftPost` with the update mutation `update`:\n   * ```\n   * engine.alterFirstOrThrow(DraftPost).update({ title: 'Hello' })\n   * ```\n   */\n  alterFirstOrThrow<S extends StateDefinition>(\n    ...states: S[]\n  ): AlterFirstOrThrowMutation<S> {\n    return MutationGenerator(\n      'AlterFirstOrThrow',\n      states,\n      (options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        new QueryClass<'AlterFirstOrThrow', S, any>({\n          returns: 'new',\n          ...options,\n          exec: (options) => execAlterOne(this, options),\n        }),\n    );\n  }\n\n  /**\n   * Call an update or delete mutation for the given states and alter the\n   * uniquely matching entity.\n   * Returns void by default. Use the `.return()` method to return the original\n   * or altered entity. Use the `.unique()` method to specify the unique fields.\n   *\n   * For example, for a state `DraftPost` with the update mutation `update`:\n   * ```\n   * engine.alterUnique(DraftPost).update({ title: 'Hello' }).unique({ id: 1 })\n   * ```\n   */\n  alterUnique<S extends StateDefinition>(\n    ...states: S[]\n  ): AlterUniqueMutation<S> {\n    return MutationGenerator(\n      'AlterUnique',\n      states,\n      (options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        new QueryClass<'AlterUnique', S, any>({\n          returns: 'new',\n          ...options,\n          unique: true,\n          exec: (options) => execAlterOne(this, options),\n        }),\n    );\n  }\n\n  /**\n   * Call an update or delete mutation for the given states and alter the\n   * uniquely matching entity.\n   * Returns void by default. Throws an error if no entity was found. Use the\n   * `.return()` method to return the original or altered entity. Use the\n   * `.unique()` method to specify the unique fields.\n   *\n   * For example, for a state `DraftPost` with the update mutation `update`:\n   * ```\n   * engine.alterUniqueOrThrow(DraftPost).update({ title: 'Hello' }).unique({ id: 1 })\n   * ```\n   */\n  alterUniqueOrThrow<S extends StateDefinition>(\n    ...states: S[]\n  ): AlterUniqueOrThrowMutation<S> {\n    return MutationGenerator(\n      'AlterUniqueOrThrow',\n      states,\n      (options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        new QueryClass<'AlterUniqueOrThrow', S, any>({\n          returns: 'new',\n          ...options,\n          unique: true,\n          exec: (options) => execAlterOne(this, options),\n        }),\n    );\n  }\n\n  // utils\n\n  /**\n   * Return a promise that resolves when the engine is ready.\n   * The engine is ready when the metadata is loaded and the database is\n   * connected. This is useful when you want to wait for the engine to be ready\n   * before starting your server. If you query the engine before it is ready,\n   * the queries will be queued and executed when the engine is ready or throw\n   * if there is an error while loading the engine.\n   */\n  async ready(): Promise<this> {\n    await this.metadata;\n    return this;\n  }\n}\n","export * from './load';\n","import { neuledgeGlob } from '@/glob';\nimport { Metadata } from '@/metadata';\nimport { Store } from '@neuledge/store';\nimport { ensureStoreCollections } from './collections';\nimport {\n  ensureMetadataCollection,\n  getMetadataCollection,\n  getStoreMetadataSnapshot,\n  syncStoreMetadata,\n} from './store';\n\nconst DEFAULT_METADATA_COLLECTION_NAME = '__neuledge_metadata';\n\nexport const loadMetadata = async (\n  store: Store,\n  metadataCollectionName: string = DEFAULT_METADATA_COLLECTION_NAME,\n): Promise<Metadata> => {\n  // init collection for metadata\n  const metadataCollection = getMetadataCollection(metadataCollectionName);\n  await ensureMetadataCollection(store, metadataCollection);\n\n  // generate metadata for current states\n  const metadata = new Metadata(neuledgeGlob.stateDefinitions.values());\n\n  // load previous metadata snapshot from the store\n  const snapshot = await getStoreMetadataSnapshot(\n    metadata,\n    store,\n    metadataCollection,\n  );\n\n  // sync metadata with previous snapshot and generate change list\n  const changes = metadata.sync(snapshot);\n\n  // update database collections and indexes\n  await ensureStoreCollections(store, metadata);\n\n  // update metadata snapshot in the store\n  await syncStoreMetadata(store, metadataCollection, changes);\n\n  return metadata;\n};\n","export * from './change';\nexport * from './collection';\nexport * from './constants';\nexport * from './metadata';\nexport * from './state';\nexport * from './schema';\n","import { StateSnapshot } from './state';\n\nexport type MetadataChange = MetadataCreatedChange | MetadataUpdatedChange;\n\nexport interface MetadataCreatedChange {\n  type: 'created';\n  entity: StateSnapshot;\n}\n\nexport interface MetadataUpdatedChange {\n  type: 'updated';\n  entity: StateSnapshot;\n  origin: StateSnapshot;\n}\n","import { parseSortedField, SortDefinition } from '@/definitions';\nimport { NeuledgeError } from '@/error';\nimport {\n  StoreCollection,\n  StoreField,\n  StoreIndex,\n  StoreIndexField,\n  StorePrimaryKey,\n} from '@neuledge/store';\nimport {\n  getMetadataSchema,\n  MetadataSchema,\n  MetadataSchemaChoice,\n} from './schema';\nimport {\n  MetadataState,\n  MetadataStateField,\n  MetadataStateReservedNames,\n} from './state';\n\nexport type MetadataCollectionFieldMap = Record<\n  MetadataStateField['path'],\n  {\n    fields: Map<MetadataStateField['name'], MetadataStateField>;\n    children: Set<MetadataStateField['path']>;\n  }\n>;\n\nexport class MetadataCollection implements StoreCollection {\n  readonly reservedNames: MetadataStateReservedNames;\n  readonly schema: MetadataSchema;\n  readonly primaryKey: StorePrimaryKey;\n  readonly indexes: Record<StoreIndex['name'], StoreIndex>;\n  readonly fields: Record<StoreField['name'], StoreField>;\n\n  constructor(\n    public readonly name: string,\n    public readonly states: MetadataState[],\n  ) {\n    this.fields = getStoreCollectionFields(states);\n    this.schema = getMetadataSchema(this.states);\n\n    const { indexes, primaryKey } = getStoreIndexes(this.schema, states);\n\n    this.indexes = indexes;\n    this.primaryKey = primaryKey;\n\n    this.reservedNames = this.states[0].reservedNames;\n  }\n\n  /**\n   * Traverse the collection schema and all fields under the given path.\n   */\n  getSchemaFields(rootPath: string): MetadataStateField[] {\n    let choices = this.schema[rootPath];\n    if (!choices) return [];\n\n    choices = [...choices].reverse();\n    const res: MetadataStateField[] = [];\n\n    while (choices.length) {\n      const choice = choices.pop() as MetadataSchemaChoice;\n\n      if (choice.field) {\n        res.push(choice.field);\n        continue;\n      }\n\n      for (const schemaChoices of Object.values(choice.schema)) {\n        if (!schemaChoices) continue;\n\n        choices.push(...[...schemaChoices].reverse());\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * Traverse the collection schema and all field names under the given path.\n   */\n  getSchemaFieldNames(rootPath: string): string[] {\n    return this.getSchemaFields(rootPath).map((field) => field.name);\n  }\n}\n\nconst getStoreCollectionFields = (\n  states: MetadataState[],\n): StoreCollection['fields'] => {\n  const fields: StoreCollection['fields'] = {};\n\n  // count field name references by states\n  const refCount = new Map<string, number>();\n\n  // add fields from states, prefer nullable fields\n  for (const state of states) {\n    for (const field of state.fields) {\n      const storeField = fields[field.name];\n\n      if (!storeField) {\n        fields[field.name] = getStoreField(field);\n      } else if (field.nullable && !storeField.nullable) {\n        storeField.nullable = true;\n      }\n\n      const count = refCount.get(field.name) ?? 0;\n      refCount.set(field.name, count + 1);\n    }\n  }\n\n  // set field to nullable if it is not referenced by all states\n  for (const [name, count] of refCount) {\n    if (count === states.length) continue;\n\n    const field = fields[name];\n    field.nullable = true;\n  }\n\n  return fields;\n};\n\nconst getStoreField = (field: MetadataStateField): StoreField => ({\n  name: field.name,\n  ...field.type.shape,\n  nullable: field.nullable,\n});\n\nconst getStoreIndexes = (\n  schema: MetadataSchema,\n  states: MetadataState[],\n): Pick<StoreCollection, 'indexes' | 'primaryKey'> => {\n  const indexes: StoreCollection['indexes'] = {};\n  const primaryKey: StoreCollection['primaryKey'] = {\n    name: '', // will be set by `applyPrimaryKey`\n    fields: getStoreIndexFields(schema, states[0].instance.$id.fields),\n    unique: 'primary',\n    auto: states[0].instance.$id.auto,\n  };\n\n  for (const state of states) {\n    for (const [name, index] of Object.entries(state.instance.$indexes ?? {})) {\n      indexes[name] = {\n        name,\n        fields: getStoreIndexFields(schema, index.fields),\n        unique: index.unique,\n      };\n    }\n  }\n\n  applyPrimaryKey(indexes, primaryKey);\n\n  return { indexes, primaryKey } as const;\n};\n\nconst getStoreIndexFields = (\n  schema: MetadataSchema,\n  sortDefinition: SortDefinition<Record<string, unknown>>,\n): StoreIndex['fields'] => {\n  const fields: StoreIndex['fields'] = {};\n\n  for (const sortField of sortDefinition) {\n    const [name, sort] = parseSortedField(sortField);\n    const indexField: StoreIndexField = { sort };\n\n    const choices = schema[name];\n    if (!choices) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.UNKNOWN_SORT_FIELD,\n        `Unknown sort field: '${name}'`,\n      );\n    }\n\n    assignStoreIndexField(fields, choices, indexField);\n  }\n\n  return fields;\n};\n\nconst assignStoreIndexField = (\n  fields: StoreIndex['fields'],\n  choices: (MetadataSchemaChoice | undefined)[],\n  indexField: StoreIndexField,\n): void => {\n  for (const choice of choices) {\n    if (!choice) continue;\n\n    if (choice.field) {\n      fields[choice.field.name] = indexField;\n      continue;\n    }\n\n    assignStoreIndexField(\n      fields,\n      Object.values(choice.schema).flatMap((item) => item ?? []),\n      indexField,\n    );\n  }\n};\n\nconst applyPrimaryKey = (\n  indexes: StoreCollection['indexes'],\n  primaryKey: StoreCollection['primaryKey'],\n): void => {\n  const primaryKeyName = Object.keys(primaryKey.fields).join('_');\n\n  primaryKey.name = primaryKeyName;\n  for (let i = 2; indexes[primaryKey.name]; i++) {\n    primaryKey.name = `${primaryKeyName}_${i}`;\n  }\n\n  indexes[primaryKey.name] = primaryKey;\n};\n","import { MetadataState, MetadataStateField } from './state';\n\n/**\n * Metadata schema contain for each where path a set of choices, each choice\n * can be a field or a sub schema.\n */\nexport type MetadataSchema = {\n  [Path in string]?: MetadataSchemaChoice[];\n};\n\n/**\n * A schema choice can be a field or a sub schema.\n */\nexport type MetadataSchemaChoice =\n  | { field: MetadataStateField; schema?: never }\n  | { field?: never; schema: MetadataSchema };\n\n/**\n * Get the metadata schema from the given states.\n * This function will be used recursively to build the schema for the relation\n * fields. If a relation parent provided, only include the fields that are under\n * the parent path will be included.\n */\nexport const getMetadataSchema = (\n  states: MetadataState[],\n  relationParent?: { state: MetadataState; path: string },\n): MetadataSchema => {\n  const schemaMap: Record<string, Record<string, MetadataSchemaChoice>> = {};\n\n  for (const state of states) {\n    // query the state fields and build the field choices\n    // if a relation parent provided, only include the fields that are under\n    // the parent path\n    for (const field of (relationParent?.state ?? state).fields) {\n      let { path } = field;\n      if (relationParent) {\n        if (!path.startsWith(`${relationParent.path}.`)) continue;\n\n        path = path.slice(relationParent.path.length + 1);\n      }\n\n      let pathChoices = schemaMap[path];\n      if (!pathChoices) {\n        pathChoices = schemaMap[path] = {};\n      }\n\n      const key = getFieldKey(field);\n      if (pathChoices[key]) continue;\n\n      pathChoices[key] = { field };\n    }\n\n    // query the state relations and build the schema choices\n    // if a relation parent provided, only include the relations that are under\n    // the parent path\n    for (const relation of state.relations) {\n      let { path } = relation;\n\n      if (relationParent) {\n        if (!path.startsWith(`${relationParent.path}.`)) continue;\n\n        path = path.slice(relationParent.path.length + 1);\n      }\n\n      let pathChoices = schemaMap[path];\n      if (!pathChoices) {\n        pathChoices = schemaMap[path] = {};\n      }\n\n      const key = getSchemaKey(relation.states);\n      if (pathChoices[key]) continue;\n\n      const childSchema = getMetadataSchema(relation.states, { state, path });\n      pathChoices[key] = { schema: childSchema };\n    }\n  }\n\n  // convert the schema map to a schema object without the choices keys\n  return Object.fromEntries(\n    Object.entries(schemaMap).map(([path, choices]) => [\n      path,\n      Object.values(choices),\n    ]),\n  );\n};\n\n/**\n * Get a unique field key\n */\nconst getFieldKey = (field: MetadataStateField): string =>\n  `${field.name}:${field.type.name}${field.nullable ? '?' : ''}`;\n\n/**\n * Get a unique schema key\n */\nconst getSchemaKey = (states: MetadataState[]): string =>\n  JSON.stringify(\n    states\n      .map((state) => `${state.name}#${state.hash.toString('base64url')}`)\n      .sort(),\n  );\n","export const METADATA_HASH_BYTES = 8;\n","import { StateDefinition } from '@/definitions';\nimport { MetadataCollection } from './collection';\nimport {\n  renameDuplicateFieldNames,\n  groupStatesByCollectionName,\n} from './names';\nimport { MetadataState, MetadataStateContext } from './state';\nimport { MetadataSnapshot } from './snapshot';\nimport { NeuledgeError } from '@/error';\nimport { MetadataChange } from './change';\n\n/**\n * Metadata is a snapshot of the current state of the database, including all\n * the states, fields, and types instances that are currently used in the\n * codebase.\n */\nexport class Metadata extends MetadataSnapshot<MetadataState> {\n  private collections: Partial<Record<string, MetadataCollection>>;\n\n  constructor(states: Iterable<StateDefinition>) {\n    const stateGroups = groupStatesByCollectionName(states);\n\n    const ctx: MetadataStateContext = {};\n    const collections: Partial<Record<string, MetadataCollection>> = {};\n\n    const allStates: MetadataState[] = [];\n\n    for (const [name, states] of stateGroups) {\n      const metadataStates = [...states].map((state) =>\n        MetadataState.fromDefinition(ctx, state, name),\n      );\n\n      renameDuplicateFieldNames(metadataStates);\n\n      collections[name] = new MetadataCollection(name, metadataStates);\n      allStates.push(...metadataStates);\n    }\n\n    super(allStates);\n\n    this.collections = collections;\n  }\n\n  get listCollections(): MetadataCollection[] {\n    return Object.values(this.collections) as MetadataCollection[];\n  }\n\n  getCollectionByMetadataState(state: MetadataState): MetadataCollection {\n    const collection = this.collections[state.collectionName];\n\n    if (!collection) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.METADATA_LOAD_ERROR,\n        `Collection \"${state.collectionName}\" not found in the engine metadata. Make sure you initialize the engine AFTER declaring the states.`,\n      );\n    }\n\n    return collection;\n  }\n\n  getCollections(states: readonly StateDefinition[]): MetadataCollection[] {\n    const collectionNames = new Set<MetadataState['collectionName']>();\n\n    for (const def of states) {\n      const state = this.findStateByKey(def.$name);\n      if (!state) {\n        throw new NeuledgeError(\n          NeuledgeError.Code.METADATA_LOAD_ERROR,\n          `State \"${def.$name}\" not found in the engine metadata. Make sure you initialize the engine AFTER declaring the states.`,\n        );\n      }\n\n      collectionNames.add(state.collectionName);\n    }\n\n    return [...collectionNames].map((name) => {\n      const collection = this.collections[name];\n\n      if (!collection) {\n        throw new NeuledgeError(\n          NeuledgeError.Code.METADATA_LOAD_ERROR,\n          `Collection \"${name}\" not found in the engine metadata. Make sure you initialize the engine AFTER declaring the states.`,\n        );\n      }\n\n      return collection;\n    });\n  }\n\n  sync(snapshot: MetadataSnapshot): MetadataChange[] {\n    const changes = super.sync(snapshot);\n\n    // recreate collections as some state names may have changed\n\n    const collectionStates: Record<string, MetadataState[]> = {};\n    for (const state of this.states) {\n      let entry = collectionStates[state.collectionName];\n\n      if (!entry) {\n        entry = collectionStates[state.collectionName] = [];\n      }\n\n      entry.push(state);\n    }\n\n    const collections: Record<string, MetadataCollection> = {};\n    for (const [name, states] of Object.entries(collectionStates)) {\n      collections[name] = new MetadataCollection(name, states);\n    }\n\n    this.collections = collections;\n    return changes;\n  }\n}\n","export * from './collections';\nexport * from './fields';\n","import { resolveDefer, StateDefinition, StateName } from '@/definitions';\nimport pluralize from 'pluralize';\n\n/**\n * Group states by collections and return a map of collection name to it's states.\n */\nexport const groupStatesByCollectionName = (\n  states: Iterable<StateDefinition>,\n): Map<string, Iterable<StateDefinition>> => {\n  const groups = getStateGroups(states);\n\n  // get all possible names for each group\n  const suggestions: StatesNameSuggestion[] = [];\n  for (const group of groups.values()) {\n    suggestions.push(...suggestStatesCollectionNames(group));\n  }\n\n  // sort suggestions by name and rank to pick the best name for each group among all groups suggestions\n  suggestions.sort((a, b) => a.name.localeCompare(b.name) || b.rank - a.rank);\n\n  const selectedName = new Map<\n    Iterable<StateDefinition>,\n    StatesNameSuggestion\n  >();\n\n  // pick the best ranked name for each group\n  for (const [index, suggestion] of suggestions.entries()) {\n    // ignore name collisions with last suggestion\n    if (suggestions[index - 1]?.name === suggestion.name) continue;\n\n    const best = selectedName.get(suggestion.states);\n    if (best == null || best.rank < suggestion.rank) {\n      selectedName.set(suggestion.states, suggestion);\n    }\n  }\n\n  return new Map(\n    [...selectedName.entries()].map(([states, suggestion]) => [\n      suggestion.name,\n      states,\n    ]),\n  );\n};\n\nconst getStateGroups = (\n  states: Iterable<StateDefinition>,\n): Set<Set<StateDefinition>> => {\n  const groups: Map<StateName, Set<StateDefinition>> = new Map();\n\n  for (const state of states) {\n    let set = groups.get(state.$name);\n    if (!set) {\n      set = new Set([state]);\n      groups.set(state.$name, set);\n    }\n\n    const relatedStates = resolveDefer(state.$transforms, []);\n    for (const relatedState of relatedStates) {\n      set.add(relatedState);\n\n      for (const item of groups.get(relatedState.$name) ?? []) {\n        set.add(item);\n      }\n    }\n\n    for (const state of set) {\n      groups.set(state.$name, set);\n    }\n  }\n\n  return new Set(groups.values());\n};\n\ntype StatesNameSuggestion = {\n  states: Iterable<StateDefinition>;\n  name: string;\n  rank: number;\n};\n\n/**\n * Get all possible name combinations for a group of states by reusing the state\n * names and generate all common phrases between all states.\n *\n * For example, if the group contains states `PaidUser`, `PaidUserProfile` and `AvatarPaidUser`,\n * the suggestions will be:\n * - `paid_users`\n * - `users`\n * - `paid`\n * - `paid_user_profiles`\n * - `avatar_paid_users`\n */\nconst suggestStatesCollectionNames = (\n  stateGroup: Iterable<StateDefinition>,\n): StatesNameSuggestion[] => {\n  const suggestions: StatesNameSuggestion[] = [];\n  const sharedPhrase: string[] = [];\n\n  let first = true;\n  for (const state of stateGroup) {\n    // split string to words by camel case, snake case and numbers\n    const words = state.$name\n      .split(/(?=[A-Z])|_|(?<=[a-z])(?=\\d)/)\n      .map((word) => word.toLowerCase());\n\n    // add exact name suggestion with rank 0\n    suggestions.push({\n      states: stateGroup,\n      name: formatCollectionName(words),\n      rank: 0,\n    });\n\n    if (first) {\n      sharedPhrase.push(...words);\n\n      first = false;\n      continue;\n    }\n\n    const wordsSet = new Set(words);\n\n    // remove words that are not shared by all states\n    for (let i = 0; i < sharedPhrase.length; i++) {\n      if (!wordsSet.has(sharedPhrase[i])) {\n        sharedPhrase.splice(i, 1);\n        i--;\n      }\n    }\n  }\n\n  // add suggestion for the shared phrase between all states with top rank\n  suggestions.push({\n    states: stateGroup,\n    name: formatCollectionName(sharedPhrase),\n    rank: 1000,\n  });\n\n  // add suggestions for another shared phrases with lower rank\n  for (let i = sharedPhrase.length - 1; i > 0; i--) {\n    suggestions.push(\n      {\n        states: stateGroup,\n        name: formatCollectionName(sharedPhrase.slice(i)),\n        rank: (500 * sharedPhrase.length - i) / sharedPhrase.length,\n      },\n      {\n        states: stateGroup,\n        name: formatCollectionName(sharedPhrase.slice(0, i)),\n        rank: (100 * i) / sharedPhrase.length,\n      },\n    );\n  }\n\n  return suggestions;\n};\n\n/**\n * Get a collection name from a list of words where the last word is pluralized.\n * For example: ['user', 'profile'] -> 'user_profiles'\n */\nconst formatCollectionName = (words: string[]): string =>\n  [...words.slice(0, -1), pluralize.plural(words[words.length - 1])].join('_');\n","import { StateFieldSnapshot } from '../state';\n\n/**\n * Will check that all field names within all states are pointing to the same\n * field type. If not, it will rename the field name to be unique.\n *\n * Rename will be done by appending the field type name to the field name. If\n * the field name already contains the field type name, or if the field name\n * already exists, it will append a number to the field name.\n */\nexport const renameDuplicateFieldNames = <\n  Field extends Pick<StateFieldSnapshot, 'name' | 'type'>,\n>(\n  states: {\n    fields: Field[];\n  }[],\n): void => {\n  // generate a 3d map of name -> type -> fields[]\n  const fieldMap = generateFieldMap(states);\n\n  // rename duplicate fields\n  for (const [name, typeMap] of fieldMap) {\n    if (typeMap.size === 1) continue;\n\n    // check if the type is already exists in the name\n    const hasTypeInName = typeMap.has(\n      toSnakeCase(name.split('_').pop() as string),\n    );\n    let index = 0;\n\n    for (const [type, list] of typeMap) {\n      let newName = `${name}_${type}`;\n\n      if (hasTypeInName || fieldMap.has(newName)) {\n        if (index === 0) {\n          // keep the first duplicate name as is\n          index = 1;\n          continue;\n        }\n\n        do {\n          newName = `${name}_${++index}`;\n        } while (fieldMap.has(newName));\n      }\n\n      // reindex the field map\n      fieldMap.set(newName, new Map([[type, list]]));\n      typeMap.delete(type);\n\n      // rename the fields\n      for (const field of list) {\n        field.name = newName;\n      }\n    }\n  }\n};\n\nconst generateFieldMap = <\n  Field extends Pick<StateFieldSnapshot, 'name' | 'type'>,\n>(\n  states: {\n    fields: Field[];\n  }[],\n): Map<Field['name'], Map<Field['type']['name'], Field[]>> => {\n  const fieldMap = new Map<\n    Field['name'],\n    Map<Field['type']['name'], Field[]>\n  >();\n\n  for (const { fields } of states) {\n    for (const field of fields) {\n      let typeMap = fieldMap.get(field.name);\n      if (!typeMap) {\n        typeMap = new Map();\n        fieldMap.set(field.name, typeMap);\n      }\n\n      const type = toSnakeCase(field.type.name);\n      let list = typeMap.get(type);\n      if (!list) {\n        list = [];\n        typeMap.set(type, list);\n      }\n\n      list.push(field);\n    }\n  }\n\n  return fieldMap;\n};\n\nexport const toSnakeCase = (str: string): string =>\n  str.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();\n","export * from './snapshot';\nexport * from './field';\nexport * from './state';\n","import { StateDefinition } from '@/definitions';\nimport { generateHash } from '../hash';\nimport { getMetadataStateFieldKey, StateFieldSnapshot } from './field';\n\nexport type StateSnapshotHash = Buffer;\n\nexport interface StateRelationSnapshot {\n  name: string;\n  states: StateSnapshot[];\n  path?: string;\n  index: number;\n}\n\nexport class StateSnapshot {\n  collectionName!: string;\n  name!: string;\n  hash!: StateSnapshotHash;\n  fields!: StateFieldSnapshot[];\n  instance?: StateDefinition;\n  relations!: StateRelationSnapshot[];\n\n  /**\n   * Check that the origin state matches the current state signature.\n   * The state can match if one of the following conditions is true:\n   * - the hash is the same\n   * - the current state has all the required fields of the origin state\n   */\n  matches(origin: StateSnapshot): boolean {\n    if (this.hash.equals(origin.hash)) return true;\n\n    const existingFields = new Map(\n      this.fields.map((item) => [getMetadataStateFieldKey(item), item]),\n    );\n\n    return Object.values(origin.fields).every((originField) => {\n      const existsField = existingFields.get(\n        getMetadataStateFieldKey(originField),\n      );\n      if (!existsField) {\n        return originField.nullable;\n      }\n\n      return !existsField.nullable || originField.nullable;\n    });\n  }\n\n  /**\n   * Sync the current state with the origin state.\n   * This will update the collection name and store field names to match the\n   * origin state representation on the store. This is useful when the state\n   * rename a field and we want to keep the same name on the store for backward\n   * compatibility.\n   */\n  sync(origin: StateSnapshot): void {\n    this.collectionName = origin.collectionName;\n\n    const targetFields = new Map(\n      this.fields.map((field) => [getMetadataStateFieldKey(field), field]),\n    );\n    const targetFieldNames = new Map(\n      this.fields.map((field) => [field.name, field]),\n    );\n\n    for (const key in origin.fields) {\n      const field = origin.fields[key];\n      const targetField = targetFields.get(getMetadataStateFieldKey(field));\n\n      if (!targetField || targetField.name === field.name) continue;\n\n      const oldFieldName = targetField.name;\n      const overrideField = targetFieldNames.get(field.name);\n\n      targetField.name = field.name;\n      targetFieldNames.set(targetField.name, targetField);\n\n      if (overrideField) {\n        overrideField.name = oldFieldName;\n        targetFieldNames.set(overrideField.name, overrideField);\n      }\n    }\n  }\n\n  clone(): this {\n    return Object.assign(Object.create(this), this);\n  }\n\n  assign(\n    origin: Omit<StateSnapshot, 'matches' | 'sync' | 'clone' | 'assign'>,\n  ): this {\n    this.collectionName = origin.collectionName;\n    this.name = origin.name;\n    this.hash = origin.hash;\n    this.fields = origin.fields;\n    this.relations = origin.relations;\n\n    return this;\n  }\n}\n\n// state\n\nexport const generateStateHash = (\n  state: Pick<StateSnapshot, 'fields' | 'relations'>,\n): StateSnapshotHash =>\n  generateHash([\n    state.fields.map((field) => getMetadataStateFieldKey(field, true)).sort(),\n    state.relations\n      .map((relation) => getMetadataStateRelationKey(relation))\n      .sort(),\n  ]);\n\nconst getMetadataStateRelationKey = (relation: StateRelationSnapshot): string =>\n  `${relation.index}#${relation.states\n    .map((state) =>\n      generateStateHash({ fields: state.fields, relations: [] }).toString(\n        'base64url',\n      ),\n    )\n    .join('|')}`;\n","import { createHash } from 'node:crypto';\nimport { METADATA_HASH_BYTES } from './constants';\n\nconst HASH_ALGORITHM = 'sha512';\n\ntype HashPayload = string | number | boolean | HashPayload[];\n\nexport const generateHash = (payload: HashPayload): Buffer =>\n  createHash(HASH_ALGORITHM)\n    .update(JSON.stringify(payload))\n    .digest()\n    .slice(0, METADATA_HASH_BYTES);\n","import {\n  fromSortedField,\n  isStateDefinitionScalarTypeScalar,\n  resolveDefer,\n  StateDefinition,\n  StateDefintionScalar,\n} from '@/definitions';\nimport { Scalar } from '@neuledge/scalars';\nimport { toSnakeCase } from '../names';\n\nexport interface StateFieldSnapshot {\n  name: string;\n  path?: string;\n  indexes: number[];\n  type: Scalar;\n  nullable: boolean;\n}\n\nexport interface MetadataStateField extends StateFieldSnapshot {\n  path: string;\n}\n\nexport const getMetadataStateFieldKey = (\n  field: StateFieldSnapshot,\n  strict?: boolean,\n): string =>\n  `${field.indexes.join(':')}#${field.type}${\n    strict && field.nullable ? '?' : ''\n  }`;\n\n/**\n * Generate list of scalar fields from field definition. Usually, each field definition\n * will have only one scalar field, but in case of nested states, it may have multiple\n * fields, as the number of primary keys in the nested state.\n *\n * We will assign a unique name to each field, and the path will match the original\n * field destination, using dot notation for nested fields. For example, if we have\n * a field named `user` that is a nested state, and the nested state has a primary\n * key named `id`, the field name will be `user_id`, and the path will be `user.id`.\n *\n * The indexes will be the indexes of the parent state, plus the index of the field\n * in the current state. Top level fields will have only one item in the indexes array\n * that equals the index of the field in the state.\n */\nexport const getScalarFields = (\n  name: string,\n  path: string,\n  scalarDef: StateDefintionScalar,\n  parentIndexes: number[] = [],\n  nullable?: boolean,\n): MetadataStateField[] => {\n  const { type, index } = scalarDef;\n\n  if (!nullable && scalarDef.nullable) {\n    nullable = true;\n  }\n\n  const indexes = [...parentIndexes, index];\n\n  // type is scalar\n  if (isStateDefinitionScalarTypeScalar(type)) {\n    return [\n      {\n        name: toSnakeCase(name),\n        path,\n        indexes,\n        type,\n        nullable: nullable ?? false,\n      },\n    ];\n  }\n\n  return getStateDefinitionFields(name, path, indexes, type, nullable);\n};\n\nconst getStateDefinitionFields = (\n  name: string,\n  path: string,\n  indexes: number[],\n  type: readonly StateDefinition[],\n  nullable?: boolean,\n): MetadataStateField[] => {\n  const fieldMap = new Map<string, MetadataStateField>();\n  const refCount = new Map<string, number>();\n\n  // `type` is array of possible states\n  for (const childState of type) {\n    const scalars = resolveDefer(childState.$scalars);\n\n    // query only the primary key fields\n    for (const sortKey of childState.$id.fields) {\n      const id = fromSortedField(sortKey);\n      const childScalarDef = scalars[id];\n\n      const scalarFields = getScalarFields(\n        `${name}_${id}`,\n        `${path}.${id}`,\n        childScalarDef,\n        indexes,\n        nullable,\n      );\n\n      for (const item of scalarFields) {\n        const mapKey = getMetadataStateFieldKey(item);\n        const value = fieldMap.get(mapKey);\n\n        if (!value || (!value.nullable && item.nullable)) {\n          // prefer nullable fields and overwrite existing field if the current\n          // field is not nullable\n          fieldMap.set(mapKey, item);\n        }\n\n        refCount.set(mapKey, (refCount.get(mapKey) ?? 0) + 1);\n      }\n    }\n  }\n\n  // set field to nullable if it is not referenced by all states\n  for (const [key, field] of fieldMap) {\n    if (field.nullable || refCount.get(key) === type.length) {\n      continue;\n    }\n\n    field.nullable = true;\n  }\n\n  return [...fieldMap.values()];\n};\n","import {\n  resolveDefer,\n  StateDefinition,\n  StateName,\n  StateDefintionScalar,\n} from '@/definitions';\nimport { NeuledgeError } from '@/index';\nimport { getScalarFields, MetadataStateField } from './field';\nimport {\n  generateStateHash,\n  StateSnapshot,\n  StateRelationSnapshot,\n} from './snapshot';\n\nconst METADATA_HASH_DEFAULT_FIELD = '__h';\nconst METADATA_VERSION_DEFAULT_FIELD = '__v';\n\nexport type MetadataStateContext = Partial<Record<StateName, MetadataState>>;\n\nexport interface MetadataStateReservedNames {\n  hash: string;\n  version: string;\n}\n\nexport interface MetadataStateRelation extends StateRelationSnapshot {\n  states: MetadataState[];\n  path: string;\n}\n\nexport class MetadataState extends StateSnapshot {\n  fields: MetadataStateField[];\n  instance: StateDefinition;\n  reservedNames: MetadataStateReservedNames;\n  relations: MetadataStateRelation[];\n  transforms: MetadataState[];\n\n  static fromDefinition = (\n    ctx: MetadataStateContext,\n    state: StateDefinition,\n    collectionName?: string,\n  ): MetadataState => {\n    let ref = ctx[state.$name];\n\n    if (!ref) {\n      // the constructor will add to context and handle circular references\n      ref = new MetadataState(ctx, state);\n    }\n\n    if (collectionName) {\n      ref.collectionName = collectionName;\n    }\n\n    return ref;\n  };\n\n  private constructor(ctx: MetadataStateContext, state: StateDefinition) {\n    super();\n\n    // add to context to handle circular references\n    ctx[state.$name] = this;\n\n    // init all properties before handling circular references\n    this.collectionName = state.$name;\n    this.name = state.$name;\n    this.hash = null as never;\n    this.fields = [];\n    this.instance = state;\n    this.reservedNames = {\n      hash: METADATA_HASH_DEFAULT_FIELD,\n      version: METADATA_VERSION_DEFAULT_FIELD,\n    };\n    this.relations = [];\n    this.transforms = [];\n\n    const scalars = Object.entries(resolveDefer(state.$scalars));\n    const transforms = resolveDefer(state.$transforms, []);\n\n    // assing fields\n    for (const [key, def] of scalars) {\n      const fields = getScalarFields(key, key, def);\n\n      for (const field of fields) {\n        if (\n          field.name === this.reservedNames.hash ||\n          field.name === this.reservedNames.version\n        ) {\n          throw new NeuledgeError(\n            NeuledgeError.Code.RESERVED_FIELD_NAME,\n            `State \"${this.name}\" has a scalar field named \"${field.name}\" which is reserved for internal use.`,\n          );\n        }\n      }\n\n      this.fields.push(...fields);\n    }\n\n    // assign relations\n    for (const [key, def] of scalars) {\n      this.relations.push(...getScalarRelations(ctx, key, def));\n    }\n\n    // assign transforms\n    for (const def of transforms) {\n      this.transforms.push(MetadataState.fromDefinition(ctx, def));\n    }\n\n    // generate hash after all properties are finalized\n    this.hash = generateStateHash(this);\n  }\n}\n\nconst getScalarRelations = (\n  ctx: MetadataStateContext,\n  key: string,\n  def: StateDefintionScalar,\n): MetadataStateRelation[] =>\n  Array.isArray(def.type)\n    ? [\n        {\n          name: key,\n          states: def.type.map((state) =>\n            MetadataState.fromDefinition(ctx, state),\n          ),\n          path: key,\n          index: def.index,\n        },\n      ]\n    : [];\n","import { Scalar } from '@neuledge/scalars';\nimport { MetadataChange } from './change';\nimport { StateSnapshot } from './state';\n\nconst HASH_KEY_ENCODING = 'base64url';\n\n/**\n * MetadataSnapshot is a snapshot of the metadata state at a given point in time\n * and provides a way to query the metadata state by hash, key, or type. It's\n * built from a list of snapshot states that may or may not exist in the codebase\n * anymore.\n */\nexport class MetadataSnapshot<S extends StateSnapshot = StateSnapshot> {\n  private readonly typeMap: Partial<Record<string, Scalar>>;\n  private readonly hashMap: Partial<Record<string, StateSnapshot | S>>;\n  private readonly keyMap: Partial<Record<string, S>>;\n\n  constructor(states: Iterable<S>) {\n    this.typeMap = {};\n    this.hashMap = {};\n    this.keyMap = {};\n\n    for (const entity of states) {\n      this.hashMap[entity.hash.toString(HASH_KEY_ENCODING)] = entity;\n\n      for (const { type } of entity.fields) {\n        if (this.typeMap[type.name] == null) {\n          this.typeMap[type.name] = type;\n        }\n      }\n\n      this.keyMap[entity.name] = entity;\n    }\n  }\n\n  get states(): S[] {\n    return Object.values(this.keyMap) as S[];\n  }\n\n  findType(key: string): Scalar | undefined {\n    return this.typeMap[key];\n  }\n\n  findStateByHash(hash: Buffer): StateSnapshot | undefined {\n    return this.hashMap[hash.toString(HASH_KEY_ENCODING)];\n  }\n\n  findStateByKey(key: string): S | undefined {\n    return this.keyMap[key];\n  }\n\n  sync(snapshot: MetadataSnapshot): MetadataChange[] {\n    const changes: MetadataChange[] = [];\n\n    for (const hashKey in snapshot.hashMap) {\n      const origin = snapshot.hashMap[hashKey];\n      if (!origin) continue;\n\n      let entity = this.hashMap[hashKey];\n      if (entity != null) {\n        // reuse original store names and continue\n        entity.sync(origin);\n        continue;\n      }\n\n      // we currently don't have an existing state instance for this hash, so\n      // either the use updated the state without keeping reference to the old\n      // version or the state was simply deleted.\n\n      entity = this.keyMap[origin.name];\n      const deleted = origin.clone();\n\n      if (entity != null) {\n        // we found another state with the same name, so the old state was\n        // probably renamed. we'll rename the old state to the new name and keep\n        // the old state around for backward compatibility.\n\n        if (entity.matches(origin)) {\n          entity.sync(origin);\n\n          this.hashMap[hashKey] = entity;\n          changes.push({ type: 'updated', entity, origin });\n        }\n\n        deleted.name = `${entity.name}_old`;\n\n        for (let i = 2; this.keyMap[deleted.name] != null; i += 1) {\n          deleted.name = `${entity.name}_old${i}`;\n        }\n      }\n\n      this.hashMap[hashKey] = deleted;\n    }\n\n    // search for new states that were added to the codebase since the last\n    // snapshot was taken.\n\n    for (const hashKey in this.hashMap) {\n      const entity = this.hashMap[hashKey];\n      if (!entity) continue;\n\n      const origin = snapshot.hashMap[hashKey];\n      if (origin) continue;\n\n      changes.push({ type: 'created', entity });\n    }\n\n    return changes;\n  }\n}\n","import { Metadata, MetadataCollection } from '@/metadata';\nimport { Store } from '@neuledge/store';\nimport pLimit from 'p-limit';\n\nexport const ensureStoreCollections = async (\n  store: Store,\n  metadata: Metadata,\n): Promise<void> => {\n  const asyncLimit = pLimit(1);\n\n  await Promise.all(\n    metadata.listCollections.map((collection) =>\n      asyncLimit(() => ensureStoreCollection(store, collection)),\n    ),\n  );\n};\n\nconst ensureStoreCollection = async (\n  store: Store,\n  collection: MetadataCollection,\n): Promise<void> => {\n  await store.ensureCollection({\n    collection,\n    indexes: Object.values(collection.indexes),\n    fields: Object.values(collection.fields),\n  });\n};\n","import { NeuledgeError } from '@/error';\nimport { MetadataChange, StateSnapshot, METADATA_HASH_BYTES } from '@/metadata';\nimport { MetadataSnapshot } from '@/metadata/snapshot';\nimport {\n  Store,\n  StoreCollection,\n  StoreField,\n  StoreList,\n  StorePrimaryKey,\n} from '@neuledge/store';\nimport pLimit from 'p-limit';\nimport {\n  fromStoreMetadataState,\n  StoreMetadataState,\n  toStoreMetadataState,\n} from './state';\n\nconst HASH_ENCODING = 'base64url';\nconst COLLECTION_FIND_LIMIT = 1000;\n\nexport const getMetadataCollection = (\n  metadataCollectionName: string,\n): StoreCollection => {\n  const hash: StoreField = {\n    name: 'hash',\n    type: 'binary',\n    size: METADATA_HASH_BYTES,\n  };\n\n  const primaryKey: StorePrimaryKey = {\n    name: 'hash',\n    fields: { [hash.name]: { sort: 'asc' } },\n    unique: 'primary',\n  };\n\n  return {\n    name: metadataCollectionName,\n    primaryKey,\n    indexes: { [primaryKey.name]: primaryKey },\n    fields: {\n      [hash.name]: hash,\n      key: { name: 'key', type: 'string' },\n      payload: { name: 'payload', type: 'json' },\n    },\n  };\n};\n\nexport const ensureMetadataCollection = async (\n  store: Store,\n  metadataCollection: StoreCollection,\n): Promise<void> => {\n  await store.ensureCollection({\n    collection: metadataCollection,\n    indexes: Object.values(metadataCollection.indexes),\n    fields: Object.values(metadataCollection.fields),\n  });\n};\n\nexport const getStoreMetadataSnapshot = async (\n  snapshot: MetadataSnapshot,\n  store: Store,\n  metadataCollection: StoreCollection,\n): Promise<MetadataSnapshot> => {\n  const entities: Record<string, StateSnapshot> = {};\n\n  const getState = (hash: Buffer) => {\n    const key = hash.toString(HASH_ENCODING);\n\n    let res = entities[key] as StateSnapshot | undefined;\n    if (!res) {\n      res = new StateSnapshot() as never;\n      entities[key] = res;\n    }\n\n    return res;\n  };\n\n  const getType = (key: string) => {\n    const type = snapshot.findType(key);\n    if (!type) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.CORRUPTED_METADATA,\n        `Can't find reference for type: ${key}`,\n      );\n    }\n\n    return type;\n  };\n\n  let res: StoreList | undefined;\n  do {\n    res = await store.find({\n      collection: metadataCollection,\n      limit: COLLECTION_FIND_LIMIT,\n      offset: res?.nextOffset,\n    });\n\n    for (const doc of res) {\n      if (!(doc.hash instanceof Buffer)) {\n        throw new NeuledgeError(\n          NeuledgeError.Code.CORRUPTED_METADATA,\n          `Invalid state document: ${doc.hash}`,\n        );\n      }\n\n      const state = doc as unknown as StoreMetadataState;\n\n      entities[state.hash.toString(HASH_ENCODING)] = fromStoreMetadataState(\n        getState,\n        getType,\n        state,\n      );\n    }\n  } while (res.length >= COLLECTION_FIND_LIMIT);\n\n  return new MetadataSnapshot(Object.values(entities));\n};\n\nexport const syncStoreMetadata = async (\n  store: Store,\n  metadataCollection: StoreCollection,\n  changes: MetadataChange[],\n): Promise<void> => {\n  const { inserts, updates } = getStoreMetadataChanges(changes);\n\n  if (inserts.length > 0) {\n    await store.insert({\n      collection: metadataCollection,\n      documents: inserts as never[],\n    });\n  }\n\n  if (updates.length > 0) {\n    const limit = pLimit(10);\n\n    await Promise.all(\n      updates.map(({ hash, ...set }) =>\n        limit(() =>\n          store.update({\n            collection: metadataCollection,\n            where: { hash: { $eq: hash } },\n            set: set as never,\n            limit: 1,\n          }),\n        ),\n      ),\n    );\n  }\n};\n\nconst getStoreMetadataChanges = (changes: MetadataChange[]) => {\n  const inserts: StoreMetadataState[] = [];\n  const updates: StoreMetadataState[] = [];\n\n  for (const change of changes) {\n    switch (change.type) {\n      case 'created': {\n        inserts.push(toStoreMetadataState(change.entity));\n        break;\n      }\n\n      case 'updated': {\n        updates.push(toStoreMetadataState(change.entity));\n        break;\n      }\n\n      default: {\n        throw new NeuledgeError(\n          NeuledgeError.Code.METADATA_SAVE_ERROR,\n          // @ts-expect-error change type is `never`\n          `Unknown metadata change type: ${change.type}`,\n        );\n      }\n    }\n  }\n\n  return { inserts, updates };\n};\n","import { NeuledgeError } from '@/error';\nimport {\n  StateSnapshot,\n  StateFieldSnapshot,\n  StateRelationSnapshot,\n} from '@/metadata';\n\nexport interface StoreMetadataState {\n  collectionName: string;\n  name: string;\n  hash: Buffer;\n  fields: StoreMetadataStateField[];\n  relations: StoreMetadataStateRelation[];\n  v: StoreMetadataStateVersion;\n}\n\nexport enum StoreMetadataStateVersion {\n  V0 = 0,\n}\n\ninterface StoreMetadataStateField {\n  name: string;\n  type: string;\n  indexes: number[];\n  nullable: boolean;\n}\n\ninterface StoreMetadataStateRelation {\n  name: string;\n  stateHashes: Buffer[];\n  index: number;\n}\n\nexport const fromStoreMetadataState = (\n  getState: (hash: Buffer) => StateSnapshot,\n  getType: (key: string) => StateFieldSnapshot['type'],\n  doc: StoreMetadataState,\n): StateSnapshot => {\n  if (doc.v !== StoreMetadataStateVersion.V0) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.UNSUPPORTED_METADATA,\n      `Unsupported metadata version: ${doc.v}`,\n    );\n  }\n\n  return getState(doc.hash).assign({\n    collectionName: doc.collectionName,\n    name: doc.name,\n    hash: doc.hash,\n    fields: doc.fields.map((field) =>\n      fromStoreMetadataStateField(getType, field),\n    ),\n    relations: doc.relations.map((relation) =>\n      fromStoreMetadataStateRelation(getState, relation),\n    ),\n  });\n};\n\nexport const toStoreMetadataState = (\n  state: StateSnapshot,\n): StoreMetadataState => ({\n  collectionName: state.collectionName,\n  name: state.name,\n  hash: state.hash,\n  fields: state.fields.map((field) => toStoreMetadataStateField(field)),\n  relations: state.relations.map((relation) =>\n    toStoreMetadataStateRelation(relation),\n  ),\n  v: StoreMetadataStateVersion.V0,\n});\n\nconst fromStoreMetadataStateField = (\n  getType: (key: string) => StateFieldSnapshot['type'],\n  doc: StoreMetadataStateField,\n): StateFieldSnapshot => ({\n  name: doc.name,\n  type: getType(doc.type),\n  indexes: doc.indexes,\n  nullable: doc.nullable,\n});\n\nconst toStoreMetadataStateField = (\n  field: StateFieldSnapshot,\n): StoreMetadataStateField => ({\n  name: field.name,\n  type: field.type.name,\n  indexes: [...field.indexes],\n  nullable: field.nullable,\n});\n\nconst fromStoreMetadataStateRelation = (\n  getState: (hash: Buffer) => StateSnapshot,\n  relation: StoreMetadataStateRelation,\n): StateRelationSnapshot => ({\n  name: relation.name,\n  states: relation.stateHashes.map((hash) => getState(hash)),\n  index: relation.index,\n});\n\nconst toStoreMetadataStateRelation = (\n  relation: StateRelationSnapshot,\n): StoreMetadataStateRelation => ({\n  name: relation.name,\n  stateHashes: relation.states.map((state) => state.hash),\n  index: relation.index,\n});\n","export * from './init';\nexport * from './find';\nexport * from './alter';\n","import { MutationDefinition, StateDefinition } from '@/definitions';\nimport { Entity, ProjectedEntity, InitiatedEntity } from '@/entity';\nimport { NeuledgeError } from '@/error';\nimport { EntityList } from '@/list';\nimport { InitManyQueryOptions, InitOneQueryOptions, Select } from '@/queries';\nimport { chooseStatesCollection } from '../collection';\nimport { toDocument } from '../document';\nimport { NeuledgeEngine } from '../engine';\nimport { toEntityOrThrow } from '../entity';\nimport { retrieveEntities } from '../relations';\n\nexport const execInitMany = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: InitManyQueryOptions<S, S> | InitOneQueryOptions<S, S>,\n): Promise<\n  EntityList<Entity<S>> | EntityList<ProjectedEntity<S, Select<S>>> | void\n> => {\n  const metadata = await engine.metadata;\n  const { collection } = chooseStatesCollection(metadata, options.states);\n\n  const [state] = options.states;\n  const fn = state[options.method] as MutationDefinition<S> | undefined;\n\n  if (fn?.mutation !== 'create') {\n    throw new NeuledgeError(\n      NeuledgeError.Code.INVALID_MUTATION,\n      `Mutation ${String(options.method)} is not an init mutation`,\n    );\n  }\n\n  const newEntities: InitiatedEntity<S>[] = await Promise.all(\n    options.args.map((args) => fn(args)),\n  );\n\n  const entities = newEntities.map(\n    (entity): Entity<S> => ({\n      ...(entity as InitiatedEntity<StateDefinition>),\n      $version: 0,\n    }),\n  );\n\n  const documents = entities.map((entity) =>\n    toDocument(metadata, collection, entity),\n  );\n\n  const { insertedIds } = await engine.store.insert({\n    collection,\n    documents,\n  });\n\n  const updatedEntities = documents.map((oldDoc, i) => {\n    const document = { ...oldDoc, ...insertedIds[i] };\n    const entity = toEntityOrThrow(metadata, collection, document);\n\n    return { entity, document, oldEntity: null };\n  });\n\n  return retrieveEntities(updatedEntities, options);\n};\n\nexport const execInitOne = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: InitOneQueryOptions<S, S>,\n): Promise<Entity<S> | ProjectedEntity<S, Select<S>> | void> => {\n  const res = await execInitMany(engine, options);\n  return res && res[0];\n};\n","import { resolveDefer, StateDefinition } from '@/definitions';\nimport { NeuledgeError } from '@/error';\nimport { Metadata, MetadataCollection, MetadataState } from '@/metadata';\n\nexport const chooseStatesCollection = <S extends StateDefinition>(\n  metadata: Metadata,\n  states: S[],\n): { collection: MetadataCollection; states: MetadataState[] } => {\n  const collections = metadata.getCollections(states);\n\n  if (collections.length !== 1) {\n    if (!collections.length) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.NO_COLLECTIONS,\n        `No collections found for ${states.length} states`,\n      );\n    }\n\n    throw new NeuledgeError(\n      NeuledgeError.Code.MULTIPLE_COLLECTIONS,\n      `Engine operations can only be used with one collection, got request for ${\n        collections.length\n      } collections: ${collections.map((c) => c.name).join(', ')}`,\n    );\n  }\n\n  const collection = collections[0];\n\n  const stateNames = new Set(states.map((s) => s.$name));\n  const collectionStates = collection.states.filter((s) =>\n    stateNames.has(s.name),\n  );\n\n  return { collection, states: collectionStates };\n};\n\nexport const getCollectionRelationStates = (\n  collection: MetadataCollection,\n  key: string,\n): StateDefinition[] => [\n  ...new Map(\n    collection.states\n      .flatMap((s) => {\n        const relations = resolveDefer(s.instance.$relations, {})[key];\n        if (!relations) {\n          return [];\n        }\n\n        return relations.states;\n      })\n      .map((s) => [s.$name, s]),\n  ).values(),\n];\n","import { StateDefinition } from '@/definitions';\nimport { Entity } from '@/entity';\nimport { NeuledgeError } from '@/error';\nimport { Metadata, MetadataCollection } from '@/metadata';\nimport { StoreDocument, StoreScalarValue } from '@neuledge/store';\n\nexport const toDocument = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  entity: Entity<S>,\n): StoreDocument => {\n  const { $state, $version } = entity as Entity<StateDefinition>;\n\n  const state = metadata.findStateByKey($state);\n  if (!state) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.ENTITY_STATE_NOT_FOUND,\n      `State metadata not found: ${$state}`,\n    );\n  }\n\n  const document: StoreDocument = {\n    [collection.reservedNames.hash]: state.hash,\n    [collection.reservedNames.version]: $version,\n  };\n\n  for (const field of state.fields) {\n    document[field.name] = getEntityValue(entity, field.path);\n  }\n\n  return document;\n};\n\nconst getEntityValue = (\n  obj: object,\n  path: string,\n): StoreScalarValue | undefined => {\n  const pathKeys = path.split('.');\n  let value = obj as StoreScalarValue;\n\n  for (const key of pathKeys) {\n    if (typeof value !== 'object' || value === null) {\n      return undefined;\n    }\n\n    value = (value as Record<string, StoreScalarValue>)[key];\n  }\n\n  return value;\n};\n","import { Entity } from '@/entity';\nimport { StateDefinition } from '@/definitions';\nimport { EntityList } from '@/list';\nimport { Metadata } from '@/metadata/metadata';\nimport { StoreDocument, StoreList } from '@neuledge/store';\n\nimport { MetadataCollection } from '@/metadata';\nimport { NeuledgeError } from '@/error';\n\nexport const toEntityList = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  list: StoreList,\n): EntityList<Entity<S>> =>\n  Object.assign(\n    list\n      .map((document) => {\n        const stateHash = document[collection.reservedNames.hash];\n\n        return Buffer.isBuffer(stateHash)\n          ? getStateEntity<S>(metadata, collection, stateHash, document)\n          : undefined;\n      })\n      .filter((entity): entity is Entity<S> => entity !== undefined),\n    { nextOffset: list.nextOffset },\n  );\n\nexport const toEntityListOrThrow = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  list: StoreList,\n): EntityList<Entity<S>> => {\n  const entities = toEntityList(metadata, collection, list);\n\n  if (!entities.length) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.DOCUMENT_NOT_FOUND,\n      'Document not found',\n    );\n  }\n\n  return entities;\n};\n\nexport const toMaybeEntity = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  document: StoreDocument | undefined,\n): Entity<S> | null => {\n  const stateHash = document?.[collection.reservedNames.hash];\n\n  return Buffer.isBuffer(stateHash)\n    ? getStateEntity<S>(\n        metadata,\n        collection,\n        stateHash,\n        document as StoreDocument,\n      )\n    : null;\n};\n\nexport const toEntityOrThrow = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  document: StoreDocument | undefined,\n): Entity<S> => {\n  const stateHash = document?.[collection.reservedNames.hash];\n\n  if (!Buffer.isBuffer(stateHash)) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.DOCUMENT_NOT_FOUND,\n      'Document not found',\n    );\n  }\n\n  return getStateEntity<S>(\n    metadata,\n    collection,\n    stateHash,\n    document as StoreDocument,\n  );\n};\n\nconst getStateEntity = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  stateHash: Buffer,\n  document: StoreDocument,\n): Entity<S> => {\n  const state = metadata.findStateByHash(stateHash);\n  if (!state) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.ENTITY_STATE_NOT_FOUND,\n      `Entity state not found: ${stateHash.toString('base64')}`,\n    );\n  }\n\n  const entity = {\n    $state: state.name,\n    $version: document[collection.reservedNames.version] ?? 0,\n  } as Entity<S>;\n\n  for (const field of state.fields) {\n    if (!(field.name in document) || !field.path) continue;\n\n    const rawValue = document[field.name];\n    const value = field.type.decode ? field.type.decode(rawValue) : rawValue;\n\n    setEntityValue(entity, field.path, value);\n  }\n\n  for (const relation of state.relations) {\n    if (!relation.path) continue;\n\n    const childDocument = document[relation.name] as StoreDocument | undefined;\n    if (childDocument == null) continue;\n\n    const childStateHash = childDocument[collection.reservedNames.hash];\n    if (!Buffer.isBuffer(childStateHash)) continue;\n\n    const childEntity = getStateEntity(\n      metadata,\n      collection,\n      childStateHash,\n      childDocument,\n    );\n\n    setEntityValue(entity, relation.path, childEntity);\n  }\n\n  return entity;\n};\n\nconst setEntityValue = (obj: object, path: string, value: unknown): void => {\n  const pathKeys = path.split('.');\n\n  for (let i = 0; i < pathKeys.length - 1; i += 1) {\n    const key = pathKeys[i];\n\n    obj =\n      key in obj\n        ? (obj[key as never] as object)\n        : (obj[key as never] = {} as never);\n  }\n\n  obj[pathKeys[pathKeys.length - 1] as never] = value as never;\n};\n","export * from './expand';\nexport * from './match';\nexport * from './populate';\nexport * from './retrieve';\n","import { StoreFindOptions, StoreJoin } from '@neuledge/store';\nimport { StateDefinition } from '@/definitions';\nimport { Metadata, MetadataCollection } from '@/metadata';\nimport { ExpandQueryOptions } from '@/queries';\nimport { convertRelationQueryOptions } from './relation';\nimport { convertFilterQuery } from '../find';\nimport { convertJoinSelectQuery } from '../select';\nimport { convertPopulateOneQuery } from './populate';\n\nexport const convertExpandQuery = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  { expand }: ExpandQueryOptions<S>,\n): Pick<StoreFindOptions, 'innerJoin'> => ({\n  ...(expand == null\n    ? null\n    : { innerJoin: convertExpand(metadata, collection, expand) }),\n});\n\nconst convertExpand = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  expand: NonNullable<ExpandQueryOptions<S>['expand']>,\n): StoreJoin =>\n  convertRelationQueryOptions(\n    metadata,\n    collection,\n    expand,\n    ({ collection, by, query }) => ({\n      collection,\n      by,\n      ...convertJoinSelectQuery(collection, query),\n      ...convertFilterQuery(collection.states, collection, query),\n      ...convertExpandQuery(metadata, collection, query),\n      ...convertPopulateOneQuery(metadata, collection, query),\n    }),\n  );\n","import { StoreJoin, StoreJoinBy, StoreJoinChoice } from '@neuledge/store';\nimport {\n  Metadata,\n  MetadataCollection,\n  MetadataState,\n  MetadataStateField,\n} from '@/metadata';\nimport { NeuledgeError } from '@/error';\nimport {\n  resolveDefer,\n  StateDefinition,\n  StateDefinitionRelation,\n} from '@/definitions';\n\ninterface RelationOptions<T extends { states?: StateDefinition[] | null }> {\n  collection: MetadataCollection;\n  by: StoreJoinBy;\n  query: T;\n}\n\n/**\n * Convert relation query options to store join options.\n * This function designed to be used with query match, populate, expand, etc.\n */\nexport const convertRelationQueryOptions = <\n  T extends { [key in string]?: { states?: StateDefinition[] | null } },\n  R extends StoreJoinChoice,\n>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  relationQueries: T,\n  convert: (relation: RelationOptions<NonNullable<T[keyof T]>>) => R,\n): StoreJoin<R> => {\n  const res: Record<string, R[]> = {};\n\n  // resolve all the states relations defer for later use\n  const statesRelations = collection.states.map((state) =>\n    resolveDefer(state.instance.$relations, {}),\n  );\n\n  for (const key in relationQueries) {\n    const query = relationQueries[key];\n    if (query == null) continue;\n\n    const referenceCollectionMap = getRelationReferenceCollections(\n      metadata,\n      collection.states,\n      statesRelations.map(\n        (stateRelations) => stateRelations[key] ?? { states: [] },\n      ),\n      key,\n      query.states,\n    );\n\n    const values: R[] = [];\n\n    for (const [reference, collectionMap] of referenceCollectionMap) {\n      for (const [targerCollection, refCollections] of collectionMap) {\n        const fields = targerCollection.getSchemaFields(reference);\n\n        values.push(\n          ...refCollections.map((relCollection) => {\n            const reverse = relCollection === collection;\n\n            return convert({\n              collection: reverse ? targerCollection : relCollection,\n              by: getStoreJoinBy(reference, fields, relCollection, reverse),\n              query,\n            });\n          }),\n        );\n      }\n    }\n\n    res[key] = values;\n  }\n\n  return res;\n};\n\n/**\n * Get relation reference collections.\n * For each reference field, it gets the source collection and all the other\n * collections that was referenced by this field. For example, if we have an\n * entity `Post` with the field `post.user`, then the result will be:\n *\n * ```ts\n * {\n *  'user': {\n *   [PostsCollection]: [UsersCollection]\n * }\n * ```\n *\n * The same result will apply for the reverse relation. Ie, if we have an\n * entity `User` with the field `user.posts`, then the result will be the same,\n * as the relation stored in the `post.user` field.\n */\nconst getRelationReferenceCollections = (\n  metadata: Metadata,\n  states: MetadataState[],\n  stateRelations: StateDefinitionRelation[],\n  key: string,\n  queryStates?: StateDefinition[] | null,\n): Map<string, Map<MetadataCollection, MetadataCollection[]>> => {\n  const res = new Map<string, Map<MetadataCollection, MetadataCollection[]>>();\n\n  for (const [i, state] of states.entries()) {\n    const stateRelation = stateRelations[i];\n    if (!stateRelation.states.length) continue;\n\n    const path = stateRelation.reference ?? key;\n\n    let entry = res.get(path);\n    if (!entry) {\n      entry = new Map();\n      res.set(path, entry);\n    }\n\n    let relStates;\n    if (queryStates) {\n      const queryStatesMap = new Map(\n        queryStates.map((state) => [state.$name, state]),\n      );\n\n      relStates = stateRelation.states.filter(\n        (state) => queryStatesMap.get(state.$name) === state,\n      );\n\n      if (relStates.length !== queryStates.length) {\n        throw new NeuledgeError(\n          NeuledgeError.Code.RELATION_STATE_NOT_FOUND,\n          `Could not find matching states for '${key}': ${queryStates\n            .map((state) => state.$name)\n            .join(', ')}`,\n        );\n      }\n    } else {\n      relStates = stateRelation.states;\n    }\n\n    let collections = [metadata.getCollectionByMetadataState(state)];\n    let relCollections = metadata.getCollections(relStates);\n\n    if (stateRelation.reference) {\n      [collections, relCollections] = [relCollections, collections];\n    }\n\n    for (const collection of collections) {\n      entry.set(collection, relCollections);\n    }\n  }\n\n  return res;\n};\n\n/**\n * Get store join by object from relation fields.\n * Receives the relation key and all the fields that are part of the relation in\n * the current collection. Then it tries to find the matching fields in the\n * related collection. If it fails, it throws an error.\n */\nconst getStoreJoinBy = (\n  reference: string,\n  fields: MetadataStateField[],\n  relCollection: MetadataCollection,\n  reverse: boolean,\n): StoreJoinBy => {\n  const res: StoreJoinBy = {};\n\n  const fieldMap = new Map(\n    fields.map((field) => [field.path.slice(reference.length + 1), field]),\n  );\n\n  for (const state of relCollection.states) {\n    for (const refField of state.fields) {\n      const field = fieldMap.get(refField.path);\n      if (!field) continue;\n\n      if (reverse) {\n        res[field.name] = { field: refField.name };\n      } else {\n        res[refField.name] = { field: field.name };\n      }\n\n      fieldMap.delete(refField.path);\n\n      if (!fieldMap.size) {\n        return res;\n      }\n    }\n  }\n\n  throw new NeuledgeError(\n    NeuledgeError.Code.RELATION_FIELD_NOT_FOUND,\n    `Could not find matching fields for '${reference}': ${[\n      ...fieldMap.keys(),\n    ].join(', ')}`,\n  );\n};\n","export * from './where';\nexport * from './unique';\n","import { StateDefinition, StateDefinitionWhereRecord } from '@/definitions';\nimport { MetadataCollection, MetadataState } from '@/metadata';\nimport {\n  StoreFindOptions,\n  StoreWhere,\n  StoreWhereRecord,\n} from '@neuledge/store';\nimport {\n  Filter,\n  FilterQueryOptions,\n  Where,\n  WhereQueryOptions,\n} from '@/queries';\nimport { convertWhereRecord } from './record';\nimport { applyFilter } from './filter';\n\nexport const convertWhereFilterQuery = <S extends StateDefinition>(\n  states: MetadataState[],\n  collection: MetadataCollection,\n  { where, filter }: WhereQueryOptions<S> & FilterQueryOptions<S>,\n): Pick<StoreFindOptions, 'where'> => ({\n  where: convertWhereFilter(states, collection, where, filter),\n});\n\nexport const convertFilterQuery = <S extends StateDefinition>(\n  states: MetadataState[],\n  collection: MetadataCollection,\n  { filter }: FilterQueryOptions<S>,\n): Pick<StoreFindOptions, 'where'> => ({\n  where: convertWhereFilter(states, collection, null, filter),\n});\n\nconst convertWhereFilter = <S extends StateDefinition>(\n  states: MetadataState[],\n  collection: MetadataCollection,\n  where: Where<S> | null | undefined,\n  filter: Filter<S> | null | undefined,\n): StoreWhere => {\n  let res = convertWhere(states, collection, where);\n\n  if (filter != null) {\n    res = applyFilter(res, collection, filter);\n  }\n\n  return res.length === 1 ? res[0] : { $or: res };\n};\n\nconst convertWhere = <S extends StateDefinition>(\n  states: MetadataState[],\n  collection: MetadataCollection,\n  where: Where<S> | null | undefined,\n): StoreWhereRecord[] =>\n  where && Array.isArray(where.$or)\n    ? where.$or.flatMap((w: StateDefinitionWhereRecord) =>\n        convertWhereRecord(states, collection, w),\n      )\n    : convertWhereRecord(\n        states,\n        collection,\n        where as StateDefinitionWhereRecord,\n      );\n","import {\n  StateDefinitionWhereRecord,\n  StateDefinitionWhereTerm,\n} from '@/definitions';\nimport { NeuledgeError } from '@/error';\nimport { MetadataCollection, MetadataSchema, MetadataState } from '@/metadata';\nimport { StoreWhereRecord } from '@neuledge/store';\nimport { applyWhereOperatorTerm, applyWhereRecordTerm } from './term';\n\nexport const convertWhereRecord = (\n  states: MetadataState[],\n  collection: MetadataCollection,\n  where: StateDefinitionWhereRecord | null,\n): StoreWhereRecord[] =>\n  applyFilterRecord(\n    [\n      {\n        [collection.reservedNames.hash]: {\n          $in: states.map((s) => s.hash),\n        },\n      },\n    ],\n    collection,\n    where,\n  );\n\nexport const applyFilterRecord = (\n  records: StoreWhereRecord[],\n  collection: MetadataCollection,\n  filter: StateDefinitionWhereRecord | null,\n): StoreWhereRecord[] => {\n  for (const [key, term] of Object.entries(filter ?? {})) {\n    if (term == null) continue;\n\n    const choices = collection.schema[key] ?? [];\n    if (!choices?.length) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_PARSING_ERROR,\n        `Unknown where key: '${key}'`,\n      );\n    }\n\n    const base = records;\n    records = [];\n\n    for (const choice of choices) {\n      records.push(\n        ...(choice.field\n          ? applyWhereRecordTerm(base, choice.field, term)\n          : applyWhereState(base, choice.schema, term)),\n      );\n    }\n  }\n\n  return records;\n};\n\nconst applyWhereState = (\n  records: StoreWhereRecord[],\n  schema: MetadataSchema,\n  term: StateDefinitionWhereTerm,\n): StoreWhereRecord[] => {\n  for (const [operator, where] of Object.entries(term)) {\n    if (typeof where !== 'object' || where == null) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_PARSING_ERROR,\n        `Invalid where operator: '${operator}'`,\n      );\n    }\n\n    records = applyWhereOperatorRecord(records, schema, operator, where);\n  }\n\n  return records;\n};\n\nconst applyWhereOperatorRecord = (\n  records: StoreWhereRecord[],\n  schema: MetadataSchema,\n  operator: string,\n  where: object,\n): StoreWhereRecord[] => {\n  switch (operator) {\n    case '$eq':\n    case '$gt':\n    case '$gte':\n    case '$lt':\n    case '$lte':\n    case '$contains':\n    case '$startsWith':\n    case '$endsWith': {\n      return applyWhereEveryOperatorRecord(records, schema, operator, where);\n    }\n\n    case '$ne': {\n      return applyWhereNotEqualRecord(records, schema, where);\n    }\n\n    case '$in': {\n      return applyWhereInOperatorRecord(records, schema, where);\n    }\n\n    case '$nin': {\n      return applyWhereNotInOperatorRecord(records, schema, where);\n    }\n\n    default: {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_PARSING_ERROR,\n        `Invalid operator: ${operator}`,\n      );\n    }\n  }\n};\n\nconst applyWhereEveryOperatorRecord = (\n  records: StoreWhereRecord[],\n  schema: MetadataSchema,\n  operator: string,\n  where: object,\n) => {\n  for (const [key, value] of Object.entries(where)) {\n    records = applyWhereOperatorRecordValue(\n      records,\n      schema,\n      operator,\n      key,\n      value,\n    );\n  }\n\n  return records;\n};\n\nconst applyWhereNotEqualRecord = (\n  records: StoreWhereRecord[],\n  schema: MetadataSchema,\n  where: object,\n) => {\n  let base = records;\n  const res = [];\n\n  for (const [key, value] of Object.entries(where)) {\n    res.push(...applyWhereOperatorRecordValue(base, schema, '$ne', key, value));\n\n    base = applyWhereOperatorRecordValue(base, schema, '$eq', key, value);\n  }\n\n  return res;\n};\n\nconst applyWhereInOperatorRecord = (\n  records: StoreWhereRecord[],\n  schema: MetadataSchema,\n  where: object,\n) => {\n  if (!Array.isArray(where)) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.QUERY_PARSING_ERROR,\n      `Invalid where operator: '$in'`,\n    );\n  }\n\n  const res = [];\n  for (const value of where) {\n    res.push(...applyWhereEveryOperatorRecord(records, schema, '$eq', value));\n  }\n\n  return res;\n};\n\nconst applyWhereNotInOperatorRecord = (\n  records: StoreWhereRecord[],\n  schema: MetadataSchema,\n  where: object,\n) => {\n  if (!Array.isArray(where)) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.QUERY_PARSING_ERROR,\n      `Invalid where operator: '$nin'`,\n    );\n  }\n\n  for (const value of where) {\n    records = applyWhereNotEqualRecord(records, schema, value);\n  }\n\n  return records;\n};\n\nconst applyWhereOperatorRecordValue = (\n  records: StoreWhereRecord[],\n  schema: MetadataSchema,\n  operator: string,\n  key: string,\n  value: unknown,\n): StoreWhereRecord[] => {\n  const choices = Object.values(schema[key] ?? {});\n  if (!choices?.length) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.QUERY_PARSING_ERROR,\n      `Unknown where key: '${key}'`,\n    );\n  }\n\n  const res = [];\n\n  for (const choice of choices) {\n    if (choice.field) {\n      res.push(\n        ...applyWhereOperatorTerm(\n          records,\n          choice.field.name,\n          choice.field.type,\n          operator,\n          value,\n        ),\n      );\n    } else if (typeof value === 'object' && value != null) {\n      res.push(\n        ...applyWhereOperatorRecord(records, choice.schema, operator, value),\n      );\n    } else {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_PARSING_ERROR,\n        `Invalid where operator: '${operator}'`,\n      );\n    }\n  }\n\n  return res;\n};\n","import { Scalar } from '@neuledge/scalars';\nimport equal from 'fast-deep-equal/es6';\nimport { StateDefinitionWhereTerm } from '@/definitions';\nimport { StoreWhereRecord, StoreWhereTerm } from '@neuledge/store';\nimport { NeuledgeError } from '@/error';\nimport { MetadataStateField } from '@/metadata';\n\nexport const applyWhereRecordTerm = (\n  records: StoreWhereRecord[],\n  field: MetadataStateField,\n  term: StateDefinitionWhereTerm,\n): StoreWhereRecord[] => {\n  const res = records.map((record) => ({ ...record }));\n\n  for (const record of res) {\n    if (record[field.name] == null) {\n      record[field.name] = convertWhereScalarTerm(field.type, term);\n    } else {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_PARSING_ERROR,\n        `Duplicate where key: '${field.path}'`,\n      );\n    }\n  }\n\n  return res;\n};\n\nconst convertWhereScalarTerm = (\n  scalar: Scalar,\n  term: StateDefinitionWhereTerm,\n): StoreWhereTerm => {\n  const res = {} as StoreWhereTerm;\n\n  for (const [operator, value] of Object.entries(term)) {\n    assignWhereScalarOperator(res, scalar, operator, value);\n  }\n\n  return res;\n};\n\nexport const applyWhereOperatorTerm = (\n  records: StoreWhereRecord[],\n  key: string,\n  scalar: Scalar,\n  operator: string,\n  value: unknown,\n): StoreWhereRecord[] => {\n  const res = [];\n\n  for (const origin of records) {\n    const record = { ...origin };\n    const scalarValue = scalar.encode(value);\n\n    if (record[key] == null) {\n      record[key] = {\n        [operator]: scalarValue,\n      } as StoreWhereTerm;\n    } else {\n      const term = { ...record[key] } as never as Record<string, unknown>;\n      record[key] = term as never;\n\n      if (operator === '$ne') {\n        if ('$eq' in term) {\n          if (equal(term.$eq, scalarValue)) {\n            // skip conflicts\n            continue;\n          }\n\n          // else, ignore $ne if $eq is present\n        } else if (Array.isArray(term.$nin)) {\n          term.$nin = [...term.$nin, scalarValue];\n        } else if ('$ne' in term) {\n          term.$nin = [term.$ne, scalarValue];\n          delete term.$ne;\n        } else {\n          term.$ne = scalarValue;\n        }\n      } else if (!(operator in term)) {\n        term[operator] = scalarValue;\n\n        if (operator === '$eq') {\n          delete term.$ne;\n        }\n      } else if (!equal(term[operator], scalarValue)) {\n        // skip conflicts\n        continue;\n      }\n    }\n\n    res.push(record);\n  }\n\n  return res;\n};\n\nconst assignWhereScalarOperator = (\n  res: StoreWhereTerm,\n  scalar: Scalar,\n  operator: string,\n  value: unknown,\n): void => {\n  switch (operator) {\n    case '$eq':\n    case '$ne':\n    case '$gt':\n    case '$gte':\n    case '$lt':\n    case '$lte':\n    case '$contains':\n    case '$startsWith':\n    case '$endsWith': {\n      res[operator as never] = (\n        value == null ? null : scalar.encode(value)\n      ) as never;\n      break;\n    }\n\n    case '$in':\n    case '$nin': {\n      if (!Array.isArray(value)) {\n        throw new NeuledgeError(\n          NeuledgeError.Code.QUERY_PARSING_ERROR,\n          `Expected array for '${operator}' operator`,\n        );\n      }\n\n      res[operator as never] = value.map((v) =>\n        v == null ? null : scalar.encode(v),\n      ) as never;\n      break;\n    }\n\n    default: {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_PARSING_ERROR,\n        `Invalid operator: ${operator}`,\n      );\n    }\n  }\n};\n","import { StateDefinition, StateDefinitionWhereRecord } from '@/definitions';\nimport { MetadataCollection } from '@/metadata';\nimport { StoreWhereRecord } from '@neuledge/store';\nimport { Filter } from '@/queries';\nimport { applyFilterRecord } from './record';\n\nexport const applyFilter = <S extends StateDefinition>(\n  records: StoreWhereRecord[],\n  collection: MetadataCollection,\n  filter: Filter<S>,\n): StoreWhereRecord[] =>\n  Array.isArray(filter.$or)\n    ? filter.$or.flatMap((w: StateDefinitionWhereRecord) =>\n        applyFilterRecord(records, collection, w),\n      )\n    : applyFilterRecord(\n        records,\n        collection,\n        filter as StateDefinitionWhereRecord,\n      );\n","import { StateDefinition, StateDefinitionWhereRecord } from '@/definitions';\nimport { NeuledgeError } from '@/error';\nimport { MetadataCollection, MetadataState } from '@/metadata';\nimport { Filter, FilterQueryOptions, UniqueQueryOptions } from '@/queries';\nimport {\n  StoreFindOptions,\n  StoreWhere,\n  StoreWhereRecord,\n} from '@neuledge/store';\nimport { applyFilter } from './filter';\nimport { applyWhereRecordTerm } from './term';\n\nexport const convertUniqueFilterQuery = <S extends StateDefinition>(\n  states: MetadataState[],\n  collection: MetadataCollection,\n  { unique, filter }: UniqueQueryOptions<S> & FilterQueryOptions<S>,\n): Pick<StoreFindOptions, 'where'> => ({\n  where: convertUniqueFilter(states, collection, unique, filter),\n});\n\nconst convertUniqueFilter = <S extends StateDefinition>(\n  states: MetadataState[],\n  collection: MetadataCollection,\n  unique: StateDefinitionWhereRecord | true,\n  filter: Filter<S> | null | undefined,\n): StoreWhere => {\n  let res = convertUnique(states, collection, unique);\n\n  if (filter != null) {\n    res = applyFilter(res, collection, filter);\n  }\n\n  return res.length === 1 ? res[0] : { $or: res };\n};\n\nconst convertUnique = (\n  states: MetadataState[],\n  collection: MetadataCollection,\n  unique: StateDefinitionWhereRecord | true,\n): StoreWhereRecord[] => {\n  if (unique === true) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.QUERY_EXECUTION_ERROR,\n      `This query is not executable`,\n    );\n  }\n\n  let records: StoreWhereRecord[] = [\n    {\n      [collection.reservedNames.hash]: {\n        $in: states.map((s) => s.hash),\n      },\n    },\n  ];\n\n  for (const [key, value] of Object.entries(unique)) {\n    const choices = collection.schema[key] ?? [];\n    if (!choices?.length) {\n      throw new NeuledgeError(\n        NeuledgeError.Code.QUERY_PARSING_ERROR,\n        `Unknown unique key: '${key}'`,\n      );\n    }\n\n    const base = records;\n    records = [];\n\n    for (const choice of choices) {\n      if (!choice.field) {\n        throw new NeuledgeError(\n          NeuledgeError.Code.QUERY_PARSING_ERROR,\n          `Unknown unique scalar: '${key}'`,\n        );\n      }\n\n      records.push(...applyWhereRecordTerm(base, choice.field, { $eq: value }));\n    }\n  }\n\n  return records;\n};\n","import { StateDefinition } from '@/definitions';\nimport { MetadataCollection } from '@/metadata';\nimport { Select, SelectQueryOptions } from '@/queries';\nimport {\n  StoreFindOptions,\n  StoreJoinChoice,\n  StoreLeftJoinChoice,\n  StoreSelect,\n} from '@neuledge/store';\n\nexport const convertSelectQuery = <S extends StateDefinition>(\n  collection: MetadataCollection,\n  { select }: SelectQueryOptions<S>,\n): Pick<StoreFindOptions, 'select'> => ({\n  ...(select != null && select !== true\n    ? { select: convertSelect(collection, select) }\n    : null),\n});\n\nexport const convertJoinSelectQuery = <S extends StateDefinition>(\n  collection: MetadataCollection,\n  { select }: SelectQueryOptions<S>,\n): Pick<StoreJoinChoice, 'select'> => ({\n  ...(select == null\n    ? null\n    : { select: select === true ? true : convertSelect(collection, select) }),\n});\n\nexport const convertLeftJoinSelectQuery = <S extends StateDefinition>(\n  collection: MetadataCollection,\n  { select }: SelectQueryOptions<S>,\n): Pick<StoreLeftJoinChoice, 'select'> => ({\n  select:\n    select != null && select !== true\n      ? convertSelect(collection, select)\n      : true,\n});\n\nconst convertSelect = <S extends StateDefinition>(\n  collection: MetadataCollection,\n  select: Select<S>,\n): StoreSelect => {\n  const res: StoreSelect = {\n    [collection.reservedNames.hash]: true,\n    [collection.reservedNames.version]: true,\n  };\n\n  for (const key in select) {\n    if (!select[key]) continue;\n\n    for (const fieldName of collection.getSchemaFieldNames(key)) {\n      res[fieldName] = true;\n    }\n  }\n\n  return res;\n};\n","import { StoreFindOptions, StoreLeftJoin } from '@neuledge/store';\nimport { StateDefinition } from '@/definitions';\nimport { Metadata, MetadataCollection } from '@/metadata';\nimport { PopulateQueryOptions } from '@/queries';\nimport { convertRelationQueryOptions } from './relation';\nimport { convertLeftJoinSelectQuery } from '../select';\nimport { convertFilterQuery } from '../find';\nimport { convertExpandQuery } from './expand';\n\nexport const convertPopulateOneQuery = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  { populateOne }: PopulateQueryOptions<S>,\n): Pick<StoreFindOptions, 'leftJoin'> => ({\n  ...(populateOne == null\n    ? null\n    : { leftJoin: convertPopulateOne(metadata, collection, populateOne) }),\n});\n\nconst convertPopulateOne = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  populateOne: NonNullable<PopulateQueryOptions<S>['populateOne']>,\n): StoreLeftJoin =>\n  convertRelationQueryOptions(\n    metadata,\n    collection,\n    populateOne,\n    ({ collection, by, query }) => ({\n      collection,\n      by,\n      ...convertLeftJoinSelectQuery(collection, query),\n      ...convertFilterQuery(collection.states, collection, query),\n      ...convertExpandQuery(metadata, collection, query),\n      ...convertPopulateOneQuery(metadata, collection, query),\n    }),\n  );\n","import { StateDefinition } from '@/definitions';\nimport { Metadata, MetadataCollection } from '@/metadata';\nimport { MatchQueryOptions } from '@/queries';\nimport { StoreFindOptions, StoreJoin } from '@neuledge/store';\nimport { convertFilterQuery } from '../find';\nimport { convertRelationQueryOptions } from './relation';\n\nexport const convertMatchQuery = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  { match }: MatchQueryOptions<S>,\n): Pick<StoreFindOptions, 'innerJoin'> => ({\n  ...(match == null\n    ? null\n    : { innerJoin: convertMatch(metadata, collection, match) }),\n});\n\nconst convertMatch = <S extends StateDefinition>(\n  metadata: Metadata,\n  collection: MetadataCollection,\n  match: NonNullable<MatchQueryOptions<S>['match']>,\n): StoreJoin =>\n  convertRelationQueryOptions(\n    metadata,\n    collection,\n    match,\n    ({ collection, by, query }) => ({\n      collection,\n      by,\n      ...convertFilterQuery(collection.states, collection, query),\n      ...convertMatchQuery(metadata, collection, query),\n    }),\n  );\n","import { StoreDocument } from '@neuledge/store';\nimport { StateDefinition } from '@/definitions';\nimport { Entity, ProjectedEntity } from '@/entity';\nimport { EntityList } from '@/list';\nimport { ReturnQueryOptions, Select, SelectQueryOptions } from '@/queries';\n\nexport interface AlteredEntity<S extends StateDefinition> {\n  oldEntity: Entity<S> | null;\n  entity: Entity<S>;\n  document: StoreDocument;\n}\n\nexport const retrieveEntities = async <\n  S extends StateDefinition,\n  P extends Select<S>,\n>(\n  entities: EntityList<AlteredEntity<S>>,\n  { returns, select }: Partial<ReturnQueryOptions> & SelectQueryOptions<S, P>,\n): Promise<\n  EntityList<ProjectedEntity<S, P>> | EntityList<Entity<S>> | void\n> => {\n  if (!select) return;\n\n  if (returns === 'old') {\n    return Object.assign(\n      entities.map((entity) => entity.oldEntity as Entity<S>),\n      { nextOffset: entities.nextOffset },\n    );\n  }\n\n  if (select == true) {\n    return Object.assign(\n      entities.map((entity) => entity.entity),\n      { nextOffset: entities.nextOffset },\n    );\n  }\n\n  return Object.assign(\n    entities.map((entity) => projectEntity(entity.entity, select)),\n    { nextOffset: entities.nextOffset },\n  );\n};\n\nconst projectEntity = <S extends StateDefinition, P extends Select<S>>(\n  entity: Entity<S>,\n  select: P,\n): ProjectedEntity<S, P> => {\n  const projectedEntity = {\n    $state: (entity as Entity<StateDefinition>).$state,\n    $version: (entity as Entity<StateDefinition>).$version,\n  } as ProjectedEntity<S, P>;\n\n  for (const [key, value] of Object.entries(select)) {\n    if (!value) continue;\n\n    projectedEntity[key as never] = entity[key] as never;\n  }\n\n  return projectedEntity;\n};\n","import { StateDefinition } from '@/definitions';\nimport { Entity } from '@/entity';\nimport { EntityList } from '@/list';\nimport {\n  FindFirstOrThrowQueryOptions,\n  FindFirstQueryOptions,\n  FindManyQueryOptions,\n  FindUniqueOrThrowQueryOptions,\n  FindUniqueQueryOptions,\n} from '@/queries';\nimport { chooseStatesCollection } from '../collection';\nimport { NeuledgeEngine } from '../engine';\nimport { toEntityList, toEntityOrThrow, toMaybeEntity } from '../entity';\nimport { convertUniqueFilterQuery, convertWhereFilterQuery } from '../find';\nimport {\n  convertLimitQuery,\n  checkLimitedList,\n  convertOffsetQuery,\n  convertSortQuery,\n} from '../pagination';\nimport { convertExpandQuery, convertPopulateOneQuery } from '../relations';\nimport { convertSelectQuery } from '../select';\n\nexport const execFindMany = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: FindManyQueryOptions<S, S>,\n): Promise<EntityList<Entity<S>>> => {\n  const metadata = await engine.metadata;\n\n  const { states, collection } = chooseStatesCollection(\n    metadata,\n    options.states,\n  );\n\n  const list = checkLimitedList(\n    options,\n    await engine.store.find({\n      collection,\n      ...convertSelectQuery(collection, options),\n      ...convertExpandQuery(metadata, collection, options),\n      ...convertPopulateOneQuery(metadata, collection, options),\n      ...convertWhereFilterQuery(states, collection, options),\n      ...convertOffsetQuery(options),\n      ...convertLimitQuery(options),\n      ...convertSortQuery(collection, options),\n    }),\n  );\n\n  return toEntityList(metadata, collection, list);\n};\n\nexport const execFindUnique = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: FindUniqueQueryOptions<S, S>,\n): Promise<Entity<S> | null> => {\n  const metadata = await engine.metadata;\n\n  const { states, collection } = chooseStatesCollection(\n    metadata,\n    options.states,\n  );\n\n  const [document] = await engine.store.find({\n    collection,\n    ...convertSelectQuery(collection, options),\n    ...convertExpandQuery(metadata, collection, options),\n    ...convertPopulateOneQuery(metadata, collection, options),\n    ...convertUniqueFilterQuery(states, collection, options),\n    limit: 1,\n  });\n\n  return toMaybeEntity(metadata, collection, document);\n};\n\nexport const execFindUniqueOrThrow = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: FindUniqueOrThrowQueryOptions<S, S>,\n): Promise<Entity<S>> => {\n  const metadata = await engine.metadata;\n\n  const { states, collection } = chooseStatesCollection(\n    metadata,\n    options.states,\n  );\n\n  const [document] = await engine.store.find({\n    collection,\n    ...convertSelectQuery(collection, options),\n    ...convertExpandQuery(metadata, collection, options),\n    ...convertPopulateOneQuery(metadata, collection, options),\n    ...convertUniqueFilterQuery(states, collection, options),\n    limit: 1,\n  });\n\n  return toEntityOrThrow(metadata, collection, document);\n};\n\nexport const execFindFirst = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: FindFirstQueryOptions<S, S>,\n): Promise<Entity<S> | null> => {\n  const metadata = await engine.metadata;\n\n  const { states, collection } = chooseStatesCollection(\n    metadata,\n    options.states,\n  );\n\n  const [document] = await engine.store.find({\n    collection,\n    ...convertSelectQuery(collection, options),\n    ...convertExpandQuery(metadata, collection, options),\n    ...convertPopulateOneQuery(metadata, collection, options),\n    ...convertWhereFilterQuery(states, collection, options),\n    ...convertOffsetQuery(options),\n    limit: 1,\n    ...convertSortQuery(collection, options),\n  });\n\n  return toMaybeEntity(metadata, collection, document);\n};\n\nexport const execFindFirstOrThrow = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: FindFirstOrThrowQueryOptions<S, S>,\n): Promise<Entity<S>> => {\n  const metadata = await engine.metadata;\n\n  const { states, collection } = chooseStatesCollection(\n    metadata,\n    options.states,\n  );\n\n  const [document] = await engine.store.find({\n    collection,\n    ...convertSelectQuery(collection, options),\n    ...convertExpandQuery(metadata, collection, options),\n    ...convertPopulateOneQuery(metadata, collection, options),\n    ...convertWhereFilterQuery(states, collection, options),\n    ...convertOffsetQuery(options),\n    limit: 1,\n    ...convertSortQuery(collection, options),\n  });\n\n  return toEntityOrThrow(metadata, collection, document);\n};\n","export * from './limit';\nexport * from './offset';\nexport * from './sort';\n","import { LimitQueryOptions } from '@/queries';\nimport { StoreFindOptions, StoreList } from '@neuledge/store';\n\nexport const DEFAULT_QUERY_LIMIT = 1000;\n\nexport const convertLimitQuery = (\n  options: LimitQueryOptions,\n): Pick<StoreFindOptions, 'limit'> => ({\n  limit: options.limit ?? DEFAULT_QUERY_LIMIT,\n});\n\nexport const checkLimitedList = (\n  options: LimitQueryOptions,\n  list: StoreList,\n): StoreList => {\n  if (\n    options.limit == null &&\n    list.length >= DEFAULT_QUERY_LIMIT &&\n    typeof process === 'object' &&\n    process?.env?.NODE_ENV !== 'production'\n  ) {\n    /* eslint-disable no-console */\n\n    console.warn(`Warning: Too many documents found without an explicit limit. A default limit of ${DEFAULT_QUERY_LIMIT} \n    was applied. Consider adding a limit to your query.`);\n    console.trace(`Your query can be found here:`);\n\n    /* eslint-enable no-console */\n  }\n\n  return list;\n};\n","import { OffsetQueryOptions } from '@/queries';\nimport { StoreFindOptions } from '@neuledge/store';\n\nexport const convertOffsetQuery = ({\n  offset,\n}: OffsetQueryOptions): Pick<StoreFindOptions, 'offset'> =>\n  offset == null ? {} : { offset };\n","import { StateDefinition, SortDefinition } from '@/definitions';\nimport { NeuledgeError } from '@/error';\nimport { MetadataCollection } from '@/metadata';\nimport { SortQueryOptions } from '@/queries';\nimport { StoreFindOptions, StoreSort } from '@neuledge/store';\n\nexport const convertSortQuery = <S extends StateDefinition>(\n  collection: MetadataCollection,\n  { sort }: SortQueryOptions<S>,\n): Pick<StoreFindOptions, 'sort'> => {\n  let reverse = false;\n\n  if (typeof sort === 'string') {\n    reverse = sort[0] === '-';\n\n    const indexKey = sort.slice(1);\n    for (const state of collection.states) {\n      const index = state.instance.$indexes?.[indexKey];\n      if (index != null) {\n        sort = index.fields;\n        break;\n      }\n    }\n\n    if (typeof sort === 'string') {\n      throw new NeuledgeError(\n        NeuledgeError.Code.UNKNOWN_SORT_INDEX,\n        `Unknown sort index: ${indexKey}`,\n      );\n    }\n  } else if (sort == null) {\n    return {};\n  }\n\n  const res: StoreSort = {};\n\n  for (const key of sort as SortDefinition<S>) {\n    let sort: 'asc' | 'desc';\n    switch (key[0]) {\n      case '+': {\n        sort = reverse ? 'desc' : 'asc';\n        break;\n      }\n\n      case '-': {\n        sort = reverse ? 'asc' : 'desc';\n        break;\n      }\n\n      default: {\n        throw new NeuledgeError(\n          NeuledgeError.Code.UNKNOWN_SORT_DIRECTION,\n          `Unknown sort direction: '${key}'`,\n        );\n      }\n    }\n\n    const field = key.slice(1);\n\n    for (const name of collection.getSchemaFieldNames(field)) {\n      res[name] = sort;\n    }\n  }\n\n  return { sort: res };\n};\n","import {\n  MutationDefinition,\n  StateDefinition,\n  StateDefinitionAlterMethods,\n  StateDefinitionMutationsReturn,\n} from '@/definitions';\nimport { Entity, ProjectedEntity } from '@/entity';\nimport {\n  Select,\n  AlterFirstOrThrowQueryOptions,\n  AlterFirstQueryOptions,\n  AlterManyQueryOptions,\n  AlterUniqueOrThrowQueryOptions,\n  AlterUniqueQueryOptions,\n} from '@/queries';\nimport { chooseStatesCollection } from '../collection';\nimport { NeuledgeEngine } from '../engine';\nimport { toEntityList, toEntityListOrThrow } from '../entity';\nimport {\n  convertLimitQuery,\n  DEFAULT_QUERY_LIMIT,\n  checkLimitedList,\n} from '../pagination';\nimport {\n  getStateDefinitionMap,\n  StateDefinitionMap,\n  alterEntityList,\n  alterStoreDocuments,\n} from '../mutations';\nimport { NeuledgeError } from '@/error';\nimport {\n  Store,\n  StoreDeleteOptions,\n  StoreDocument,\n  StoreFindOptions,\n  StoreList,\n} from '@neuledge/store';\nimport { Metadata, MetadataCollection, MetadataState } from '@/metadata';\nimport { toDocument } from '../document';\nimport {\n  retrieveEntities,\n  AlteredEntity,\n  convertMatchQuery,\n} from '../relations';\nimport { convertUniqueFilterQuery, convertWhereFilterQuery } from '../find';\n\nconst ALTER_VERSION_RETRIES = 3;\n\ntype AlterQueryOptions<\n  S extends StateDefinition,\n  R extends ReturnState<S> = ReturnState<S>,\n> =\n  | AlterManyQueryOptions<S, R>\n  | AlterFirstQueryOptions<S, R>\n  | AlterFirstOrThrowQueryOptions<S, R>\n  | AlterUniqueQueryOptions<S, R>\n  | AlterUniqueOrThrowQueryOptions<S, R>;\n\ntype ReturnState<S extends StateDefinition> = StateDefinitionMutationsReturn<\n  S,\n  StateDefinitionAlterMethods<S>\n>;\n\ntype AlterContext<S extends StateDefinition> = {\n  entities: Map<string, AlteredEntity<ReturnState<S>>>;\n  metadata: Metadata;\n  store: Store;\n  collection: MetadataCollection;\n  states: StateDefinitionMap<S>;\n  options: AlterQueryOptions<S>;\n  storeFilters: StoreFindOptions;\n};\n\nexport const execAlterMany = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: AlterQueryOptions<S>,\n): Promise<\n  | Entity<ReturnState<S>>[]\n  | ProjectedEntity<ReturnState<S>, Select<ReturnState<S>>>[]\n  | void\n> => {\n  const ctx = await preprareAlter(engine, options);\n  if (!ctx) return;\n\n  let documents = await engine.store.find(ctx.storeFilters);\n  await alterDocuments(ctx, documents);\n\n  for (let retries = 1; retries < ALTER_VERSION_RETRIES; retries++) {\n    let leftDocs: StoreList | undefined;\n\n    if (ctx.entities.size < documents.length) {\n      documents = await engine.store.find(ctx.storeFilters);\n\n      leftDocs = documents.filter(\n        (document) =>\n          !ctx.entities.has(getDocumentKey(ctx.collection, document)),\n      );\n    }\n\n    if (!leftDocs?.length) {\n      return retrieveEntities([...ctx.entities.values()], options);\n    }\n\n    await alterDocuments(ctx, leftDocs);\n  }\n\n  throw new NeuledgeError(\n    NeuledgeError.Code.VERSION_MISMATCH,\n    `Version mismatch while altering ${\n      documents.length > 1 ? 'entities' : 'entity'\n    }`,\n  );\n};\n\nexport const execAlterOne = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options:\n    | AlterFirstQueryOptions<S, ReturnState<S>>\n    | AlterFirstOrThrowQueryOptions<S, ReturnState<S>>\n    | AlterUniqueQueryOptions<S, ReturnState<S>>\n    | AlterUniqueOrThrowQueryOptions<S, ReturnState<S>>,\n): Promise<\n  | Entity<ReturnState<S>>\n  | ProjectedEntity<ReturnState<S>, Select<ReturnState<S>>>\n  | void\n> => {\n  const res = await execAlterMany(engine, options);\n  return res?.[0];\n};\n\nconst preprareAlter = async <S extends StateDefinition>(\n  engine: NeuledgeEngine,\n  options: AlterQueryOptions<S>,\n): Promise<AlterContext<S> | void> => {\n  const metadata = await engine.metadata;\n\n  const { states, collection } = chooseStatesCollection(\n    metadata,\n    options.states,\n  );\n\n  const storeFilters = createStoreFilters(\n    metadata,\n    states,\n    collection,\n    options,\n  );\n\n  if (isAlterDeleteOnly(options)) {\n    return deleteDocuments(engine.store, storeFilters, options);\n  }\n\n  const res = new Map<string, AlteredEntity<ReturnState<S>>>();\n\n  return {\n    entities: res,\n    metadata,\n    store: engine.store,\n    collection,\n    states: getStateDefinitionMap(options.states),\n    options,\n    storeFilters,\n  };\n};\n\nconst createStoreFilters = <S extends StateDefinition>(\n  metadata: Metadata,\n  states: MetadataState[],\n  collection: MetadataCollection,\n  options: AlterQueryOptions<S>,\n) => ({\n  collection,\n\n  // we don't use select here, because we need to get all fields to validate the\n  // current state of the entity. we will use select later to project the result\n  // to the user\n\n  ...('unique' in options\n    ? convertUniqueFilterQuery(states, collection, options)\n    : convertWhereFilterQuery(states, collection, options)),\n\n  ...convertMatchQuery(metadata, collection, options),\n\n  ...(options.type === 'AlterMany' ? convertLimitQuery(options) : { limit: 1 }),\n});\n\nconst isAlterDeleteOnly = <S extends StateDefinition>(\n  options: AlterQueryOptions<S>,\n): boolean => {\n  if (options.select || options.match) {\n    return false;\n  }\n\n  for (const state of options.states) {\n    const mutation = state[options.method] as MutationDefinition<S> | undefined;\n\n    if (mutation?.mutation !== 'delete' || !mutation.virtual) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst deleteDocuments = async <S extends StateDefinition>(\n  store: Store,\n  storeFilters: StoreDeleteOptions,\n  options: AlterQueryOptions<S>,\n): Promise<void> => {\n  let res;\n\n  do {\n    res = await store.delete(storeFilters);\n  } while (\n    options.type === 'AlterMany' &&\n    (!('limit' in options) || options.limit == null) &&\n    res.affectedCount >= DEFAULT_QUERY_LIMIT\n  );\n};\n\nconst alterDocuments = async <S extends StateDefinition>(\n  ctx: AlterContext<S>,\n  documents: StoreList,\n): Promise<void> => {\n  const convert = ctx.options.type.endsWith('OrThrow')\n    ? toEntityListOrThrow\n    : toEntityList;\n\n  const list =\n    ctx.options.type === 'AlterMany'\n      ? checkLimitedList(ctx.options, documents)\n      : documents;\n\n  const entities = convert(ctx.metadata, ctx.collection, list);\n\n  const updated = await alterEntityList(\n    ctx.states,\n    entities,\n    ctx.options.method,\n    ctx.options.args[0],\n  );\n\n  const updatedDocs = updated.map(\n    (entity) => entity && toDocument(ctx.metadata, ctx.collection, entity),\n  );\n\n  const success = await alterStoreDocuments(\n    ctx.store,\n    ctx.collection,\n    documents,\n    updatedDocs,\n  );\n\n  for (const [i, flag] of success.entries()) {\n    if (!flag) continue;\n\n    const document = updatedDocs[i] ?? documents[i];\n    const entity = updated[i] ?? entities[i];\n\n    const key = getDocumentKey(ctx.collection, document);\n\n    ctx.entities.set(key, { document, entity, oldEntity: entities[i] });\n  }\n};\n\nconst getDocumentKey = (\n  collection: MetadataCollection,\n  document: StoreDocument,\n) =>\n  JSON.stringify(\n    Object.keys(collection.primaryKey.fields).map(\n      (key) => document[key] ?? null,\n    ),\n  );\n","export * from './entities';\nexport * from './store';\nexport * from './states';\n","import {\n  MutationDefinition,\n  StateDefinition,\n  StateDefinitionAlterMethods,\n  StateDefinitionMutationArguments,\n  StateDefinitionMutationsReturn,\n} from '@/definitions';\nimport { Entity, AlteredEntity } from '@/entity';\nimport { NeuledgeError } from '@/error';\nimport pLimit from 'p-limit';\nimport { StateDefinitionMap } from './states';\n\nexport const alterEntityList = async <\n  S extends StateDefinition,\n  M extends StateDefinitionAlterMethods<S>,\n  A extends StateDefinitionMutationArguments<S, M>,\n>(\n  states: StateDefinitionMap<S>,\n  entities: Entity<S>[],\n  method: M,\n  args: A,\n): Promise<(Entity<StateDefinitionMutationsReturn<S, M>> | null)[]> => {\n  const asyncLimit = pLimit(10);\n\n  return Promise.all(\n    entities.map((entity) =>\n      asyncLimit(() => alterEntity(states, entity, method, args)),\n    ),\n  );\n};\n\nconst alterEntity = async <\n  S extends StateDefinition,\n  M extends StateDefinitionAlterMethods<S>,\n  A extends StateDefinitionMutationArguments<S, M>,\n>(\n  states: StateDefinitionMap<S>,\n  entity: Entity<S>,\n  method: M,\n  args: A,\n): Promise<Entity<StateDefinitionMutationsReturn<S, M>> | null> => {\n  const { $state, $version, ...thisArg } = entity as Entity<StateDefinition>;\n\n  const state = states[$state];\n  if (!state) {\n    throw new NeuledgeError(\n      NeuledgeError.Code.INTERNAL_ERROR,\n      `State ${$state} not found`,\n    );\n  }\n\n  const fn = state[method] as\n    | MutationDefinition<S, A, StateDefinitionMutationsReturn<S, M>>\n    | undefined;\n\n  switch (fn?.mutation) {\n    case 'update': {\n      const mutated = await fn.call(thisArg, args);\n\n      return {\n        ...(mutated as AlteredEntity<StateDefinition>),\n        $version: $version + 1,\n      };\n    }\n\n    case 'delete': {\n      await fn.call(thisArg, args);\n      return null;\n    }\n\n    default: {\n      break;\n    }\n  }\n\n  throw new NeuledgeError(\n    NeuledgeError.Code.INVALID_MUTATION,\n    `Mutation ${String(method)} is not an alter mutation`,\n  );\n};\n","import { MetadataCollection } from '@/metadata';\nimport {\n  Store,\n  StoreDocument,\n  StoreWhere,\n  StoreWhereEquals,\n  StoreWhereRecord,\n} from '@neuledge/store';\nimport pLimit from 'p-limit';\n\n// update\n\nexport const alterStoreDocuments = async (\n  store: Store,\n  collection: MetadataCollection,\n  documents: StoreDocument[],\n  updates: (StoreDocument | null)[],\n): Promise<boolean[]> => {\n  const asyncLimit = pLimit(10);\n  const deleteDocuments: StoreDocument[] = [];\n\n  const res = await Promise.all(\n    documents.map((document, index) => {\n      const updated = updates[index];\n\n      if (updated == null) {\n        deleteDocuments.push(document);\n        return true;\n      }\n\n      return asyncLimit(() =>\n        updateStoreDocument(store, collection, document, updated),\n      );\n    }),\n  );\n\n  if (deleteDocuments.length) {\n    await deleteStoreDocuments(store, collection, deleteDocuments);\n  }\n\n  return res;\n};\n\nconst updateStoreDocument = async (\n  store: Store,\n  collection: MetadataCollection,\n  document: StoreDocument,\n  updated: StoreDocument,\n): Promise<boolean> => {\n  const setEntries = Object.entries(updated).filter(\n    ([key, value]) => value !== document[key],\n  );\n  if (!setEntries.length) {\n    return true;\n  }\n\n  const res = await store.update({\n    collection,\n    where: getWhereRecordByPrimaryKeys(collection, document),\n    set: Object.fromEntries(setEntries),\n    limit: 1,\n  });\n\n  return !!res.affectedCount;\n};\n\n// delete\n\nconst deleteStoreDocuments = async (\n  store: Store,\n  collection: MetadataCollection,\n  documents: StoreDocument[],\n): Promise<void> => {\n  await store.delete({\n    collection,\n    where: getWhereByPrimaryKeys(collection, documents),\n    limit: documents.length,\n  });\n};\n\n// const deleteStoreDocument = async (\n//   store: Store,\n//   collection: MetadataCollection,\n//   document: StoreDocument,\n// ): Promise<void> => {\n//   await store.delete({\n//     collectionName: collection.name,\n//     where: getWhereRecord(collection.primaryKeys, document),\n//     limit: 1,\n//   });\n// };\n\n// store where\n\nconst getWhereByPrimaryKeys = (\n  collection: MetadataCollection,\n  documents: StoreDocument[],\n): StoreWhere => ({\n  $or: documents.map((document) =>\n    getWhereRecordByPrimaryKeys(collection, document),\n  ),\n});\n\nconst getWhereRecordByPrimaryKeys = (\n  collection: MetadataCollection,\n  document: StoreDocument,\n): StoreWhereRecord =>\n  Object.fromEntries([\n    ...Object.keys(collection.primaryKey.fields).map(\n      (key): [string, StoreWhereEquals] => [\n        key,\n        { $eq: document[key] ?? null },\n      ],\n    ),\n    [\n      collection.reservedNames.hash,\n      { $eq: document[collection.reservedNames.hash] ?? null },\n    ],\n    [\n      collection.reservedNames.version,\n      { $eq: document[collection.reservedNames.version] ?? 0 },\n    ],\n  ]);\n","import { StateDefinition } from '@/definitions';\n\nexport type StateDefinitionMap<S extends StateDefinition> = {\n  [N in string]?: S;\n};\n\nexport const getStateDefinitionMap = <S extends StateDefinition>(\n  states: S[],\n): StateDefinitionMap<S> => {\n  const map: StateDefinitionMap<S> = {};\n\n  for (const state of states) {\n    map[state.$name] = state;\n  }\n\n  return map;\n};\n","export * from './alter';\nexport * from './init';\nexport * from './mutation';\nexport * from './generator';\n","import {\n  StateDefinition,\n  StateDefinitionMutationArguments,\n  StateDefinitionMutationsReturn,\n  StateDefinitionAlterWithArgsMethods,\n  StateDefinitionAlterWithoutArgsMethods,\n} from '@/definitions';\nimport {\n  AlterFirstOrThrowQuery,\n  AlterFirstQuery,\n  AlterManyQuery,\n  AlterUniqueOrThrowQuery,\n  AlterUniqueQuery,\n} from '@/queries';\n\nexport type AlterManyMutation<S extends StateDefinition> = {\n  [M in StateDefinitionAlterWithoutArgsMethods<S>]: (\n    args?: StateDefinitionMutationArguments<S, M>,\n  ) => AlterManyQuery<S, StateDefinitionMutationsReturn<S, M>>;\n} & {\n  [M in StateDefinitionAlterWithArgsMethods<S>]: (\n    args: StateDefinitionMutationArguments<S, M>,\n  ) => AlterManyQuery<S, StateDefinitionMutationsReturn<S, M>>;\n};\n\nexport type AlterFirstMutation<S extends StateDefinition> = {\n  [M in StateDefinitionAlterWithoutArgsMethods<S>]: (\n    args?: StateDefinitionMutationArguments<S, M>,\n  ) => AlterFirstQuery<S, StateDefinitionMutationsReturn<S, M>>;\n} & {\n  [M in StateDefinitionAlterWithArgsMethods<S>]: (\n    args: StateDefinitionMutationArguments<S, M>,\n  ) => AlterFirstQuery<S, StateDefinitionMutationsReturn<S, M>>;\n};\n\nexport type AlterFirstOrThrowMutation<S extends StateDefinition> = {\n  [M in StateDefinitionAlterWithoutArgsMethods<S>]: (\n    args?: StateDefinitionMutationArguments<S, M>,\n  ) => AlterFirstOrThrowQuery<S, StateDefinitionMutationsReturn<S, M>>;\n} & {\n  [M in StateDefinitionAlterWithArgsMethods<S>]: (\n    args: StateDefinitionMutationArguments<S, M>,\n  ) => AlterFirstOrThrowQuery<S, StateDefinitionMutationsReturn<S, M>>;\n};\n\nexport type AlterUniqueMutation<S extends StateDefinition> = {\n  [M in StateDefinitionAlterWithoutArgsMethods<S>]: (\n    args?: StateDefinitionMutationArguments<S, M>,\n  ) => AlterUniqueQuery<S, StateDefinitionMutationsReturn<S, M>>;\n} & {\n  [M in StateDefinitionAlterWithArgsMethods<S>]: (\n    args: StateDefinitionMutationArguments<S, M>,\n  ) => AlterUniqueQuery<S, StateDefinitionMutationsReturn<S, M>>;\n};\n\nexport type AlterUniqueOrThrowMutation<S extends StateDefinition> = {\n  [M in StateDefinitionAlterWithoutArgsMethods<S>]: (\n    args?: StateDefinitionMutationArguments<S, M>,\n  ) => AlterUniqueOrThrowQuery<S, StateDefinitionMutationsReturn<S, M>>;\n} & {\n  [M in StateDefinitionAlterWithArgsMethods<S>]: (\n    args: StateDefinitionMutationArguments<S, M>,\n  ) => AlterUniqueOrThrowQuery<S, StateDefinitionMutationsReturn<S, M>>;\n};\n","import {\n  StateDefinition,\n  StateDefinitionInitWithArgsMethods,\n  StateDefinitionInitWithoutArgsMethods,\n  StateDefinitionMutationArguments,\n} from '@/definitions';\nimport { InitManyQuery, InitOneQuery } from '@/queries';\n\nexport type InitManyMutation<S extends StateDefinition> = {\n  [M in StateDefinitionInitWithArgsMethods<S>]: (\n    ...args: StateDefinitionMutationArguments<S, M>[]\n  ) => InitManyQuery<S>;\n} & {\n  [M in StateDefinitionInitWithoutArgsMethods<S>]:\n    | ((...args: StateDefinitionMutationArguments<S, M>[]) => InitManyQuery<S>)\n    | ((count: number) => InitManyQuery<S>);\n};\n\nexport type InitOneMutation<S extends StateDefinition> = {\n  [M in StateDefinitionInitWithArgsMethods<S>]: (\n    args: StateDefinitionMutationArguments<S, M>,\n  ) => InitOneQuery<S>;\n} & {\n  [M in StateDefinitionInitWithoutArgsMethods<S>]: (\n    args?: StateDefinitionMutationArguments<S, M>,\n  ) => InitOneQuery<S>;\n};\n","import { StateDefinition } from '@/definitions';\nimport {\n  AlterFirstMutation,\n  AlterFirstOrThrowMutation,\n  AlterManyMutation,\n  AlterUniqueMutation,\n  AlterUniqueOrThrowMutation,\n} from './alter';\nimport { InitManyMutation, InitOneMutation } from './init';\n\nexport type Mutation<\n  T extends MutationType,\n  I extends StateDefinition,\n> = MutationTypes<I>[T];\n\nexport type MutationType = keyof MutationTypes<never>;\n\nexport interface MutationTypes<I extends StateDefinition> {\n  InitMany: InitManyMutation<I>;\n  InitOne: InitOneMutation<I>;\n  AlterMany: AlterManyMutation<I>;\n  AlterFirst: AlterFirstMutation<I>;\n  AlterFirstOrThrow: AlterFirstOrThrowMutation<I>;\n  AlterUnique: AlterUniqueMutation<I>;\n  AlterUniqueOrThrow: AlterUniqueOrThrowMutation<I>;\n}\n","import {\n  MutationDefinition,\n  StateDefinition,\n  StateDefinitionMethods,\n} from '@/definitions';\nimport { Query, QueryMode, QueryOptions, QueryType } from '@/queries';\nimport { Mutation, MutationType } from './mutation';\n\nexport interface MutationGeneratorMethod {\n  (...args: Record<string, never>[]): Query<\n    QueryMode,\n    StateDefinition,\n    StateDefinition,\n    null,\n    NonNullable<unknown>\n  >;\n}\n\nexport const MutationGenerator = <\n  T extends QueryType & MutationType,\n  I extends StateDefinition,\n>(\n  type: T,\n  states: I[],\n  generator: (\n    options: Pick<\n      QueryOptions<T, I, StateDefinition>,\n      'type' | 'states' | 'method' | 'args'\n    >,\n  ) => Query<\n    QueryMode,\n    StateDefinition,\n    StateDefinition,\n    null,\n    NonNullable<unknown>\n  >,\n): Mutation<T, I> =>\n  new Proxy({} as Mutation<T, I>, {\n    get: (_, method): MutationGeneratorMethod | undefined =>\n      hasMutation(type, states, method as never)\n        ? (...args) =>\n            generator({\n              type,\n              states,\n              method: method as never,\n              args: (typeof args[0] === 'number'\n                ? Array.from({ length: args[0] }).fill({})\n                : [args[0] ?? {}, ...args.slice(1)]) as never,\n            })\n        : undefined,\n\n    ownKeys: (): string[] => {\n      if (!states.length) {\n        return [];\n      }\n\n      return Object.keys(states[0]).filter((method) =>\n        hasMutation(type, states, method as never),\n      );\n    },\n\n    has: (_, method): boolean => hasMutation(type, states, method as never),\n  });\n\nconst hasMutation = <\n  S extends StateDefinition,\n  M extends StateDefinitionMethods<S>,\n>(\n  type: MutationType,\n  states: S[],\n  method: M,\n): boolean =>\n  states.every((state) => {\n    const fn = state[method] as MutationDefinition<S> | undefined;\n\n    switch (fn?.mutation) {\n      case 'create': {\n        return type.startsWith('Init');\n      }\n\n      case 'update':\n      case 'delete': {\n        return type.startsWith('Alter');\n      }\n\n      default: {\n        return false;\n      }\n    }\n  });\n","import { InitiatedState, StateDefinition, StateName } from './definitions';\nimport { Select } from './queries';\n\nexport type Entity<S extends StateDefinition> = {\n  [N in StateName<S>]: S extends StateDefinition<N, infer R>\n    ? StateEntity<S, R>\n    : never;\n}[StateName<S>];\n\nexport type InitiatedEntity<S extends StateDefinition> = {\n  [N in StateName<S>]: S extends StateDefinition<N, infer R>\n    ? InitiatedState<S['$id'], R> & {\n        $state: StateName<S>;\n      }\n    : never;\n}[StateName<S>];\n\nexport type AlteredEntity<S extends StateDefinition> = {\n  [N in StateName<S>]: S extends StateDefinition<N, infer R>\n    ? R & { $state: StateName<S> }\n    : never;\n}[StateName<S>];\n\nexport type ProjectedEntity<S extends StateDefinition, P extends Select<S>> = {\n  [K in StateName<S>]: S extends StateDefinition<K, infer R>\n    ? Project<S, P & Select<S>, R>\n    : never;\n}[StateName<S>];\n\ntype StateEntity<S extends StateDefinition, T> = T & {\n  $state: StateName<S>;\n  $version: number;\n};\n\ntype Project<S extends StateDefinition, P extends Select<S>, T> = StateEntity<\n  S,\n  {\n    [K in TruthyKeys<S, P, T>]: T[K];\n  } & {\n    [K in BooleanKeys<S, P, T>]?: T[K] | null;\n  }\n>;\n\ntype TruthyKeys<S extends StateDefinition, P extends Select<S>, T> = {\n  [K in keyof T]: P[K] extends true\n    ? undefined extends T[K]\n      ? never\n      : K\n    : never;\n}[keyof T];\n\ntype BooleanKeys<S extends StateDefinition, P extends Select<S>, T> = {\n  [K in keyof T]: P[K] extends false ? never : P[K] extends boolean ? K : never;\n}[keyof T];\n","export interface EntityList<T> extends Array<T> {\n  nextOffset?: EntityListOffset | null;\n}\n\nexport type EntityListOffset = string | number | Buffer;\n\nexport const createEntityList = <T>(\n  entries: T[],\n  nextOffset: EntityList<T>['nextOffset'],\n): EntityList<T> => Object.assign(entries, { nextOffset });\n","export {\n  State,\n  type StateId as Id,\n  type StateDefinitionWhereId as WhereId,\n  type StateDefinitionWhereNullableId as WhereNullableId,\n  type StateDefinitionWhereEnum as WhereEnum,\n  type StateDefinitionWhereNullableEnum as WhereNullableEnum,\n  type StateDefinitionWhereNumber as WhereNumber,\n  type StateDefinitionWhereNullableNumber as WhereNullableNumber,\n  type StateDefinitionWhereBoolean as WhereBoolean,\n  type StateDefinitionWhereNullableBoolean as WhereNullableBoolean,\n  type StateDefinitionWhereString as WhereString,\n  type StateDefinitionWhereNullableString as WhereNullableString,\n  type StateDefinitionWhereUnknown as WhereUnknown,\n  type StateDefinitionWhereNullableUnknown as WhereNullableUnknown,\n  type StateDefinitionWhereDateTime as WhereDateTime,\n  type StateDefinitionWhereNullableDateTime as WhereNullableDateTime,\n  type StateDefinitionWhereBuffer as WhereBuffer,\n  type StateDefinitionWhereNullableBuffer as WhereNullableBuffer,\n  type StateDefinitionWhereState as WhereState,\n  type StateDefinitionWhereNullableState as WhereNullableState,\n  type StateDefinitionWhereListState as WhereListState,\n  type StateDefinitionWhereNullableListState as WhereNullableListState,\n  type StateDefinitionWhereArray as WhereArray,\n  type StateDefinitionWhereNullableArray as WhereNullableArray,\n  type EitherDefintion as Either,\n  createEitherDefintion as either,\n  createMutation as mutation,\n} from './definitions';\n\nexport { type Entity as Entity, type AlteredEntity as Type } from '@/entity';\n\nexport { types as scalars, runtime } from '@neuledge/scalars';\n"],"mappings":"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","names":["module","exports","equal","a","b","constructor","length","i","keys","Array","isArray","Map","size","entries","has","get","Set","ArrayBuffer","isView","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","createEitherDefintion","name","states","Object","assign","$name","createMutation","type","mutation","Object","assign","undefined","virtual","NeuledgeErrorCode","VERSION_MISMATCH","INVALID_ARGUMENT","DOCUMENT_NOT_FOUND","NO_COLLECTIONS","MULTIPLE_COLLECTIONS","ENTITY_STATE_NOT_FOUND","RESERVED_FIELD_NAME","DUPLICATE_STATE_NAME","UNKNOWN_SORT_DIRECTION","UNKNOWN_SORT_INDEX","UNKNOWN_SORT_FIELD","RELATION_FIELD_NOT_FOUND","RELATION_STATE_NOT_FOUND","QUERY_PARSING_ERROR","QUERY_EXECUTION_ERROR","INVALID_MUTATION","UNSUPPORTED_METADATA","CORRUPTED_METADATA","METADATA_SAVE_ERROR","METADATA_LOAD_ERROR","INTERNAL_ERROR","NOT_IMPLEMENTED","NeuledgeError","Error","code","fromError","originalError","message","hideOriginalError","orgMsg","String","error","StoreError","fromStoreErrorCode","Code","stack","constructor","name","wrap","defaultCode","INVALID_DATA","globKey","glob","globalThis","self","window","global","neuledgeGlob","stateDefinitions","Map","stateDefinitions","neuledgeGlob","State","state","has","$name","get","NeuledgeError","Code","DUPLICATE_STATE_NAME","set","isStateDefinitionScalarTypeScalar","type","Array","isArray","isStateDefinitionScalarTypeStates","parseSortedField","field","slice","fromSortedField","resolveDefer","defer","def","QueryClass","options","constructor","unique","then","return","returns","select","expand","key","states","query","undefined","Array","isArray","rel","type","populateOne","where","filter","match","sort","fields","limit","offset","exec","NeuledgeError","Code","QUERY_EXECUTION_ERROR","onfulfilled","onrejected","catch","wrap","getMetadataSchema","states","relationParent","schemaMap","state","field","fields","path","startsWith","slice","length","pathChoices","key","getFieldKey","relation","relations","getSchemaKey","childSchema","schema","Object","fromEntries","entries","map","choices","values","name","type","nullable","JSON","stringify","hash","toString","sort","MetadataCollection","name","states","reservedNames","schema","primaryKey","indexes","fields","constructor","getStoreCollectionFields","getMetadataSchema","getStoreIndexes","getSchemaFields","rootPath","choices","reverse","res","length","choice","pop","field","push","schemaChoices","Object","values","getSchemaFieldNames","map","refCount","Map","state","storeField","getStoreField","nullable","count","get","set","type","shape","getStoreIndexFields","instance","$id","unique","auto","index","entries","$indexes","applyPrimaryKey","sortDefinition","sortField","sort","parseSortedField","indexField","NeuledgeError","Code","UNKNOWN_SORT_FIELD","assignStoreIndexField","flatMap","item","primaryKeyName","keys","join","i","METADATA_HASH_BYTES","groupStatesByCollectionName","states","groups","getStateGroups","suggestions","group","values","push","suggestStatesCollectionNames","sort","a","b","name","localeCompare","rank","selectedName","Map","index","suggestion","entries","best","get","set","map","state","$name","Set","relatedStates","resolveDefer","$transforms","relatedState","add","item","stateGroup","sharedPhrase","first","words","split","word","toLowerCase","formatCollectionName","wordsSet","i","length","has","splice","slice","pluralize","plural","join","renameDuplicateFieldNames","states","fieldMap","generateFieldMap","name","typeMap","size","hasTypeInName","has","toSnakeCase","split","pop","index","type","list","newName","set","Map","delete","field","fields","get","push","str","replace","toLowerCase","HASH_ALGORITHM","generateHash","payload","createHash","update","JSON","stringify","digest","slice","METADATA_HASH_BYTES","getMetadataStateFieldKey","field","strict","indexes","join","type","nullable","getScalarFields","name","path","scalarDef","parentIndexes","index","isStateDefinitionScalarTypeScalar","toSnakeCase","getStateDefinitionFields","fieldMap","Map","refCount","childState","scalars","resolveDefer","$scalars","sortKey","$id","fields","id","fromSortedField","childScalarDef","scalarFields","item","mapKey","value","get","set","key","length","values","StateSnapshot","collectionName","name","hash","fields","instance","relations","matches","origin","equals","existingFields","Map","map","item","getMetadataStateFieldKey","Object","values","every","originField","existsField","get","nullable","sync","targetFields","field","targetFieldNames","key","targetField","oldFieldName","overrideField","set","clone","assign","create","generateStateHash","state","generateHash","sort","relation","getMetadataStateRelationKey","index","states","toString","join","METADATA_HASH_DEFAULT_FIELD","METADATA_VERSION_DEFAULT_FIELD","MetadataState","StateSnapshot","fields","instance","reservedNames","relations","transforms","ctx","state","$name","collectionName","name","hash","version","scalars","Object","entries","resolveDefer","$scalars","$transforms","key","def","getScalarFields","field","NeuledgeError","Code","RESERVED_FIELD_NAME","push","getScalarRelations","fromDefinition","generateStateHash","ref","Array","isArray","type","states","map","path","index","HASH_KEY_ENCODING","MetadataSnapshot","typeMap","hashMap","keyMap","constructor","states","entity","hash","toString","type","fields","name","Object","values","findType","key","findStateByHash","findStateByKey","sync","snapshot","changes","hashKey","origin","deleted","clone","matches","push","i","Metadata","MetadataSnapshot","collections","constructor","states","stateGroups","groupStatesByCollectionName","ctx","allStates","name","metadataStates","map","state","MetadataState","fromDefinition","renameDuplicateFieldNames","MetadataCollection","push","listCollections","Object","values","getCollectionByMetadataState","collection","collectionName","NeuledgeError","Code","METADATA_LOAD_ERROR","getCollections","collectionNames","Set","def","findStateByKey","$name","add","sync","snapshot","changes","collectionStates","entry","entries","ensureStoreCollections","store","metadata","asyncLimit","pLimit","Promise","all","listCollections","map","collection","ensureStoreCollection","ensureCollection","indexes","Object","values","fields","import_p_limit","StoreMetadataStateVersion","V0","fromStoreMetadataState","getState","getType","doc","v","NeuledgeError","Code","UNSUPPORTED_METADATA","hash","assign","collectionName","name","fields","map","field","fromStoreMetadataStateField","relations","relation","fromStoreMetadataStateRelation","toStoreMetadataState","state","toStoreMetadataStateField","toStoreMetadataStateRelation","type","indexes","nullable","states","stateHashes","index","HASH_ENCODING","COLLECTION_FIND_LIMIT","getMetadataCollection","metadataCollectionName","hash","name","type","size","METADATA_HASH_BYTES","primaryKey","fields","sort","unique","indexes","key","payload","ensureMetadataCollection","store","metadataCollection","ensureCollection","collection","Object","values","getStoreMetadataSnapshot","snapshot","entities","getState","toString","res","StateSnapshot","getType","findType","NeuledgeError","Code","CORRUPTED_METADATA","find","limit","offset","nextOffset","doc","Buffer","state","fromStoreMetadataState","length","MetadataSnapshot","syncStoreMetadata","changes","inserts","updates","getStoreMetadataChanges","insert","documents","pLimit","Promise","all","map","set","update","where","$eq","change","push","toStoreMetadataState","entity","METADATA_SAVE_ERROR","DEFAULT_METADATA_COLLECTION_NAME","loadMetadata","store","metadataCollectionName","metadataCollection","getMetadataCollection","ensureMetadataCollection","metadata","Metadata","neuledgeGlob","stateDefinitions","values","snapshot","getStoreMetadataSnapshot","changes","sync","ensureStoreCollections","syncStoreMetadata","chooseStatesCollection","metadata","states","collections","getCollections","length","NeuledgeError","Code","NO_COLLECTIONS","MULTIPLE_COLLECTIONS","map","c","name","join","collection","stateNames","Set","s","$name","collectionStates","filter","has","toDocument","metadata","collection","entity","$state","$version","state","findStateByKey","NeuledgeError","Code","ENTITY_STATE_NOT_FOUND","document","reservedNames","hash","version","field","fields","name","getEntityValue","path","obj","pathKeys","split","value","key","undefined","toEntityList","metadata","collection","list","Object","assign","map","document","stateHash","reservedNames","hash","Buffer","isBuffer","getStateEntity","undefined","filter","entity","nextOffset","toEntityListOrThrow","entities","length","NeuledgeError","Code","DOCUMENT_NOT_FOUND","toMaybeEntity","toEntityOrThrow","state","findStateByHash","ENTITY_STATE_NOT_FOUND","toString","$state","name","$version","version","field","fields","path","rawValue","value","type","decode","setEntityValue","relation","relations","childDocument","childStateHash","childEntity","obj","pathKeys","split","i","key","convertRelationQueryOptions","metadata","collection","relationQueries","convert","res","statesRelations","states","map","state","resolveDefer","instance","$relations","key","query","referenceCollectionMap","getRelationReferenceCollections","stateRelations","values","reference","collectionMap","targerCollection","refCollections","fields","getSchemaFields","push","relCollection","reverse","by","getStoreJoinBy","queryStates","Map","i","entries","stateRelation","length","path","entry","get","set","relStates","queryStatesMap","$name","filter","NeuledgeError","Code","RELATION_STATE_NOT_FOUND","join","collections","getCollectionByMetadataState","relCollections","getCollections","fieldMap","field","slice","refField","name","delete","size","RELATION_FIELD_NOT_FOUND","keys","applyWhereRecordTerm","records","field","term","res","map","record","name","convertWhereScalarTerm","type","NeuledgeError","Code","QUERY_PARSING_ERROR","path","scalar","operator","value","Object","entries","assignWhereScalarOperator","applyWhereOperatorTerm","key","origin","scalarValue","encode","equal","$eq","Array","isArray","$nin","$ne","push","v","convertWhereRecord","states","collection","where","applyFilterRecord","reservedNames","hash","$in","map","s","records","filter","key","term","Object","entries","choices","schema","length","NeuledgeError","Code","QUERY_PARSING_ERROR","base","choice","push","field","applyWhereRecordTerm","applyWhereState","operator","applyWhereOperatorRecord","applyWhereEveryOperatorRecord","applyWhereNotEqualRecord","applyWhereInOperatorRecord","applyWhereNotInOperatorRecord","value","applyWhereOperatorRecordValue","res","Array","isArray","values","applyWhereOperatorTerm","name","type","applyFilter","records","collection","filter","Array","isArray","$or","flatMap","w","applyFilterRecord","convertWhereFilterQuery","states","collection","where","filter","convertWhereFilter","convertFilterQuery","res","convertWhere","applyFilter","length","$or","Array","isArray","flatMap","w","convertWhereRecord","convertUniqueFilterQuery","states","collection","unique","filter","where","convertUniqueFilter","res","convertUnique","applyFilter","length","$or","NeuledgeError","Code","QUERY_EXECUTION_ERROR","records","reservedNames","hash","$in","map","s","key","value","Object","entries","choices","schema","QUERY_PARSING_ERROR","base","choice","field","push","applyWhereRecordTerm","$eq","convertSelectQuery","collection","select","convertSelect","convertJoinSelectQuery","convertLeftJoinSelectQuery","res","reservedNames","hash","version","key","fieldName","getSchemaFieldNames","convertPopulateOneQuery","metadata","collection","populateOne","leftJoin","convertPopulateOne","convertRelationQueryOptions","by","query","convertLeftJoinSelectQuery","convertFilterQuery","states","convertExpandQuery","convertExpandQuery","metadata","collection","expand","innerJoin","convertExpand","convertRelationQueryOptions","by","query","convertJoinSelectQuery","convertFilterQuery","states","convertPopulateOneQuery","convertMatchQuery","metadata","collection","match","innerJoin","convertMatch","convertRelationQueryOptions","by","query","convertFilterQuery","states","retrieveEntities","entities","returns","select","Object","assign","map","entity","oldEntity","nextOffset","projectEntity","projectedEntity","$state","$version","key","value","entries","execInitMany","engine","options","metadata","collection","chooseStatesCollection","states","state","fn","method","mutation","NeuledgeError","Code","INVALID_MUTATION","String","newEntities","Promise","all","args","map","entities","entity","$version","documents","toDocument","insertedIds","store","insert","updatedEntities","oldDoc","i","document","toEntityOrThrow","oldEntity","retrieveEntities","execInitOne","res","DEFAULT_QUERY_LIMIT","convertLimitQuery","options","limit","checkLimitedList","list","length","process","env","NODE_ENV","console","warn","trace","convertOffsetQuery","offset","convertSortQuery","collection","sort","reverse","indexKey","slice","state","states","index","instance","$indexes","fields","NeuledgeError","Code","UNKNOWN_SORT_INDEX","res","key","UNKNOWN_SORT_DIRECTION","field","name","getSchemaFieldNames","execFindMany","engine","options","metadata","states","collection","chooseStatesCollection","list","checkLimitedList","store","find","convertSelectQuery","convertExpandQuery","convertPopulateOneQuery","convertWhereFilterQuery","convertOffsetQuery","convertLimitQuery","convertSortQuery","toEntityList","execFindUnique","document","convertUniqueFilterQuery","limit","toMaybeEntity","execFindUniqueOrThrow","toEntityOrThrow","execFindFirst","execFindFirstOrThrow","import_p_limit","alterEntityList","states","entities","method","args","asyncLimit","pLimit","Promise","all","map","entity","alterEntity","$state","$version","thisArg","state","NeuledgeError","Code","INTERNAL_ERROR","fn","mutation","mutated","call","INVALID_MUTATION","String","import_p_limit","alterStoreDocuments","store","collection","documents","updates","asyncLimit","pLimit","deleteDocuments","res","Promise","all","map","document","index","updated","push","updateStoreDocument","length","deleteStoreDocuments","setEntries","Object","entries","filter","key","value","update","where","getWhereRecordByPrimaryKeys","set","fromEntries","limit","affectedCount","delete","getWhereByPrimaryKeys","$or","keys","primaryKey","fields","$eq","reservedNames","hash","version","getStateDefinitionMap","states","map","state","$name","ALTER_VERSION_RETRIES","execAlterMany","engine","options","ctx","preprareAlter","documents","store","find","storeFilters","alterDocuments","retries","leftDocs","entities","size","length","filter","document","has","getDocumentKey","collection","retrieveEntities","values","NeuledgeError","Code","VERSION_MISMATCH","execAlterOne","res","metadata","states","chooseStatesCollection","createStoreFilters","isAlterDeleteOnly","deleteDocuments","Map","getStateDefinitionMap","convertUniqueFilterQuery","convertWhereFilterQuery","convertMatchQuery","type","convertLimitQuery","limit","select","match","state","mutation","method","virtual","delete","affectedCount","DEFAULT_QUERY_LIMIT","convert","endsWith","toEntityListOrThrow","toEntityList","list","checkLimitedList","updated","alterEntityList","args","updatedDocs","map","entity","toDocument","success","alterStoreDocuments","i","flag","entries","key","set","oldEntity","JSON","stringify","Object","keys","primaryKey","fields","MutationGenerator","type","states","generator","Proxy","get","_","method","hasMutation","args","Array","from","length","fill","slice","undefined","ownKeys","Object","keys","filter","has","every","state","fn","mutation","startsWith","NeuledgeEngine","store","metadata","constructor","options","loadMetadata","metadataCollectionName","catch","NeuledgeError","wrap","findMany","states","QueryClass","type","select","exec","execFindMany","findUnique","unique","execFindUnique","findUniqueOrThrow","execFindUniqueOrThrow","findFirst","execFindFirst","findFirstOrThrow","execFindFirstOrThrow","initMany","state","MutationGenerator","execInitMany","initOne","execInitOne","alterMany","returns","execAlterMany","alterFirst","execAlterOne","alterFirstOrThrow","alterUnique","alterUniqueOrThrow","ready","createEntityList","entries","nextOffset","Object","assign"]}