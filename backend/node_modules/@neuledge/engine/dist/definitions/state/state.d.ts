import { Defer, Deferred } from '../defer';
import { StateDefinitionId as StateDefinitionId, StateDefinitionIndex } from './indexes';
import { StateDefinitionRelation } from './relations';
import { StateDefintionScalar } from './scalar';
import { SortDefinitionKey } from './sort';
import { StateDefinitionUnique, StateDefinitionWhereRecord } from './find';
export interface StateDefinition<N extends string = string, T = any> {
    $name: N;
    $id: StateDefinitionId<T>;
    $scalars: Defer<{
        [K in keyof T]: StateDefintionScalar<T[K]>;
    }>;
    $filter: StateDefinitionWhereRecord<T>;
    $where: StateDefinitionWhereRecord<T>;
    $unique: StateDefinitionUnique<T>;
    $relations?: Defer<Record<string, StateDefinitionRelation>>;
    $transforms?: Defer<readonly StateDefinition[]>;
    $indexes?: Record<string, StateDefinitionIndex<T>>;
    new (...args: any): T;
}
export type StateType<S extends StateDefinition> = S extends new (...args: any) => infer R ? R : never;
export type StateName<S extends StateDefinition = StateDefinition> = S['$name'];
export type StateId<S extends StateDefinition> = Pick<StateType<S>, SortDefinitionKey<S['$id']['fields'][number]>>;
export type StateFilter<S extends StateDefinition> = S['$filter'];
export type StateWhere<S extends StateDefinition> = S['$where'];
export type StateUnique<S extends StateDefinition> = S['$unique'];
export type StateIndexes<S extends StateDefinition> = NonNullable<S['$indexes']>;
export type StateRelations<S extends StateDefinition> = Deferred<S['$relations'], Record<never, never>>;
//# sourceMappingURL=state.d.ts.map