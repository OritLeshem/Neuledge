"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BigIntScalar: () => BigIntScalar,
  BooleanScalar: () => BooleanScalar,
  BufferScalar: () => BufferScalar,
  DateTime: () => DateTime,
  DateTimeScalar: () => DateTimeScalar,
  EmailScalar: () => EmailScalar,
  FalseScalar: () => FalseScalar,
  IntegerScalar: () => IntegerScalar,
  NumberScalar: () => NumberScalar,
  ObjectScalar: () => ObjectScalar,
  Required: () => Required,
  StringScalar: () => StringScalar,
  TrueScalar: () => TrueScalar,
  URLScalar: () => URLScalar,
  UnknownScalar: () => UnknownScalar,
  createCallable: () => createCallable,
  createCallableScalar: () => createCallableScalar,
  createScalarGenerator: () => createScalarGenerator,
  parseParametersInput: () => parseParametersInput,
  runtime: () => runtime_exports,
  types: () => types_exports
});
module.exports = __toCommonJS(src_exports);

// src/generator.ts
var createScalarGenerator = /* @__PURE__ */ __name(({ name, ...props }, generator) => {
  const target = /* @__PURE__ */ __name((parameters2) => generator(parameters2, getParametersKey(parameters2)), "target");
  Object.defineProperty(target, "name", {
    value: name,
    writable: false
  });
  return Object.assign(target, props);
}, "createScalarGenerator");
var createCallableScalar = /* @__PURE__ */ __name((parameters2, generator) => {
  const { name, ...props } = generator({}, "");
  const target = /* @__PURE__ */ __name((parameters3) => generator(parameters3, getParametersKey(parameters3)), "target");
  Object.defineProperty(target, "name", {
    value: name,
    writable: false
  });
  return Object.assign(target, {
    parameters: parameters2,
    ...props
  });
}, "createCallableScalar");
var getParametersKey = /* @__PURE__ */ __name((parameters2) => {
  const parametersStr = Object.entries(parameters2).filter(([, value]) => value !== null).sort(([keyA], [keyB]) => keyA.localeCompare(keyB)).map(([key, value]) => `${escapeKey(key)}: ${escapeValue(value)}`).join(", ");
  if (!parametersStr) {
    return "";
  }
  return `(${parametersStr})`;
}, "getParametersKey");
var escapeKey = /* @__PURE__ */ __name((key) => /^[_a-z]\w*$/i.test(key) ? key : JSON.stringify(key), "escapeKey");
var escapeValue = /* @__PURE__ */ __name((value) => {
  switch (typeof value) {
    case "string":
    default: {
      return JSON.stringify(value);
    }
    case "number":
    case "boolean": {
      return String(value);
    }
  }
}, "escapeValue");

// src/callable.ts
var createCallable = /* @__PURE__ */ __name((name, parameters2, returnType2, callable) => {
  Object.defineProperty(callable, "name", {
    value: name,
    writable: false
  });
  return Object.assign(callable, {
    parameters: parameters2,
    returnType: returnType2
  });
}, "createCallable");

// src/primitives/big-int.ts
var import_zod = require("zod");

// src/primitives/shapes.ts
var getBigIntShape = /* @__PURE__ */ __name((minRange, maxRange) => {
  const shape = {
    type: "number",
    scale: 0
  };
  if (minRange == null) {
    return shape;
  }
  shape.unsigned = (minRange ?? -1n) >= 0n;
  if (maxRange == null) {
    return shape;
  }
  shape.precision = Math.max((maxRange >= 0n ? maxRange : -maxRange).toString().length, (minRange >= 0n ? minRange : -minRange).toString().length);
  return shape;
}, "getBigIntShape");
var booleanShape = {
  type: "boolean"
};
var getBinaryShape = /* @__PURE__ */ __name((size) => ({
  type: "binary",
  size
}), "getBinaryShape");
var dateTimeShape = {
  type: "date-time"
};
var getIntergerShape = /* @__PURE__ */ __name((minRange = -Infinity, maxRange = Infinity) => {
  const shape = {
    type: "number",
    scale: 0
  };
  if (minRange >= 0) {
    shape.unsigned = true;
    if (maxRange <= 255) {
      shape.size = 1;
    } else if (maxRange <= 65535) {
      shape.size = 2;
    } else if (maxRange <= 4294967295) {
      shape.size = 4;
    } else {
      shape.size = 8;
    }
    return shape;
  } else {
    if (minRange >= -128 && maxRange <= 127) {
      shape.size = 1;
    } else if (minRange >= -32768 && maxRange <= 32767) {
      shape.size = 2;
    } else if (minRange >= -2147483648 && maxRange <= 2147483647) {
      shape.size = 4;
    } else {
      shape.size = 8;
    }
  }
  return shape;
}, "getIntergerShape");
var getNumberShape = /* @__PURE__ */ __name((precision, scale) => ({
  type: "number",
  size: 8,
  precision,
  scale
}), "getNumberShape");
var jsonShape = {
  type: "json"
};
var getStringShape = /* @__PURE__ */ __name((size) => ({
  type: "string",
  size
}), "getStringShape");

// src/primitives/big-int.ts
var core = {
  type: "Scalar",
  shape: getBigIntShape(),
  name: "BigInt",
  description: "The `BigInt` scalar type represents non-fractional signed whole numeric values that may be larger than 2^53.",
  encode: (value) => import_zod.z.bigint().parse(toBigInt(value))
};
var BigIntScalar = createCallableScalar({
  min: {
    type: core,
    nullable: true
  },
  max: {
    type: core,
    nullable: true
  },
  after: {
    type: core,
    nullable: true
  },
  below: {
    type: core,
    nullable: true
  }
}, ({ min, max, after, below }, key) => {
  let validator = import_zod.z.bigint();
  let minRange = null;
  let maxRange = null;
  if (min != null) {
    minRange = min;
    validator = validator.refine((value) => value >= min, {
      message: `Must be greater than or equal to ${min}`
    });
  }
  if (max != null) {
    maxRange = max;
    validator = validator.refine((value) => value <= max, {
      message: `Must be less than or equal to ${max}`
    });
  }
  if (after != null) {
    if (min != null) {
      throw new TypeError("Cannot set both `min` and `after`");
    }
    minRange = after + 1n;
    validator = validator.refine((value) => value > after, {
      message: `Must be greater than ${after}`
    });
  }
  if (below != null) {
    if (max != null) {
      throw new TypeError("Cannot set both `max` and `below`");
    }
    maxRange = below - 1n;
    validator = validator.refine((value) => value < below, {
      message: `Must be less than ${below}`
    });
  }
  return {
    ...core,
    name: `BigInt${key}`,
    shape: getBigIntShape(minRange, maxRange),
    encode: (value) => validator.parse(toBigInt(value))
  };
});
var toBigInt = /* @__PURE__ */ __name((value) => {
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "number") {
    return BigInt(value);
  }
  return value;
}, "toBigInt");

// src/primitives/boolean.ts
var import_zod2 = require("zod");
var BooleanScalar = {
  type: "Scalar",
  shape: booleanShape,
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  encode: (value) => import_zod2.z.boolean().or(trueLiterals).or(falseLiterals).parse(value)
};
var TrueScalar = {
  type: "Scalar",
  shape: booleanShape,
  name: "True",
  description: "The `True` scalar type represents only `true` value.",
  encode: (value) => import_zod2.z.literal(true).or(trueLiterals).parse(value)
};
var FalseScalar = {
  type: "Scalar",
  shape: booleanShape,
  name: "False",
  description: "The `False` scalar type represents only `false` value.",
  encode: (value) => import_zod2.z.literal(false).or(falseLiterals).parse(value)
};
var trueLiterals = import_zod2.z.union([
  import_zod2.z.literal(1),
  import_zod2.z.literal("true"),
  import_zod2.z.literal("yes"),
  import_zod2.z.literal("True"),
  import_zod2.z.literal("Yes"),
  import_zod2.z.literal("TRUE"),
  import_zod2.z.literal("YES")
]).transform(() => true);
var falseLiterals = import_zod2.z.union([
  import_zod2.z.literal(0),
  import_zod2.z.literal("false"),
  import_zod2.z.literal("no"),
  import_zod2.z.literal("False"),
  import_zod2.z.literal("No"),
  import_zod2.z.literal("FALSE"),
  import_zod2.z.literal("NO")
]).transform(() => false);

// src/primitives/buffer.ts
var import_consumers = require("stream/consumers");
var import_zod4 = require("zod");

// src/primitives/integer.ts
var import_zod3 = require("zod");
var core2 = {
  type: "Scalar",
  shape: getIntergerShape(),
  name: "Integer",
  description: "The `Integer` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^53 - 1) and 2^53 - 1.",
  encode: (value) => import_zod3.z.number().int().parse(value)
};
var IntegerScalar = createCallableScalar({
  min: {
    type: core2,
    nullable: true
  },
  max: {
    type: core2,
    nullable: true
  },
  after: {
    type: core2,
    nullable: true
  },
  below: {
    type: core2,
    nullable: true
  }
}, ({ min, max, after, below }, key) => {
  let validator = import_zod3.z.number().int();
  let minRange = -Infinity;
  let maxRange = Infinity;
  if (min != null) {
    minRange = min;
    validator = validator.min(min);
  }
  if (max != null) {
    maxRange = max;
    validator = validator.max(max);
  }
  if (after != null) {
    if (min != null) {
      throw new TypeError("Cannot set both `min` and `after`");
    }
    minRange = Math.floor(after) + 1;
    validator = validator.gt(after);
  }
  if (below != null) {
    if (max != null) {
      throw new TypeError("Cannot set both `max` and `below`");
    }
    maxRange = Math.ceil(below) - 1;
    validator = validator.lt(below);
  }
  return {
    ...core2,
    name: `Integer${key}`,
    shape: getIntergerShape(minRange, maxRange),
    encode: (value) => validator.parse(value)
  };
});

// src/primitives/buffer.ts
var BufferScalar = createCallableScalar({
  min: {
    type: IntegerScalar({
      min: 0
    }),
    nullable: true
  },
  max: {
    type: IntegerScalar({
      min: 0
    }),
    nullable: true
  }
}, ({ min, max }, key) => {
  let validator = import_zod4.z.instanceof(Buffer);
  if (min != null) {
    validator = validator.refine((value) => value.length >= min, {
      message: `Expected buffer with at least ${min} bytes`
    });
  }
  if (max != null) {
    validator = validator.refine((value) => value.length <= max, {
      message: `Expected buffer with at most ${max} bytes`
    });
  }
  return {
    type: "Scalar",
    shape: getBinaryShape(max),
    name: `Buffer${key}`,
    description: "The `Buffer` scalar type represents a binary data with a variable length.",
    encode: (value) => validator.parse(toBuffer(value))
  };
});
var numbersBuffer = import_zod4.z.array(import_zod4.z.number().int().min(0).max(255));
var toBuffer = /* @__PURE__ */ __name((value) => {
  if (value instanceof Buffer) {
    return value;
  }
  if (typeof value === "string") {
    return Buffer.from(value, "base64");
  }
  if (value instanceof Uint8Array || value instanceof ArrayBuffer) {
    return Buffer.from(value);
  }
  if (Array.isArray(value)) {
    return Buffer.from(numbersBuffer.parse(value));
  }
  return import_consumers.buffer;
}, "toBuffer");

// src/primitives/date-time.ts
var import_zod5 = require("zod");
var MIN_NUMERIC_DATE = Date.UTC(2e3, 0, 1);
var MAX_NUMERIC_DATE = Date.UTC(2100, 0, 1);
var core3 = {
  type: "Scalar",
  shape: dateTimeShape,
  name: "DateTime",
  description: "The `DateTime` scalar type represents a date and time following the ISO-8601 standard.",
  encode: (value) => import_zod5.z.date().parse(toDate(value))
};
var DateTimeScalar = createCallableScalar({
  min: {
    type: core3,
    nullable: true
  },
  max: {
    type: core3,
    nullable: true
  }
}, ({ min, max }, key) => {
  let validator = import_zod5.z.date();
  if (min != null) {
    validator = validator.min(min);
  }
  if (max != null) {
    validator = validator.max(max);
  }
  return {
    ...core3,
    name: `DateTime${key}`,
    encode: (value) => validator.parse(toDate(value))
  };
});
var stringDate = import_zod5.z.string().datetime({
  offset: true
});
var numericDate = import_zod5.z.number().min(MIN_NUMERIC_DATE).max(MAX_NUMERIC_DATE);
var toDate = /* @__PURE__ */ __name((value) => {
  if (value instanceof Date) {
    return value;
  }
  if (typeof value === "string") {
    return new Date(stringDate.parse(value));
  }
  if (typeof value === "number") {
    return new Date(numericDate.parse(value));
  }
  return value;
}, "toDate");

// src/primitives/number.ts
var import_zod6 = require("zod");
var core4 = {
  type: "Scalar",
  shape: getNumberShape(),
  name: "Number",
  description: "The `Number` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).",
  encode: (value) => import_zod6.z.number().parse(value)
};
var validatePrecision = /* @__PURE__ */ __name((precision, scale, max, below) => {
  if (precision < scale) {
    throw new TypeError("`precision` must be greater than or equal to `scale`");
  }
  const digits = precision - scale;
  const digitsBelow = 10 ** digits;
  if (max != null) {
    if (max >= digitsBelow) {
      throw new TypeError(`Cannot set 'max' greater than equal ${digitsBelow} for 'precision' of ${precision} and 'scale' of ${scale}`);
    }
  } else if (below == null) {
    below = digitsBelow;
  } else {
    if (below > digitsBelow) {
      throw new TypeError(`Cannot set 'below' greater than ${digitsBelow} for 'precision' of ${precision} and 'scale' of ${scale}`);
    }
  }
  return {
    below
  };
}, "validatePrecision");
var NumberScalar = createCallableScalar({
  min: {
    type: core4,
    nullable: true
  },
  max: {
    type: core4,
    nullable: true
  },
  after: {
    type: core4,
    nullable: true
  },
  below: {
    type: core4,
    nullable: true
  },
  finite: {
    type: BooleanScalar,
    nullable: true
  },
  precision: {
    type: IntegerScalar({
      min: 1,
      max: 1e3
    }),
    nullable: true
  },
  scale: {
    type: IntegerScalar({
      min: 1,
      max: 1e3
    }),
    nullable: true
  }
}, ({ min, max, after, below, finite, precision, scale }, key) => {
  let validator = import_zod6.z.number();
  if (precision != null && scale != null) {
    ({ below } = validatePrecision(precision, scale, max, below));
  }
  if (min != null) {
    validator = validator.min(min);
  }
  if (max != null) {
    validator = validator.max(max);
  }
  if (after != null) {
    if (min != null) {
      throw new TypeError("Cannot set both `min` and `after`");
    }
    validator = validator.gt(after);
  }
  if (below != null) {
    if (max != null) {
      throw new TypeError("Cannot set both `max` and `below`");
    }
    validator = validator.lt(below);
  }
  if (finite) {
    validator = validator.finite();
  }
  return {
    ...core4,
    name: `Number${key}`,
    shape: getNumberShape(precision, scale),
    encode: (value) => validator.parse(value)
  };
});

// src/primitives/object.ts
var import_zod7 = require("zod");
var ObjectScalar = {
  type: "Scalar",
  shape: jsonShape,
  name: "Object",
  description: "The `Object` scalar type represents any arbitrary object.",
  encode: (value) => import_zod7.z.object({}).parse(value)
};

// src/primitives/string.ts
var import_zod8 = require("zod");
var core5 = {
  type: "Scalar",
  shape: getStringShape(),
  name: `String`,
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used to represent free-form human-readable text.",
  encode: (value) => import_zod8.z.string().parse(value)
};
var formatValidator = /* @__PURE__ */ __name(({ trim, normalize, lowercase, uppercase }) => {
  let validator = import_zod8.z.string();
  if (trim) {
    validator = validator.trim();
  }
  if (normalize) {
    validator = validator.transform((value) => value.normalize());
  }
  if (lowercase) {
    if (uppercase) {
      throw new TypeError("`lowercase` and `uppercase` cannot be used together");
    }
    validator = validator.transform((value) => value.toLowerCase());
  } else if (uppercase) {
    validator = validator.transform((value) => value.toUpperCase());
  }
  return validator;
}, "formatValidator");
var StringScalar = createCallableScalar({
  min: {
    type: IntegerScalar({
      min: 0
    }),
    nullable: true
  },
  max: {
    type: IntegerScalar({
      min: 0
    }),
    nullable: true
  },
  trim: {
    type: BooleanScalar,
    nullable: true
  },
  lowercase: {
    type: BooleanScalar,
    nullable: true
  },
  uppercase: {
    type: BooleanScalar,
    nullable: true
  },
  normalize: {
    type: BooleanScalar,
    nullable: true
  },
  startsWith: {
    type: core5,
    nullable: true
  },
  endsWith: {
    type: core5,
    nullable: true
  },
  regex: {
    type: core5,
    nullable: true
  }
}, ({ min, max, startsWith, endsWith, regex, ...format }, key) => {
  let validator = formatValidator(format);
  if (min != null) {
    validator = validator.min(min);
  }
  if (max != null) {
    if (min != null && min > max) {
      throw new TypeError("`min` cannot be greater than `max`");
    }
    validator = validator.max(max);
  }
  if (startsWith != null) {
    validator = validator.refine((value) => value.startsWith(startsWith), {
      message: `Must start with "${startsWith}"`
    });
  }
  if (endsWith != null) {
    validator = validator.refine((value) => value.endsWith(endsWith), {
      message: `Must end with "${endsWith}"`
    });
  }
  if (regex != null) {
    validator = validator.regex(new RegExp(regex));
  }
  return {
    ...core5,
    shape: getStringShape(max),
    name: `String${key}`,
    encode: (value) => validator.parse(value)
  };
});

// src/primitives/unknown.ts
var UnknownScalar = {
  type: "Scalar",
  shape: jsonShape,
  name: "Unknown",
  description: "The `Unknown` scalar type represents any value that can be represented by JSON.",
  encode: (value) => value
};

// src/callables/date-time.ts
var DateTime = createCallable("DateTime", {
  now: {
    type: DateTimeScalar,
    nullable: true
  }
}, {
  type: DateTimeScalar
}, ({ now }) => {
  if (now != null) {
    return new Date(now);
  }
  return /* @__PURE__ */ new Date();
});

// src/callables/required.ts
var parameters = {
  value: {
    type: UnknownScalar,
    nullable: true,
    generic: "T"
  },
  message: {
    type: StringScalar,
    nullable: true
  }
};
var returnType = {
  type: UnknownScalar,
  generic: "T"
};
var Required = createCallable("Required", parameters, returnType, ({ value, message }) => {
  if (value == null) {
    throw new TypeError(message ?? "Required value is null or undefined");
  }
  return value;
});

// src/commons/email.ts
var import_zod9 = require("zod");
var EMAIL_DOMAIN_MAX_LENGTH = 255;
var EMAIL_MAX_LENGTH = 320;
var EmailScalar = createCallableScalar({
  at: {
    type: StringScalar({
      max: EMAIL_DOMAIN_MAX_LENGTH,
      regex: "^[a-zA-Z0-9]+([\\.-]?[a-zA-Z0-9]+)*(\\.[a-zA-Z0-9]{2,3})+$",
      trim: true
    }),
    nullable: true
  },
  lowercase: {
    type: BooleanScalar,
    nullable: true
  }
}, ({ at, lowercase }, key) => {
  let validator = import_zod9.z.string().trim().email();
  if (lowercase) {
    validator = validator.transform((value) => value.toLowerCase());
  }
  if (at != null) {
    validator = validator.refine((value) => value.endsWith(`@${at}`), {
      message: `Must be an email address at "${at}"`
    });
  }
  return {
    type: "Scalar",
    shape: getStringShape(EMAIL_MAX_LENGTH),
    name: `Email${key}`,
    description: "The `Email` scalar type represents a string email address.",
    encode: (value) => validator.parse(value)
  };
});

// src/commons/url.ts
var import_zod10 = require("zod");
var DOMAIN_MAX_LENGTH = 253;
var URLScalar = createCallableScalar({
  domain: {
    type: StringScalar({
      max: DOMAIN_MAX_LENGTH,
      regex: "^([a-zA-Z0-9]+([\\.-]?[a-zA-Z0-9]+)*)+$",
      trim: true
    }),
    nullable: true
  },
  protocol: {
    type: StringScalar({
      max: 10,
      regex: "^[a-zA-Z0-9]+$",
      trim: true
    }),
    nullable: true
  },
  secure: {
    type: BooleanScalar,
    nullable: true
  }
}, ({ domain, secure, protocol }, key) => {
  let validator = import_zod10.z.string().trim().url();
  if (domain != null) {
    const regex = new RegExp(`://([a-z0-9]+(-[a-z0-9]+)*\\.)*${domain.replace(/\./g, "\\.")}/`, "i");
    validator = validator.refine((value) => value.match(regex), {
      message: `Must be a URL with domain "${domain}"`
    });
  }
  if (secure != null) {
    if (protocol != null) {
      throw new TypeError('Cannot specify both "secure" and "protocol"');
    }
    validator = validator.refine((value) => value.startsWith("https://"), {
      message: `Must be a secure URL`
    });
  } else if (protocol != null) {
    validator = validator.refine((value) => value.startsWith(`${protocol}://`), {
      message: `Must be a URL with protocol "${protocol}"`
    });
  }
  return {
    type: "Scalar",
    shape: getStringShape(),
    name: `URL${key}`,
    description: "The `URL` scalar type represents a string URL.",
    encode: (value) => validator.parse(value)
  };
});

// src/parameters/parse.ts
var parseParametersInput = /* @__PURE__ */ __name((parameters2) => {
  const entries = Object.entries(parameters2);
  return (input) => Object.fromEntries(entries.filter(([key, parameter]) => !parameter.nullable || key in input).map(([key, parameter]) => {
    const value = input[key];
    if (parameter.nullable && value == null) {
      return [
        key,
        value
      ];
    }
    return [
      key,
      parameter.type.encode(value)
    ];
  }));
}, "parseParametersInput");

// src/types.ts
var types_exports = {};
__export(types_exports, {
  BigInt: () => BigIntScalar,
  Boolean: () => BooleanScalar,
  Buffer: () => BufferScalar,
  DateTime: () => DateTimeScalar,
  Email: () => EmailScalar,
  False: () => FalseScalar,
  Integer: () => IntegerScalar,
  Number: () => NumberScalar,
  Object: () => ObjectScalar,
  String: () => StringScalar,
  True: () => TrueScalar,
  URL: () => URLScalar
});

// src/runtime.ts
var runtime_exports = {};
__export(runtime_exports, {
  DateTime: () => DateTime,
  Required: () => Required
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BigIntScalar,
  BooleanScalar,
  BufferScalar,
  DateTime,
  DateTimeScalar,
  EmailScalar,
  FalseScalar,
  IntegerScalar,
  NumberScalar,
  ObjectScalar,
  Required,
  StringScalar,
  TrueScalar,
  URLScalar,
  UnknownScalar,
  createCallable,
  createCallableScalar,
  createScalarGenerator,
  parseParametersInput,
  runtime,
  types
});
//# sourceMappingURL=index.js.map