{"version":3,"sources":["../src/generator.ts","../src/callable.ts","../src/primitives/big-int.ts","../src/primitives/shapes.ts","../src/primitives/boolean.ts","../src/primitives/buffer.ts","../src/primitives/integer.ts","../src/primitives/date-time.ts","../src/primitives/number.ts","../src/primitives/object.ts","../src/primitives/string.ts","../src/primitives/unknown.ts","../src/callables/date-time.ts","../src/callables/required.ts","../src/commons/email.ts","../src/commons/url.ts","../src/parameters/parse.ts","../src/types.ts","../src/runtime.ts"],"sourcesContent":["import { StoreValueShapeType } from '@neuledge/store';\nimport { ParametersType, Parameters } from './parameters';\nimport { Scalar } from './scalar';\n\nexport interface ScalarGenerator<\n  P extends Parameters = Parameters,\n  S extends Scalar = Scalar,\n> {\n  type: 'ScalarGenerator';\n  name: string;\n  description?: string;\n  deprecated?: string | true;\n  parameters: P;\n  (args: ParametersType<P>): S;\n}\n\nexport interface CallableScalar<\n  P extends Parameters = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Type = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Input = Type,\n  Value = Type,\n  Encoding extends StoreValueShapeType<Value> = StoreValueShapeType<Value>,\n> extends Scalar<Type, Input, Value, Encoding> {\n  parameters: P;\n  (args: ParametersType<P>): Scalar<Type, Input, Value>;\n}\n\nexport const createScalarGenerator = <P extends Parameters, S extends Scalar>(\n  { name, ...props }: Pick<ScalarGenerator<P, S>, keyof ScalarGenerator<P, S>>,\n  generator: (\n    args: ParametersType<P> | Record<string, never>,\n    key: string,\n  ) => S,\n): ScalarGenerator<P, S> => {\n  const target = (parameters: ParametersType<P>): S =>\n    generator(parameters, getParametersKey(parameters));\n\n  Object.defineProperty(target, 'name', { value: name, writable: false });\n\n  return Object.assign(target, props);\n};\n\nexport const createCallableScalar = <\n  P extends Parameters,\n  Type,\n  Input,\n  Value,\n  Encoding extends StoreValueShapeType<Value>,\n>(\n  parameters: P,\n  generator: (\n    args: ParametersType<P> | Record<string, never>,\n    key: string,\n  ) => Scalar<Type, Input, Value, Encoding>,\n): CallableScalar<P, Type, Input, Value, Encoding> => {\n  const { name, ...props } = generator({}, '');\n\n  const target = (parameters: ParametersType<P>): Scalar<Type, Input, Value> =>\n    generator(parameters, getParametersKey(parameters));\n\n  Object.defineProperty(target, 'name', { value: name, writable: false });\n\n  return Object.assign(target, { parameters, ...props });\n};\n\nconst getParametersKey = <P extends Parameters>(\n  parameters: ParametersType<P>,\n): string => {\n  const parametersStr = Object.entries(parameters)\n    .filter(([, value]) => value !== null)\n    .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))\n    .map(([key, value]) => `${escapeKey(key)}: ${escapeValue(value)}`)\n    .join(', ');\n\n  if (!parametersStr) {\n    return '';\n  }\n\n  return `(${parametersStr})`;\n};\n\nconst escapeKey = (key: string): string =>\n  /^[_a-z]\\w*$/i.test(key) ? key : JSON.stringify(key);\n\nconst escapeValue = (value: unknown): string => {\n  switch (typeof value) {\n    case 'string':\n    default: {\n      return JSON.stringify(value);\n    }\n\n    case 'number':\n    case 'boolean': {\n      return String(value);\n    }\n  }\n};\n","import { ScalarType } from './scalar';\nimport { Parameter, Parameters, ParametersType } from './parameters';\n\nexport interface Callable<\n  P extends Parameters = Parameters,\n  R extends Parameter = Parameter,\n> {\n  name: string;\n  parameters: P;\n  returnType: R;\n  (args: ParametersType<P>): Resolveable<ReturnParameterType<R>>;\n}\n\nexport type ReturnParameterType<P extends Parameter> =\n  | (P extends Parameter<infer S> ? ScalarType<S> : never)\n  | (P['nullable'] extends true ? null : never);\n\ntype Resolveable<T> = T | PromiseLike<T>;\n\nexport const createCallable = <P extends Parameters, R extends Parameter>(\n  name: string,\n  parameters: P,\n  returnType: R,\n  callable: (args: ParametersType<P>) => Resolveable<ReturnParameterType<R>>,\n): Callable<P, R> => {\n  Object.defineProperty(callable, 'name', { value: name, writable: false });\n\n  return Object.assign(callable, { parameters, returnType });\n};\n","import { createCallableScalar } from '@/generator';\nimport { Scalar } from '@/scalar';\nimport { z, ZodType } from 'zod';\nimport { getBigIntShape } from './shapes';\n\nexport type BigIntScalar = bigint;\ntype BigIntScalarInput = bigint | number;\n\nconst core: Scalar<BigIntScalar, BigIntScalarInput> = {\n  type: 'Scalar',\n  shape: getBigIntShape(),\n  name: 'BigInt',\n  description:\n    'The `BigInt` scalar type represents non-fractional signed whole numeric values that may be larger than 2^53.',\n  encode: (value) => z.bigint().parse(toBigInt(value)),\n};\n\nexport const BigIntScalar = createCallableScalar(\n  {\n    min: { type: core, nullable: true },\n    max: { type: core, nullable: true },\n    after: { type: core, nullable: true },\n    below: { type: core, nullable: true },\n  },\n  (\n    { min, max, after, below },\n    key,\n  ): Scalar<BigIntScalar, BigIntScalarInput> => {\n    let validator: ZodType<bigint> = z.bigint();\n    let minRange: bigint | null = null;\n    let maxRange: bigint | null = null;\n\n    if (min != null) {\n      minRange = min;\n      validator = validator.refine((value) => value >= min, {\n        message: `Must be greater than or equal to ${min}`,\n      });\n    }\n\n    if (max != null) {\n      maxRange = max;\n      validator = validator.refine((value) => value <= max, {\n        message: `Must be less than or equal to ${max}`,\n      });\n    }\n\n    if (after != null) {\n      if (min != null) {\n        throw new TypeError('Cannot set both `min` and `after`');\n      }\n\n      minRange = after + 1n;\n      validator = validator.refine((value) => value > after, {\n        message: `Must be greater than ${after}`,\n      });\n    }\n\n    if (below != null) {\n      if (max != null) {\n        throw new TypeError('Cannot set both `max` and `below`');\n      }\n\n      maxRange = below - 1n;\n      validator = validator.refine((value) => value < below, {\n        message: `Must be less than ${below}`,\n      });\n    }\n\n    return {\n      ...core,\n      name: `BigInt${key}`,\n      shape: getBigIntShape(minRange, maxRange),\n      encode: (value) => validator.parse(toBigInt(value)),\n    };\n  },\n);\n\nconst toBigInt = (value: BigIntScalarInput): BigIntScalar => {\n  if (typeof value === 'bigint') {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    return BigInt(value);\n  }\n\n  return value;\n};\n","import { StoreShape } from '@neuledge/store';\n\nexport const getBigIntShape = (\n  minRange?: bigint | null,\n  maxRange?: bigint | null,\n): StoreShape<'number'> => {\n  const shape: StoreShape<'number'> = { type: 'number', scale: 0 };\n\n  if (minRange == null) {\n    return shape;\n  }\n\n  shape.unsigned = (minRange ?? -1n) >= 0n;\n\n  if (maxRange == null) {\n    return shape;\n  }\n\n  shape.precision = Math.max(\n    (maxRange >= 0n ? maxRange : -maxRange).toString().length,\n    (minRange >= 0n ? minRange : -minRange).toString().length,\n  );\n\n  return shape;\n};\n\nexport const booleanShape: StoreShape<'boolean'> = { type: 'boolean' };\n\nexport const getBinaryShape = (size?: number | null): StoreShape<'binary'> => ({\n  type: 'binary',\n  size,\n});\n\nexport const dateTimeShape: StoreShape<'date-time'> = { type: 'date-time' };\n\nexport const getIntergerShape = (\n  minRange = -Infinity,\n  maxRange = Infinity,\n): StoreShape<'number'> => {\n  const shape: StoreShape<'number'> = { type: 'number', scale: 0 };\n\n  if (minRange >= 0) {\n    shape.unsigned = true;\n\n    if (maxRange <= 255) {\n      shape.size = 1;\n    } else if (maxRange <= 65_535) {\n      shape.size = 2;\n    } else if (maxRange <= 4_294_967_295) {\n      shape.size = 4;\n    } else {\n      shape.size = 8;\n    }\n\n    return shape;\n  } else {\n    if (minRange >= -128 && maxRange <= 127) {\n      shape.size = 1;\n    } else if (minRange >= -32_768 && maxRange <= 32_767) {\n      shape.size = 2;\n    } else if (minRange >= -2_147_483_648 && maxRange <= 2_147_483_647) {\n      shape.size = 4;\n    } else {\n      shape.size = 8;\n    }\n  }\n\n  return shape;\n};\n\nexport const getNumberShape = (\n  precision?: number | null,\n  scale?: number | null,\n): StoreShape<'number'> => ({\n  type: 'number',\n  size: 8,\n  precision,\n  scale,\n});\n\nexport const jsonShape: StoreShape<'json'> = { type: 'json' };\n\nexport const getStringShape = (size?: number | null): StoreShape<'string'> => ({\n  type: 'string',\n  size,\n});\n","import { Scalar } from '@/scalar';\nimport { z } from 'zod';\nimport { booleanShape } from './shapes';\n\n// boolean\n\nexport type BooleanScalar = boolean;\ntype BooleanScalarInput = TrueScalarInput | FalseScalarInput;\n\nexport const BooleanScalar: Scalar<BooleanScalar, BooleanScalarInput> = {\n  type: 'Scalar',\n  shape: booleanShape,\n  name: 'Boolean',\n  description: 'The `Boolean` scalar type represents `true` or `false`.',\n  encode: (value) =>\n    z.boolean().or(trueLiterals).or(falseLiterals).parse(value),\n};\n\n// true\n\nexport type TrueScalar = true;\ntype TrueScalarInput =\n  | true\n  | 1\n  | 'true'\n  | 'yes'\n  | 'True'\n  | 'Yes'\n  | 'TRUE'\n  | 'YES';\n\nexport const TrueScalar: Scalar<TrueScalar, TrueScalarInput> = {\n  type: 'Scalar',\n  shape: booleanShape,\n  name: 'True',\n  description: 'The `True` scalar type represents only `true` value.',\n  encode: (value) => z.literal(true).or(trueLiterals).parse(value),\n};\n\n// false\n\nexport type FalseScalar = false;\ntype FalseScalarInput =\n  | false\n  | 0\n  | 'false'\n  | 'no'\n  | 'False'\n  | 'No'\n  | 'FALSE'\n  | 'NO';\n\nexport const FalseScalar: Scalar<FalseScalar, FalseScalarInput> = {\n  type: 'Scalar',\n  shape: booleanShape,\n  name: 'False',\n  description: 'The `False` scalar type represents only `false` value.',\n  encode: (value) => z.literal(false).or(falseLiterals).parse(value),\n};\n\n// literals helpers\n\nconst trueLiterals = z\n  .union([\n    z.literal(1),\n    z.literal('true'),\n    z.literal('yes'),\n    z.literal('True'),\n    z.literal('Yes'),\n    z.literal('TRUE'),\n    z.literal('YES'),\n  ])\n  .transform(() => true as const);\n\nconst falseLiterals = z\n  .union([\n    z.literal(0),\n    z.literal('false'),\n    z.literal('no'),\n    z.literal('False'),\n    z.literal('No'),\n    z.literal('FALSE'),\n    z.literal('NO'),\n  ])\n  .transform(() => false as const);\n","import { createCallableScalar } from '@/generator';\nimport { Scalar } from '@/scalar';\nimport { buffer } from 'node:stream/consumers';\nimport { z } from 'zod';\nimport { IntegerScalar } from './integer';\nimport { getBinaryShape } from './shapes';\n\nexport type BufferScalar = Buffer;\ntype BufferScalarInput = Buffer | string | number[] | Uint8Array | ArrayBuffer;\n\nexport const BufferScalar = createCallableScalar(\n  {\n    min: { type: IntegerScalar({ min: 0 }), nullable: true },\n    max: { type: IntegerScalar({ min: 0 }), nullable: true },\n  },\n  ({ min, max }, key): Scalar<BufferScalar> => {\n    let validator = z.instanceof(Buffer);\n\n    if (min != null) {\n      validator = validator.refine((value) => value.length >= min, {\n        message: `Expected buffer with at least ${min} bytes`,\n      });\n    }\n\n    if (max != null) {\n      validator = validator.refine((value) => value.length <= max, {\n        message: `Expected buffer with at most ${max} bytes`,\n      });\n    }\n\n    return {\n      type: 'Scalar',\n      shape: getBinaryShape(max),\n      name: `Buffer${key}`,\n      description:\n        'The `Buffer` scalar type represents a binary data with a variable length.',\n      encode: (value) => validator.parse(toBuffer(value)),\n    };\n  },\n);\n\nconst numbersBuffer = z.array(z.number().int().min(0).max(255));\n\nconst toBuffer = (value: BufferScalarInput): Buffer => {\n  if (value instanceof Buffer) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return Buffer.from(value, 'base64');\n  }\n\n  if (value instanceof Uint8Array || value instanceof ArrayBuffer) {\n    return Buffer.from(value);\n  }\n\n  if (Array.isArray(value)) {\n    return Buffer.from(numbersBuffer.parse(value));\n  }\n\n  return buffer as never;\n};\n","import { createCallableScalar } from '@/generator';\nimport { Scalar } from '@/scalar';\nimport { z } from 'zod';\nimport { getIntergerShape } from './shapes';\n\nexport type IntegerScalar = number;\n\nconst core: Scalar<IntegerScalar> = {\n  type: 'Scalar',\n  shape: getIntergerShape(),\n  name: 'Integer',\n  description:\n    'The `Integer` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^53 - 1) and 2^53 - 1.',\n  encode: (value) => z.number().int().parse(value),\n};\n\nexport const IntegerScalar = createCallableScalar(\n  {\n    min: { type: core, nullable: true },\n    max: { type: core, nullable: true },\n    after: { type: core, nullable: true },\n    below: { type: core, nullable: true },\n  },\n  ({ min, max, after, below }, key): Scalar<IntegerScalar> => {\n    let validator = z.number().int();\n    let minRange = -Infinity;\n    let maxRange = Infinity;\n\n    if (min != null) {\n      minRange = min;\n      validator = validator.min(min);\n    }\n\n    if (max != null) {\n      maxRange = max;\n      validator = validator.max(max);\n    }\n\n    if (after != null) {\n      if (min != null) {\n        throw new TypeError('Cannot set both `min` and `after`');\n      }\n\n      minRange = Math.floor(after) + 1;\n      validator = validator.gt(after);\n    }\n\n    if (below != null) {\n      if (max != null) {\n        throw new TypeError('Cannot set both `max` and `below`');\n      }\n\n      maxRange = Math.ceil(below) - 1;\n      validator = validator.lt(below);\n    }\n\n    return {\n      ...core,\n      name: `Integer${key}`,\n      shape: getIntergerShape(minRange, maxRange),\n      encode: (value) => validator.parse(value),\n    };\n  },\n);\n","import { createCallableScalar } from '@/generator';\nimport { Scalar } from '@/scalar';\nimport { z } from 'zod';\nimport { dateTimeShape } from './shapes';\n\nconst MIN_NUMERIC_DATE = Date.UTC(2000, 0, 1);\nconst MAX_NUMERIC_DATE = Date.UTC(2100, 0, 1);\n\nexport type DateTimeScalar = Date;\ntype DateTimeScalarInput = string | number | Date;\n\nconst core: Scalar<DateTimeScalar, DateTimeScalarInput> = {\n  type: 'Scalar',\n  shape: dateTimeShape,\n  name: 'DateTime',\n  description:\n    'The `DateTime` scalar type represents a date and time following the ISO-8601 standard.',\n  encode: (value) => z.date().parse(toDate(value)),\n};\n\nexport const DateTimeScalar = createCallableScalar(\n  {\n    min: { type: core, nullable: true },\n    max: { type: core, nullable: true },\n  },\n  ({ min, max }, key): Scalar<DateTimeScalar, DateTimeScalarInput> => {\n    let validator = z.date();\n\n    if (min != null) {\n      validator = validator.min(min);\n    }\n\n    if (max != null) {\n      validator = validator.max(max);\n    }\n\n    return {\n      ...core,\n      name: `DateTime${key}`,\n      encode: (value) => validator.parse(toDate(value)),\n    };\n  },\n);\n\nconst stringDate = z.string().datetime({ offset: true });\nconst numericDate = z.number().min(MIN_NUMERIC_DATE).max(MAX_NUMERIC_DATE);\n\nconst toDate = (value: DateTimeScalarInput): Date => {\n  if (value instanceof Date) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return new Date(stringDate.parse(value));\n  }\n\n  if (typeof value === 'number') {\n    return new Date(numericDate.parse(value));\n  }\n\n  return value;\n};\n","import { createCallableScalar } from '@/generator';\nimport { Scalar } from '@/scalar';\nimport { z } from 'zod';\nimport { BooleanScalar } from './boolean';\nimport { IntegerScalar } from './integer';\nimport { getNumberShape } from './shapes';\n\nexport type NumberScalar = number;\n\nconst core: Scalar<NumberScalar> = {\n  type: 'Scalar',\n  shape: getNumberShape(),\n  name: 'Number',\n  description:\n    'The `Number` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).',\n  encode: (value) => z.number().parse(value),\n};\n\nconst validatePrecision = (\n  precision: number,\n  scale: number,\n  max?: number | null,\n  below?: number | null,\n) => {\n  if (precision < scale) {\n    throw new TypeError('`precision` must be greater than or equal to `scale`');\n  }\n\n  const digits = precision - scale;\n  const digitsBelow = 10 ** digits;\n\n  if (max != null) {\n    if (max >= digitsBelow) {\n      throw new TypeError(\n        `Cannot set 'max' greater than equal ${digitsBelow} for 'precision' of ${precision} and 'scale' of ${scale}`,\n      );\n    }\n  } else if (below == null) {\n    below = digitsBelow;\n  } else {\n    if (below > digitsBelow) {\n      throw new TypeError(\n        `Cannot set 'below' greater than ${digitsBelow} for 'precision' of ${precision} and 'scale' of ${scale}`,\n      );\n    }\n  }\n\n  return { below };\n};\n\nexport const NumberScalar = createCallableScalar(\n  {\n    min: { type: core, nullable: true },\n    max: { type: core, nullable: true },\n    after: { type: core, nullable: true },\n    below: { type: core, nullable: true },\n    finite: { type: BooleanScalar, nullable: true },\n    precision: { type: IntegerScalar({ min: 1, max: 1000 }), nullable: true },\n    scale: { type: IntegerScalar({ min: 1, max: 1000 }), nullable: true },\n  },\n  (\n    { min, max, after, below, finite, precision, scale },\n    key,\n  ): Scalar<NumberScalar> => {\n    let validator = z.number();\n\n    if (precision != null && scale != null) {\n      ({ below } = validatePrecision(precision, scale, max, below));\n    }\n\n    if (min != null) {\n      validator = validator.min(min);\n    }\n\n    if (max != null) {\n      validator = validator.max(max);\n    }\n\n    if (after != null) {\n      if (min != null) {\n        throw new TypeError('Cannot set both `min` and `after`');\n      }\n\n      validator = validator.gt(after);\n    }\n\n    if (below != null) {\n      if (max != null) {\n        throw new TypeError('Cannot set both `max` and `below`');\n      }\n\n      validator = validator.lt(below);\n    }\n\n    if (finite) {\n      validator = validator.finite();\n    }\n\n    return {\n      ...core,\n      name: `Number${key}`,\n      shape: getNumberShape(precision, scale),\n      encode: (value) => validator.parse(value),\n    };\n  },\n);\n","import { Scalar } from '@/scalar';\nimport { z } from 'zod';\nimport { jsonShape } from './shapes';\n\nexport type ObjectScalar = object;\n\nexport const ObjectScalar: Scalar<ObjectScalar> = {\n  type: 'Scalar',\n  shape: jsonShape,\n  name: 'Object',\n  description: 'The `Object` scalar type represents any arbitrary object.',\n  encode: (value) => z.object({}).parse(value),\n};\n","import { createCallableScalar } from '@/generator';\nimport { Scalar } from '@/scalar';\nimport { z } from 'zod';\nimport { BooleanScalar } from './boolean';\nimport { IntegerScalar } from './integer';\nimport { getStringShape } from './shapes';\n\nexport type StringScalar = string;\n\nconst core: Scalar<StringScalar> = {\n  type: 'Scalar',\n  shape: getStringShape(),\n  name: `String`,\n  description:\n    'The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used to represent free-form human-readable text.',\n  encode: (value) => z.string().parse(value),\n};\n\nconst formatValidator = ({\n  trim,\n  normalize,\n  lowercase,\n  uppercase,\n}: {\n  trim?: boolean | null;\n  normalize?: boolean | null;\n  lowercase?: boolean | null;\n  uppercase?: boolean | null;\n}) => {\n  let validator = z.string();\n\n  if (trim) {\n    validator = validator.trim();\n  }\n\n  if (normalize) {\n    validator = validator.transform((value) => value.normalize()) as never;\n  }\n\n  if (lowercase) {\n    if (uppercase) {\n      throw new TypeError(\n        '`lowercase` and `uppercase` cannot be used together',\n      );\n    }\n\n    validator = validator.transform((value) => value.toLowerCase()) as never;\n  } else if (uppercase) {\n    validator = validator.transform((value) => value.toUpperCase()) as never;\n  }\n\n  return validator;\n};\n\nexport const StringScalar = createCallableScalar(\n  {\n    min: { type: IntegerScalar({ min: 0 }), nullable: true },\n    max: { type: IntegerScalar({ min: 0 }), nullable: true },\n    trim: { type: BooleanScalar, nullable: true },\n    lowercase: { type: BooleanScalar, nullable: true },\n    uppercase: { type: BooleanScalar, nullable: true },\n    normalize: { type: BooleanScalar, nullable: true },\n    startsWith: { type: core, nullable: true },\n    endsWith: { type: core, nullable: true },\n    regex: { type: core, nullable: true },\n  },\n  (\n    { min, max, startsWith, endsWith, regex, ...format },\n    key,\n  ): Scalar<StringScalar> => {\n    let validator = formatValidator(format);\n\n    if (min != null) {\n      validator = validator.min(min);\n    }\n\n    if (max != null) {\n      if (min != null && min > max) {\n        throw new TypeError('`min` cannot be greater than `max`');\n      }\n\n      validator = validator.max(max);\n    }\n\n    if (startsWith != null) {\n      validator = validator.refine((value) => value.startsWith(startsWith), {\n        message: `Must start with \"${startsWith}\"`,\n      }) as never;\n    }\n\n    if (endsWith != null) {\n      validator = validator.refine((value) => value.endsWith(endsWith), {\n        message: `Must end with \"${endsWith}\"`,\n      }) as never;\n    }\n\n    if (regex != null) {\n      validator = validator.regex(new RegExp(regex));\n    }\n\n    return {\n      ...core,\n      shape: getStringShape(max),\n      name: `String${key}`,\n      encode: (value) => validator.parse(value),\n    };\n  },\n);\n","import { Scalar } from '@/scalar';\nimport { jsonShape } from './shapes';\n\nexport type UnknownScalar = unknown;\n\nexport const UnknownScalar: Scalar<UnknownScalar> = {\n  type: 'Scalar',\n  shape: jsonShape,\n  name: 'Unknown',\n  description:\n    'The `Unknown` scalar type represents any value that can be represented by JSON.',\n  encode: (value) => value,\n};\n","import { createCallable } from '@/callable';\nimport { DateTimeScalar } from '@/primitives';\n\nexport const DateTime = createCallable(\n  'DateTime',\n  {\n    now: { type: DateTimeScalar, nullable: true },\n  },\n  { type: DateTimeScalar },\n  ({ now }) => {\n    if (now != null) {\n      return new Date(now);\n    }\n\n    return new Date();\n  },\n);\n","import { Callable, createCallable } from '@/callable';\nimport { StringScalar, UnknownScalar } from '@/primitives';\n\nconst parameters = {\n  value: { type: UnknownScalar, nullable: true, generic: 'T' as const },\n  message: { type: StringScalar, nullable: true },\n};\n\nconst returnType = { type: UnknownScalar, generic: 'T' as const };\n\nexport const Required = createCallable(\n  'Required',\n  parameters,\n  returnType,\n  <T>({\n    value,\n    message,\n  }: {\n    value?: T | null | undefined;\n    message?: string | undefined | null;\n  }) => {\n    if (value == null) {\n      throw new TypeError(message ?? 'Required value is null or undefined');\n    }\n\n    return value;\n  },\n) as (<T>(args: {\n  value?: T | null | undefined;\n  message?: string | undefined | null;\n}) => NonNullable<T>) &\n  Callable<typeof parameters, typeof returnType>;\n","import { createCallableScalar } from '@/generator';\nimport { BooleanScalar, StringScalar } from '@/primitives';\nimport { getStringShape } from '@/primitives/shapes';\nimport { Scalar } from '@/scalar';\nimport { z } from 'zod';\n\n// https://www.rfc-editor.org/errata/eid1690\n// const EMAIL_LOCAL_PART_MAX_LENGTH = 64;\nconst EMAIL_DOMAIN_MAX_LENGTH = 255;\nconst EMAIL_MAX_LENGTH = 320;\n\nexport type EmailScalar = string;\n\nexport const EmailScalar = createCallableScalar(\n  {\n    at: {\n      type: StringScalar({\n        max: EMAIL_DOMAIN_MAX_LENGTH,\n        regex: '^[a-zA-Z0-9]+([\\\\.-]?[a-zA-Z0-9]+)*(\\\\.[a-zA-Z0-9]{2,3})+$',\n        trim: true,\n      }),\n      nullable: true,\n    },\n    lowercase: {\n      type: BooleanScalar,\n      nullable: true,\n    },\n  },\n  ({ at, lowercase }, key): Scalar<StringScalar> => {\n    let validator = z.string().trim().email();\n\n    if (lowercase) {\n      validator = validator.transform((value) => value.toLowerCase()) as never;\n    }\n\n    if (at != null) {\n      validator = validator.refine((value) => value.endsWith(`@${at}`), {\n        message: `Must be an email address at \"${at}\"`,\n      }) as never;\n    }\n\n    return {\n      type: 'Scalar',\n      shape: getStringShape(EMAIL_MAX_LENGTH),\n      name: `Email${key}`,\n      description: 'The `Email` scalar type represents a string email address.',\n      encode: (value) => validator.parse(value),\n    };\n  },\n);\n","import { createCallableScalar } from '@/generator';\nimport { BooleanScalar, StringScalar } from '@/primitives';\nimport { getStringShape } from '@/primitives/shapes';\nimport { Scalar } from '@/scalar';\nimport { z } from 'zod';\n\n// https://stackoverflow.com/a/14402437/518153\nconst DOMAIN_MAX_LENGTH = 253;\n\nexport type URLScalar = string;\n\nexport const URLScalar = createCallableScalar(\n  {\n    domain: {\n      type: StringScalar({\n        max: DOMAIN_MAX_LENGTH,\n        regex: '^([a-zA-Z0-9]+([\\\\.-]?[a-zA-Z0-9]+)*)+$',\n        trim: true,\n      }),\n      nullable: true,\n    },\n    protocol: {\n      type: StringScalar({\n        max: 10,\n        regex: '^[a-zA-Z0-9]+$',\n        trim: true,\n      }),\n      nullable: true,\n    },\n    secure: { type: BooleanScalar, nullable: true },\n  },\n  ({ domain, secure, protocol }, key): Scalar<StringScalar> => {\n    let validator = z.string().trim().url();\n\n    if (domain != null) {\n      const regex = new RegExp(\n        `://([a-z0-9]+(-[a-z0-9]+)*\\\\.)*${domain.replace(/\\./g, '\\\\.')}/`,\n        'i',\n      );\n\n      validator = validator.refine((value) => value.match(regex), {\n        message: `Must be a URL with domain \"${domain}\"`,\n      }) as never;\n    }\n\n    if (secure != null) {\n      if (protocol != null) {\n        throw new TypeError('Cannot specify both \"secure\" and \"protocol\"');\n      }\n\n      validator = validator.refine((value) => value.startsWith('https://'), {\n        message: `Must be a secure URL`,\n      }) as never;\n    } else if (protocol != null) {\n      validator = validator.refine(\n        (value) => value.startsWith(`${protocol}://`),\n        {\n          message: `Must be a URL with protocol \"${protocol}\"`,\n        },\n      ) as never;\n    }\n\n    return {\n      type: 'Scalar',\n      shape: getStringShape(),\n      name: `URL${key}`,\n      description: 'The `URL` scalar type represents a string URL.',\n      encode: (value) => validator.parse(value),\n    };\n  },\n);\n","import { Parameters, ParametersType, ParametersInput } from './parameters';\n\nexport const parseParametersInput = <P extends Parameters>(\n  parameters: P,\n): ((input: ParametersInput<P>) => ParametersType<P>) => {\n  const entries = Object.entries(parameters);\n\n  return (input) =>\n    Object.fromEntries(\n      entries\n        .filter(([key, parameter]) => !parameter.nullable || key in input)\n        .map(([key, parameter]) => {\n          const value = input[key as never];\n\n          if (parameter.nullable && value == null) {\n            return [key, value];\n          }\n\n          return [key, parameter.type.encode(value)];\n        }),\n    ) as ParametersType<P>;\n};\n","export {\n  BigIntScalar as BigInt,\n  BooleanScalar as Boolean,\n  TrueScalar as True,\n  FalseScalar as False,\n  BufferScalar as Buffer,\n  DateTimeScalar as DateTime,\n  IntegerScalar as Integer,\n  NumberScalar as Number,\n  ObjectScalar as Object,\n  StringScalar as String,\n} from './primitives';\n\nexport { EmailScalar as Email, URLScalar as URL } from './commons';\n","export * from './callables';\n"],"mappings":"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","names":["createScalarGenerator","name","props","generator","target","parameters","getParametersKey","Object","defineProperty","value","writable","assign","createCallableScalar","parametersStr","entries","filter","sort","keyA","keyB","localeCompare","map","key","escapeKey","escapeValue","join","test","JSON","stringify","String","createCallable","name","parameters","returnType","callable","Object","defineProperty","value","writable","assign","z","getBigIntShape","minRange","maxRange","shape","type","scale","unsigned","precision","Math","max","toString","length","booleanShape","getBinaryShape","size","dateTimeShape","getIntergerShape","Infinity","getNumberShape","jsonShape","getStringShape","core","type","shape","getBigIntShape","name","description","encode","value","z","bigint","parse","toBigInt","BigIntScalar","createCallableScalar","min","nullable","max","after","below","key","validator","minRange","maxRange","refine","message","TypeError","BigInt","z","BooleanScalar","type","shape","booleanShape","name","description","encode","value","z","boolean","or","trueLiterals","falseLiterals","parse","TrueScalar","literal","FalseScalar","union","transform","buffer","z","z","core","type","shape","getIntergerShape","name","description","encode","value","z","number","int","parse","IntegerScalar","createCallableScalar","min","nullable","max","after","below","key","validator","minRange","maxRange","Infinity","TypeError","Math","floor","gt","ceil","lt","BufferScalar","createCallableScalar","min","type","IntegerScalar","nullable","max","key","validator","z","instanceof","Buffer","refine","value","length","message","shape","getBinaryShape","name","description","encode","parse","toBuffer","numbersBuffer","array","number","int","from","Uint8Array","ArrayBuffer","Array","isArray","buffer","z","MIN_NUMERIC_DATE","Date","UTC","MAX_NUMERIC_DATE","core","type","shape","dateTimeShape","name","description","encode","value","z","date","parse","toDate","DateTimeScalar","createCallableScalar","min","nullable","max","key","validator","stringDate","string","datetime","offset","numericDate","number","z","core","type","shape","getNumberShape","name","description","encode","value","z","number","parse","validatePrecision","precision","scale","max","below","TypeError","digits","digitsBelow","NumberScalar","createCallableScalar","min","nullable","after","finite","BooleanScalar","IntegerScalar","key","validator","gt","lt","z","ObjectScalar","type","shape","jsonShape","name","description","encode","value","z","object","parse","z","core","type","shape","getStringShape","name","description","encode","value","z","string","parse","formatValidator","trim","normalize","lowercase","uppercase","validator","transform","TypeError","toLowerCase","toUpperCase","StringScalar","createCallableScalar","min","IntegerScalar","nullable","max","BooleanScalar","startsWith","endsWith","regex","format","key","refine","message","RegExp","UnknownScalar","type","shape","jsonShape","name","description","encode","value","DateTime","createCallable","now","type","DateTimeScalar","nullable","Date","parameters","value","type","UnknownScalar","nullable","generic","message","StringScalar","returnType","Required","createCallable","TypeError","z","EMAIL_DOMAIN_MAX_LENGTH","EMAIL_MAX_LENGTH","EmailScalar","createCallableScalar","at","type","StringScalar","max","regex","trim","nullable","lowercase","BooleanScalar","key","validator","string","email","transform","value","toLowerCase","refine","endsWith","message","shape","getStringShape","name","description","encode","parse","z","DOMAIN_MAX_LENGTH","URLScalar","createCallableScalar","domain","type","StringScalar","max","regex","trim","nullable","protocol","secure","BooleanScalar","key","validator","string","url","RegExp","replace","refine","value","match","message","TypeError","startsWith","shape","getStringShape","name","description","encode","parse","parseParametersInput","parameters","entries","Object","input","fromEntries","filter","key","parameter","nullable","map","value","type","encode"]}