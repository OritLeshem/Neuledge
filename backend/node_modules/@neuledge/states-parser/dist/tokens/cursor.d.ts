import { ParsingError } from "../error";
import { PunctuationToken, Token, WordToken } from './index';
import { AbstractToken } from './abstract';
export declare class TokenCursor {
    readonly content: string;
    index: number;
    readonly tokens: Token[];
    constructor(content: string, path?: string, index?: number);
    get current(): Token | undefined;
    get next(): Token | undefined;
    get path(): string | undefined;
    get start(): number;
    get end(): number;
    static isMatch<T extends Token['type']>(token: Token | null | undefined, type: T, test?: ((token: Token & AbstractToken<T>) => boolean) | null): token is Token & AbstractToken<T>;
    pickKeyword<V extends string>(...values: V[]): (WordToken & {
        value: V;
    }) | null;
    consumeKeyword<V extends string>(...values: V[]): WordToken & {
        value: V;
    };
    pickPunctuation<V extends string>(...values: V[]): PunctuationToken & {
        value: V;
    };
    consumePunctuation<V extends string>(...values: V[]): PunctuationToken & {
        value: V;
    };
    pick<T extends Token['type']>(type: T, test?: ((token: Token & AbstractToken<T>) => boolean) | null): (Token & AbstractToken<T>) | null;
    consume<T extends Token['type']>(type: T, test?: ((token: Token & AbstractToken<T>) => boolean) | null, expected?: string): Token & AbstractToken<T>;
    createError(expected?: string): ParsingError;
    maybeConsumeKeyword<V extends string>(value: V): (WordToken & {
        value: V;
    }) | undefined;
    maybeConsumePunctuation<V extends string>(value: V): (PunctuationToken & {
        value: V;
    }) | undefined;
    maybeConsume<T extends Token['type']>(type: T, test?: ((token: Token & AbstractToken<T>) => boolean) | null): (Token & AbstractToken<T>) | undefined;
    transaction<T>(fn: () => T): T;
}
//# sourceMappingURL=cursor.d.ts.map