var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/generate/comments.ts
var generateDescriptionComment = /* @__PURE__ */ __name(({ description, deprecated }, indent) => {
  const deprecationReason = deprecated === true ? "" : deprecated || null;
  return description ? `/**
${indent} * ${description.replace(/\n/g, `
${indent} * `)}${deprecationReason ? `
${indent} *
${indent} * @deprecated ${deprecationReason.replace(/\n/g, `
${indent} * `)}` : ""}
${indent} */
${indent}` : deprecationReason ? `/**
${indent} * @deprecated ${deprecationReason.replace(/\n/g, `
${indent} * `)}
${indent} */
${indent}` : "";
}, "generateDescriptionComment");

// src/generate/either.ts
var generateEither = /* @__PURE__ */ __name((either) => generateDescriptionComment(either, "") + `${generateEitherType(either)}
${generateEitherConst(either)}
export type $${either.name} = $.Entity<typeof ${either.name}[number]>;`, "generateEither");
var generateEitherType = /* @__PURE__ */ __name((either) => `export type ${either.name} = ${either.states.map((state) => state.name).join(" | ")};`, "generateEitherType");
var generateEitherConst = /* @__PURE__ */ __name((either) => `export const ${either.name}: $.Either<'${either.name}', ${either.states.map((state) => `typeof ${state.name}`).join(" | ")}> =
  $.either('${either.name}', [${either.states.map((state) => state.name).join(", ")}]);`, "generateEitherConst");

// src/generate/imports.ts
var generateImports = /* @__PURE__ */ __name(() => `import { $ } from '@neuledge/engine';`, "generateImports");

// src/generate/entity.ts
var generateEntityScalar = /* @__PURE__ */ __name((entity) => {
  switch (entity.type) {
    case "Either": {
      return `[...${entity.name}]`;
    }
    case "State": {
      return `[${entity.name}]`;
    }
    case "Scalar": {
      return `$.scalars.${entity.name}`;
    }
    default: {
      throw new TypeError(`Unexpected entity type: ${entity.type}`);
    }
  }
}, "generateEntityScalar");
var generateEntityType = /* @__PURE__ */ __name((entity) => {
  switch (entity.type) {
    case "Either": {
      return `$.Id<typeof ${entity.name}[number]>`;
    }
    case "State": {
      return `$.Id<typeof ${entity.name}>`;
    }
    case "Scalar": {
      return entity.node ? entity.name : `$.scalars.${entity.name}`;
    }
    default: {
      throw new TypeError(`Unexpected entity type: ${entity.type}`);
    }
  }
}, "generateEntityType");
var generateWhereEntityExpression = /* @__PURE__ */ __name(({ entity, list }, nullable) => {
  switch (entity.type) {
    case "Either": {
      const type = list ? "ListState" : "State";
      const nullish = nullable ? "Nullable" : "";
      return `$.Where${nullish}${type}<typeof ${entity.name}[number]>`;
    }
    case "State": {
      const type = list ? "ListState" : "State";
      const nullish = nullable ? "Nullable" : "";
      return `$.Where${nullish}${type}<typeof ${entity.name}>`;
    }
    case "Scalar": {
      return generateWhereScalar(entity, nullable, list);
    }
    default: {
      throw new TypeError(`Unexpected entity type: ${entity.type}`);
    }
  }
}, "generateWhereEntityExpression");
var generateWhereScalar = /* @__PURE__ */ __name((scalar, nullable, list) => {
  const nullish = nullable ? "Nullable" : "";
  const name = scalar.node ? scalar.name : `$.scalars.${scalar.name}`;
  const where = list ? "Array" : WhereShapeTypeMap[scalar.shape.type];
  return `$.Where${nullish}${where}<${name}>`;
}, "generateWhereScalar");
var WhereShapeTypeMap = {
  boolean: "Boolean",
  "date-time": "DateTime",
  number: "Number",
  string: "String",
  binary: "Buffer",
  json: "Unknown",
  enum: "Enum"
};

// src/generate/type.ts
var generateTypeScalar = /* @__PURE__ */ __name((type) => {
  switch (type.type) {
    case "EntityExpression": {
      return type.list ? `[${generateEntityScalar(type.entity)}]` : generateEntityScalar(type.entity);
    }
    default: {
      throw new TypeError(`Unexpected type: ${type.type}`);
    }
  }
}, "generateTypeScalar");
var generateTypeType = /* @__PURE__ */ __name((type) => {
  switch (type.type) {
    case "EntityExpression": {
      return type.list ? `${generateEntityType(type.entity)}[]` : generateEntityType(type.entity);
    }
    default: {
      throw new TypeError(`Unexpected type: ${type.type}`);
    }
  }
}, "generateTypeType");

// src/generate/state/fields.ts
var generateStateScalars = /* @__PURE__ */ __name((state, indent) => `() => ({${Object.values(state.fields).filter((item) => item.type === "ScalarField").map((item) => `
${indent}  ${item.name}: { type: ${generateTypeScalar(item.as)}, index: ${item.index}${item.nullable ? ", nullable: true" : ""} },`).join("")}
${indent}})`, "generateStateScalars");
var generateStateFields = /* @__PURE__ */ __name((state, indent) => `${Object.values(state.fields).filter((item) => item.type === "ScalarField").map((item) => `
${indent}${generateDescriptionComment(item, indent)}${item.name}${item.nullable ? `?: ${generateTypeType(item.as)} | null;` : `!: ${generateTypeType(item.as)};`}`).join("")}`, "generateStateFields");
var generateStateOptionalRelations = /* @__PURE__ */ __name((state, indent) => {
  const fields = Object.values(state.fields).filter((item) => item.type === "RelationField" || item.as.entity.type !== "Scalar");
  if (!fields.length) {
    return null;
  }
  return `() => ({${fields.map((item) => `
${indent}  ${item.name}: { states: ${generateEntityScalar(item.as.entity)}${item.as.list ? ", list: true" : ""}${item.type === "RelationField" && item.referenceField ? `, reference: '${item.referenceField.replace(/('|\\)/g, "\\$1")}'` : ""} } as const,`).join("")}
${indent}})`;
}, "generateStateOptionalRelations");

// ../states-parser/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
var UnaryExpressionNodeOperators = {
  "!": 1,
  "-": 1,
  "+": 1,
  "~": 1
};
var UnaryExpressionNodeOperatorsArray = Object.keys(UnaryExpressionNodeOperators);
var ParsingError = /* @__PURE__ */ __name(class extends SyntaxError {
  name = "ParsingError";
  start;
  end;
  path;
  constructor(position, message) {
    super(message);
    Object.setPrototypeOf(this, ParsingError.prototype);
    this.start = position.start;
    this.end = position.end;
    this.path = position.path;
    this.stack = `${this.name}: ${this.message}\r
	at ${this.path ?? `character ${this.start}`}`;
  }
}, "ParsingError");
__name2(ParsingError, "ParsingError");
var TokenCharMap = {
  '"': "String",
  "'": "String",
  "": -1,
  " ": -1,
  "	": -1,
  "\r": -1,
  "\n": -1
};
for (const char of "$_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") {
  TokenCharMap[char] = "Word";
}
for (const char of "0123456789") {
  TokenCharMap[char] = "Number";
}
var tokenize = /* @__PURE__ */ __name2((content, path) => {
  const values = splitTokenValues(content);
  const tokens = [];
  let position = 0;
  let line = 1;
  let column = 1;
  let isComment = false;
  let lastPunctuation = null;
  for (const value of values) {
    if (!isComment) {
      const token = parseToken(value, position, path && `${path}:${line}:${column}`);
      if (token) {
        if (lastPunctuation) {
          lastPunctuation.adjacent = true;
        }
        tokens.push(token);
        lastPunctuation = token.type === "Punctuation" ? token : null;
      } else {
        lastPunctuation = null;
        if (value === "#")
          isComment = true;
      }
    }
    const lines = value.split(/\r*\n/g);
    if (lines.length > 1) {
      line += lines.length - 1;
      column = 1;
    }
    column += lines[lines.length - 1].length;
    position += value.length;
    if (isComment && value.includes("\n")) {
      isComment = false;
    }
  }
  return tokens;
}, "tokenize");
var splitTokenValues = /* @__PURE__ */ __name2((content) => content.match(/([$_a-z]\w*|(?:\d*\.\d+|\d+)|\s+|"""(?:[^"]+|"[^"]|""[^"])*"""|"(?:[^\n"\\]+|\\.)*"|'(?:[^\n'\\]+|\\.)*'|[<=>]=|=>|[!=]==|&&|!!|\|\||\?\?|\*\*|\.\.\.|.)/gi) || [], "splitTokenValues");
var parseToken = /* @__PURE__ */ __name2((value, position, path) => {
  const kind = value[0];
  const type = TokenCharMap[kind] || "Punctuation";
  const start = position;
  const end = position + value.length;
  switch (type) {
    case "Number": {
      return {
        type,
        path,
        start,
        end,
        value: Number(value)
      };
    }
    case "String": {
      return {
        type,
        start,
        end,
        ...parseStringToken(kind, value)
      };
    }
    case "Punctuation": {
      if (value.length > 1 && /^[+-]?(?:\d*\.\d+|\d+)$/.test(value)) {
        return {
          type: "Number",
          path,
          start,
          end,
          value: Number(value)
        };
      }
      if (value === "#") {
        return null;
      }
      return {
        type,
        path,
        start,
        end,
        value,
        adjacent: false
      };
    }
    case "Word": {
      return {
        type,
        path,
        start,
        end,
        value
      };
    }
    case -1: {
      return null;
    }
  }
}, "parseToken");
var parseStringToken = /* @__PURE__ */ __name2((kind, raw) => {
  if (kind === '"' && raw[1] === '"' && raw[2] === '"') {
    return {
      kind: '"""',
      value: raw.slice(3, -3).trim().replace(/[\t ]*\r?\n[\t ]*/g, "\n")
    };
  }
  return {
    kind,
    value: raw.slice(1, -1).replace(/\\(.)/g, "$1")
  };
}, "parseStringToken");
var TokenCursor = /* @__PURE__ */ __name(class {
  content;
  index;
  tokens;
  constructor(content, path, index = 0) {
    this.content = content;
    this.index = index;
    this.tokens = tokenize(content, path);
  }
  get current() {
    return this.tokens[this.index];
  }
  get next() {
    return this.tokens[this.index + 1];
  }
  get path() {
    return this.tokens[this.index]?.path;
  }
  get start() {
    return this.tokens[this.index]?.start ?? this.content.length;
  }
  get end() {
    return this.tokens[this.index - 1]?.end ?? 0;
  }
  static isMatch(token, type, test) {
    if (token?.type !== type) {
      return false;
    }
    if (test == null) {
      return true;
    }
    try {
      return test(token);
    } catch {
      return false;
    }
  }
  pickKeyword(...values) {
    return this.pick("Word", values.length ? (token) => values.includes(token.value) : void 0);
  }
  consumeKeyword(...values) {
    return this.consume("Word", (token) => values.includes(token.value), `'${values[0]}' keyword`);
  }
  pickPunctuation(...values) {
    return this.pick("Punctuation", (token) => values.includes(token.value));
  }
  consumePunctuation(...values) {
    return this.consume("Punctuation", (token) => values.includes(token.value), `'${values[0]}' token`);
  }
  pick(type, test) {
    const token = this.current;
    if (!TokenCursor.isMatch(token, type, test)) {
      return null;
    }
    return token;
  }
  consume(type, test, expected) {
    const token = this.pick(type, test);
    if (!token) {
      throw this.createError(expected);
    }
    this.index += 1;
    return token;
  }
  createError(expected) {
    const token = this.current ?? null;
    return new ParsingError(token ?? {
      start: this.content.length - 1,
      end: this.content.length
    }, expected ? `Expect ${expected}` : token ? `Unexpected token '${this.content.slice(token.start, token.end)}'` : `Unexpected EOF`);
  }
  maybeConsumeKeyword(value) {
    const token = this.current;
    if (!token || token.value !== value || token.type !== "Word") {
      return void 0;
    }
    this.index += 1;
    return token;
  }
  maybeConsumePunctuation(value) {
    const token = this.current;
    if (!token || token.value !== value || token.type !== "Punctuation") {
      return void 0;
    }
    this.index += 1;
    return token;
  }
  maybeConsume(type, test) {
    const token = this.current;
    if (!TokenCursor.isMatch(token, type, test)) {
      return void 0;
    }
    this.index += 1;
    return token;
  }
  transaction(fn) {
    const { index: position } = this;
    try {
      return fn();
    } catch (error) {
      this.index = position;
      throw error;
    }
  }
}, "TokenCursor");
__name2(TokenCursor, "TokenCursor");

// src/generate/state/indexes.ts
var generateStateIdType = /* @__PURE__ */ __name((state) => {
  const { fields, auto } = state.primaryKey;
  const keys = Object.entries(fields).map(([name, dir]) => `'${dir === "asc" ? "+" : "-"}${name}'`);
  return `{ fields: [${keys.join(", ")}]${auto ? `, auto: '${auto}'` : ""} }`;
}, "generateStateIdType");
var generateStateQueryIndexes = /* @__PURE__ */ __name((state, indent) => `static $where: ${generateStateWhereType(state, indent)};
${indent}static $unique: ${generateStateUniqueType(state, indent)};
${indent}static $filter: ${generateStateFilterType(state, indent)};`, "generateStateQueryIndexes");
var generateStateOptionalIndexes = /* @__PURE__ */ __name((state, indent) => {
  const indexes = Object.values(state.indexes).filter((index) => index.name !== state.primaryKey.name);
  if (!indexes.length) {
    return null;
  }
  return `{` + indexes.map((index) => `
${indent}  ${/^\w+$/.test(index.name) ? index.name : `'${index.name.replace(/['\\]/g, "\\$1")}'`}: { fields: [${Object.entries(index.fields).map(([field, sort]) => `'${sort === "asc" ? `+` : "-"}${field}'`).join(", ")}]${index.unique ? ", unique: true" : ""} } as const,`).join("") + `
${indent}}`;
}, "generateStateOptionalIndexes");
var generateStateFilterType = /* @__PURE__ */ __name((state, indent) => `{${Object.values(state.fields).filter((field) => field.type === "ScalarField").map((item) => `
${indent}  ${item.name}?: ${generateWhereEntityExpression(item.as, item.nullable)} | null;`).join("")}
${indent}}`, "generateStateFilterType");
var generateStateWhereType = /* @__PURE__ */ __name((state, indent) => {
  const paths = getIndexTypePaths(state, Object.values(state.indexes));
  const multiPaths = paths.length > 1 || paths[0].length > 1;
  return paths.flatMap((fields) => fields.map((field, i) => `${multiPaths ? `
${indent}  | {` : "{"}${fields.slice(0, i).map((item) => `
${multiPaths ? `${indent}    ` : indent}  ${item.name}: ${generateWhereEntityExpression(item.as, item.nullable)};`).join("")}
${indent}${multiPaths ? "    " : ""}  ${field.name}?: ${generateWhereEntityExpression(field.as, field.nullable)} | null;${fields.slice(i + 1).map((item) => `
${multiPaths ? `${indent}    ` : indent}  ${item.name}?: null;`).join("")}
${multiPaths ? `${indent}    ` : indent}}`)).join(multiPaths ? "" : " | ");
}, "generateStateWhereType");
var generateStateUniqueType = /* @__PURE__ */ __name((state, indent) => getIndexTypePaths(state, Object.values(state.indexes).filter((index) => index.unique)).map((fields) => `{${fields.map((item) => `
${indent}  ${item.name}: ${generateTypeScalar(item.as)};`).join("")}
${indent}}`).join(" | "), "generateStateUniqueType");
var getIndexTypePaths = /* @__PURE__ */ __name((state, indexes) => {
  const fields = /* @__PURE__ */ new Map();
  for (const index of indexes) {
    let current = fields;
    for (const key of Object.keys(index.fields)) {
      let entry = current.get(key);
      if (!entry) {
        const field = state.fields[key];
        if (field?.type !== "ScalarField") {
          throw new ParsingError(state.node, `Index field '${key}' not found in state '${state.name}'`);
        }
        entry = {
          children: /* @__PURE__ */ new Map(),
          field
        };
        current.set(key, entry);
      }
      current = entry.children;
    }
  }
  const result = [];
  const walk = /* @__PURE__ */ __name((current, path) => {
    for (const [, entry] of current) {
      const newPath = [
        ...path,
        entry.field
      ];
      if (!entry.children.size) {
        result.push(newPath);
        continue;
      }
      walk(entry.children, newPath);
    }
  }, "walk");
  walk(fields, []);
  return result;
}, "getIndexTypePaths");

// src/generate/parameters.ts
var generateParametersType = /* @__PURE__ */ __name((parameters, indent) => {
  if (!parameters.length) {
    return "{}";
  }
  return `{
${parameters.map((parameter) => generateParameterType(parameter, indent)).join("")}${indent}}`;
}, "generateParametersType");
var generateParameterType = /* @__PURE__ */ __name((parameter, indent) => `${indent}  ${parameter.name}${parameter.nullable ? "?" : ""}: ${generateTypeType(parameter.as)}${parameter.nullable ? " | null" : ""};
`, "generateParameterType");
var generateParametersArgument = /* @__PURE__ */ __name((parameters) => {
  if (!parameters.length) {
    return "";
  }
  return `{ ${parameters.map((parameter) => parameter.name).join(", ")} }`;
}, "generateParametersArgument");

// src/generate/literal.ts
var generateLiteral = /* @__PURE__ */ __name((literal) => JSON.stringify(literal.value), "generateLiteral");
var generateNullLiteral = /* @__PURE__ */ __name((literal) => "null", "generateNullLiteral");

// src/generate/expression/binary.ts
var generateBinaryExpression = /* @__PURE__ */ __name((expression, indent) => `(${generateExpression(expression.left, indent)} ${expression.operator} ${generateExpression(expression.right, indent)})`, "generateBinaryExpression");

// src/generate/arguments.ts
var generateArguments = /* @__PURE__ */ __name((args, indent) => {
  const values = Object.values(args);
  if (!values.length) {
    return "{}";
  }
  return `{ ${values.map((arg) => `${generateArgumentName(arg.name)}: ${generateExpression(arg.value, indent)}`).join(", ")} }`;
}, "generateArguments");
var generateArgumentName = /* @__PURE__ */ __name((name) => /^\w+$/.test(name) ? name : `'${name.replace(/(['\\])/g, "\\$1")}'`, "generateArgumentName");

// src/generate/expression/call.ts
var generateCallExpression = /* @__PURE__ */ __name((expression, indent) => `await $.runtime.${expression.callee.name}(${generateArguments(expression.arguments, indent)})`, "generateCallExpression");

// src/generate/expression/identifier.ts
var generateIdentifierExpression = /* @__PURE__ */ __name((expression) => expression.reference.name, "generateIdentifierExpression");

// src/generate/expression/logical.ts
var generateLogicalExpression = /* @__PURE__ */ __name((expression, indent) => `(${generateExpression(expression.left, indent)} ${expression.operator} ${generateExpression(expression.right, indent)})`, "generateLogicalExpression");

// src/generate/expression/member.ts
var generateMemberExpression = /* @__PURE__ */ __name((expression, indent) => {
  const object = generateExpression(expression.object, indent);
  return `${object}${expression.properties.map((p) => generatePropertyExpression(p)).join("")}`;
}, "generateMemberExpression");
var generatePropertyExpression = /* @__PURE__ */ __name((expression) => /^\w+$/.test(expression.name) ? `.${expression.name}` : `['${expression.name.replace(/(['\\])/g, "\\$1")}']`, "generatePropertyExpression");

// src/generate/expression/this.ts
var generateThisExpression = /* @__PURE__ */ __name((expression) => "this", "generateThisExpression");

// src/generate/expression/unary.ts
var generateUnaryExpression = /* @__PURE__ */ __name((expression, indent) => `${expression.operator}${generateExpression(expression.argument, indent)}`, "generateUnaryExpression");

// src/generate/expression/index.ts
var generateExpression = /* @__PURE__ */ __name((expression, indent) => {
  switch (expression.type) {
    case "IdentifierExpression": {
      return generateIdentifierExpression(expression);
    }
    case "CallExpression": {
      return generateCallExpression(expression, indent);
    }
    case "ThisExpression": {
      return generateThisExpression(expression);
    }
    case "MemberExpression": {
      return generateMemberExpression(expression, indent);
    }
    case "Literal": {
      return generateLiteral(expression);
    }
    case "UnaryExpression": {
      return generateUnaryExpression(expression, indent);
    }
    case "BinaryExpression": {
      return generateBinaryExpression(expression, indent);
    }
    case "LogicalExpression": {
      return generateLogicalExpression(expression, indent);
    }
    case "NullLiteral": {
      return generateNullLiteral(expression);
    }
    default: {
      throw new TypeError(`Unexpected expression: ${expression.type}`);
    }
  }
}, "generateExpression");

// src/generate/property.ts
var generateStateFunctionBody = /* @__PURE__ */ __name((state, parameters, properties, extendsThis, indent) => {
  let res = `{
${indent}  return {
` + (extendsThis ? `${indent}    ...this,
` : "") + `${indent}    $state: '${state.name}',
`;
  if (!extendsThis) {
    for (const key in state.fields) {
      if (properties[key] || parameters[key])
        continue;
      res += `${indent}    ${key}: null,
`;
    }
  }
  for (const key in parameters) {
    if (properties[key] || !state.fields[key])
      continue;
    res += `${indent}    ${key},
`;
  }
  for (const key in properties) {
    const property = properties[key];
    res += `${indent}    ${generateProperty(property, `${indent}    `)},
`;
  }
  res += `${indent}  };
${indent}}`;
  return res;
}, "generateStateFunctionBody");
var generateProperty = /* @__PURE__ */ __name((property, indent) => {
  const value = generateExpression(property.value, indent);
  if (value === property.name) {
    return property.name;
  }
  return `${property.name}: ${value}`;
}, "generateProperty");

// src/generate/state/mutations.ts
var generateStateOptionalTransforms = /* @__PURE__ */ __name((state, indent) => {
  const transforms = Object.values(state.mutations).filter((item) => item.mutation === "update" && item.returns.name !== state.name).map((item) => item.returns);
  if (!transforms.length) {
    return null;
  }
  if (transforms.length <= 3) {
    return `() => [${transforms.map((item) => item.name).join(", ")}]`;
  }
  return `() => [${transforms.map((item) => `
${indent}  ${item.name},`).join("")}
${indent}]`;
}, "generateStateOptionalTransforms");
var generateStateMutations = /* @__PURE__ */ __name((state, indent) => Object.values(state.mutations).map((mutation) => `
${indent}${generateStateMutation(state, mutation, indent)}`).join(""), "generateStateMutations");
var generateStateMutation = /* @__PURE__ */ __name((state, mutation, indent) => {
  let value;
  switch (mutation.mutation) {
    case "create": {
      value = generateCreateMutationFn(state, mutation, indent);
      break;
    }
    case "update": {
      value = generateUpdateMutationFn(state, mutation, indent);
      break;
    }
    case "delete": {
      value = generateDeleteMutationFn(state, mutation, indent);
      break;
    }
    default: {
      throw new ParsingError(mutation.node, `Unknown mutation type: ${mutation.mutation}`);
    }
  }
  return generateDescriptionComment(mutation, indent) + `static ${mutation.name} = ${value};
`;
}, "generateStateMutation");
var generateCreateMutationFn = /* @__PURE__ */ __name((state, mutation, indent) => {
  const parameters = Object.values(mutation.parameters);
  if (!parameters.length) {
    return `$.mutation<typeof ${state.name}>('${mutation.mutation}', async function () ${generateStateFunctionBody(state, mutation.parameters, mutation.body, false, indent)})`;
  }
  return `$.mutation<
${indent}  typeof ${state.name},
${indent}  ${generateParametersType(parameters, `${indent}  `)}
${indent}>('${mutation.mutation}', async function (${generateParametersArgument(parameters)}) ${generateStateFunctionBody(state, mutation.parameters, mutation.body, false, indent)})`;
}, "generateCreateMutationFn");
var generateUpdateMutationFn = /* @__PURE__ */ __name((state, mutation, indent) => {
  const parameters = Object.values(mutation.parameters);
  if (!parameters.length) {
    return `$.mutation<typeof ${state.name}, typeof ${mutation.returns.name}>(
${indent}  '${mutation.mutation}',
${indent}  async function () ${generateStateFunctionBody(mutation.returns, mutation.parameters, mutation.body, true, `${indent}  `)},
${indent})`;
  }
  return `$.mutation<
${indent}  typeof ${state.name},
${indent}  ${generateParametersType(parameters, `${indent}  `)},
${indent}  typeof ${mutation.returns.name}
${indent}>('${mutation.mutation}', async function (${generateParametersArgument(parameters)}) ${generateStateFunctionBody(mutation.returns, mutation.parameters, mutation.body, true, indent)})`;
}, "generateUpdateMutationFn");
var generateDeleteMutationFn = /* @__PURE__ */ __name((state, mutation, indent) => {
  const parameters = Object.values(mutation.parameters);
  const properties = Object.values(mutation.body);
  if (!properties.length) {
    return `$.mutation<typeof ${state.name}>('${mutation.mutation}')`;
  }
  return `$.mutation<
${indent}  typeof ${state.name},
${indent}  ${generateParametersType(parameters, `${indent}  `)}
${indent}>('${mutation.mutation}', async function (${generateParametersArgument(parameters)}) ${generateStateFunctionBody(state, mutation.parameters, mutation.body, true, indent)})`;
}, "generateDeleteMutationFn");

// src/generate/state/index.ts
var generateState = /* @__PURE__ */ __name((state) => {
  const relations = generateStateOptionalRelations(state, "  ");
  const transforms = generateStateOptionalTransforms(state, "  ");
  const indexes = generateStateOptionalIndexes(state, "  ");
  return generateDescriptionComment(state, "") + `@$.State<'${state.name}', ${state.name}>()
export class ${state.name} {
  static $name = '${state.name}' as const;
  static $id = ${generateStateIdType(state)} as const;
  static $scalars = ${generateStateScalars(state, "  ")};
  ${generateStateQueryIndexes(state, "  ")}
` + (relations ? `  static $relations = ${relations};
` : "") + (indexes ? `  static $indexes = ${indexes};
` : "") + (transforms ? `  static $transforms = ${transforms};
` : "") + `${generateStateFields(state, "  ")}
` + generateStateMutations(state, "  ") + `}
export type $${state.name} = $.Entity<typeof ${state.name}>;`;
}, "generateState");

// src/generate/index.ts
var generate = /* @__PURE__ */ __name((context, entities = context.entities()) => {
  const res = [
    {
      source: generateImports(),
      order: 0
    }
  ];
  for (const entity of entities) {
    switch (entity.type) {
      case "Scalar": {
        if (!entity.node)
          break;
        break;
      }
      case "State": {
        res.push({
          source: generateState(entity),
          order: 2
        });
        break;
      }
      case "Either": {
        res.push({
          source: generateEither(entity),
          order: 3
        });
        break;
      }
      case "Void": {
        break;
      }
      default: {
        throw new TypeError(`Unsupported entity type '${entity.type}'`);
      }
    }
  }
  return res.sort((a, b) => a.order - b.order).map(({ source }) => source).join("\n\n") + "\n";
}, "generate");
export {
  generate
};
//# sourceMappingURL=index.mjs.map