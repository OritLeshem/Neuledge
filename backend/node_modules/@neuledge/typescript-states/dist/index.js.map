{"version":3,"sources":["../src/index.ts","../src/generate/comments.ts","../src/generate/either.ts","../src/generate/imports.ts","../src/generate/entity.ts","../src/generate/type.ts","../src/generate/state/fields.ts","../../states-parser/src/nodes/identifier.ts","../../states-parser/src/nodes/argument.ts","../../states-parser/src/nodes/literal.ts","../../states-parser/src/nodes/decorator.ts","../../states-parser/src/nodes/description.ts","../../states-parser/src/nodes/either.ts","../../states-parser/src/nodes/expressions/binary.ts","../../states-parser/src/nodes/expressions/identifier.ts","../../states-parser/src/nodes/expressions/logical.ts","../../states-parser/src/nodes/expressions/member.ts","../../states-parser/src/nodes/expressions/unary.ts","../../states-parser/src/nodes/expressions/expression.ts","../../states-parser/src/nodes/expressions/call.ts","../../states-parser/src/nodes/type.ts","../../states-parser/src/nodes/parameter.ts","../../states-parser/src/nodes/property.ts","../../states-parser/src/nodes/mutation.ts","../../states-parser/src/error.ts","../../states-parser/src/nodes/state-field.ts","../../states-parser/src/nodes/state.ts","../../states-parser/src/nodes/document.ts","../../states-parser/src/tokens/tokenize.ts","../../states-parser/src/tokens/cursor.ts","../../states-parser/src/parser.ts","../src/generate/state/indexes.ts","../src/generate/parameters.ts","../src/generate/literal.ts","../src/generate/expression/binary.ts","../src/generate/arguments.ts","../src/generate/expression/call.ts","../src/generate/expression/identifier.ts","../src/generate/expression/logical.ts","../src/generate/expression/member.ts","../src/generate/expression/this.ts","../src/generate/expression/unary.ts","../src/generate/expression/index.ts","../src/generate/property.ts","../src/generate/state/mutations.ts","../src/generate/state/index.ts","../src/generate/index.ts"],"sourcesContent":["export * from './generate';\n","export const generateDescriptionComment = (\n  {\n    description,\n    deprecated,\n  }: {\n    description?: string | null;\n    deprecated?: string | boolean;\n  },\n  indent: string,\n): string => {\n  const deprecationReason = deprecated === true ? '' : deprecated || null;\n\n  return description\n    ? `/**\\n${indent} * ${description.replace(/\\n/g, `\\n${indent} * `)}${\n        deprecationReason\n          ? `\\n${indent} *\\n${indent} * @deprecated ${deprecationReason.replace(\n              /\\n/g,\n              `\\n${indent} * `,\n            )}`\n          : ''\n      }\\n${indent} */\\n${indent}`\n    : deprecationReason\n    ? `/**\\n${indent} * @deprecated ${deprecationReason.replace(\n        /\\n/g,\n        `\\n${indent} * `,\n      )}\\n${indent} */\\n${indent}`\n    : '';\n};\n","import { Either } from '@neuledge/states';\nimport { generateDescriptionComment } from './comments';\n\nexport const generateEither = (either: Either): string =>\n  generateDescriptionComment(either, '') +\n  `${generateEitherType(either)}\\n` +\n  `${generateEitherConst(either)}\\n` +\n  `export type $${either.name} = $.Entity<typeof ${either.name}[number]>;`;\n\nconst generateEitherType = (either: Either): string =>\n  `export type ${either.name} = ${either.states\n    .map((state) => state.name)\n    .join(' | ')};`;\n\nconst generateEitherConst = (either: Either): string =>\n  `export const ${either.name}: $.Either<'${either.name}', ${either.states\n    .map((state) => `typeof ${state.name}`)\n    .join(' | ')}> =\\n  $.either('${either.name}', [${either.states\n    .map((state) => state.name)\n    .join(', ')}]);`;\n","export const generateImports = (): string =>\n  `import { $ } from '@neuledge/engine';`;\n","import { StoreShapeType } from '@neuledge/store';\nimport {\n  CustomScalar,\n  EntityExpression,\n  NonNullableEntity,\n  Scalar,\n} from '@neuledge/states';\n\nexport const generateEntityScalar = (entity: NonNullableEntity): string => {\n  switch (entity.type) {\n    case 'Either': {\n      return `[...${entity.name}]`;\n    }\n\n    case 'State': {\n      return `[${entity.name}]`;\n    }\n\n    case 'Scalar': {\n      return `$.scalars.${entity.name}`;\n    }\n\n    default: {\n      // @ts-expect-error `entity` is never\n      throw new TypeError(`Unexpected entity type: ${entity.type}`);\n    }\n  }\n};\n\nexport const generateEntityType = (entity: NonNullableEntity): string => {\n  switch (entity.type) {\n    case 'Either': {\n      return `$.Id<typeof ${entity.name}[number]>`;\n    }\n\n    case 'State': {\n      return `$.Id<typeof ${entity.name}>`;\n    }\n\n    case 'Scalar': {\n      return entity.node ? entity.name : `$.scalars.${entity.name}`;\n    }\n\n    default: {\n      // @ts-expect-error `entity` is never\n      throw new TypeError(`Unexpected entity type: ${entity.type}`);\n    }\n  }\n};\n\nexport const generateWhereEntityExpression = (\n  { entity, list }: EntityExpression,\n  nullable?: boolean,\n): string => {\n  switch (entity.type) {\n    case 'Either': {\n      const type = list ? 'ListState' : 'State';\n      const nullish = nullable ? 'Nullable' : '';\n\n      return `$.Where${nullish}${type}<typeof ${entity.name}[number]>`;\n    }\n\n    case 'State': {\n      const type = list ? 'ListState' : 'State';\n      const nullish = nullable ? 'Nullable' : '';\n\n      return `$.Where${nullish}${type}<typeof ${entity.name}>`;\n    }\n\n    case 'Scalar': {\n      return generateWhereScalar(entity, nullable, list);\n    }\n\n    default: {\n      // @ts-expect-error `entity` is never\n      throw new TypeError(`Unexpected entity type: ${entity.type}`);\n    }\n  }\n};\n\nconst generateWhereScalar = (\n  scalar: Scalar | CustomScalar,\n  nullable: boolean | undefined,\n  list: boolean,\n): string => {\n  const nullish = nullable ? 'Nullable' : '';\n  const name = scalar.node ? scalar.name : `$.scalars.${scalar.name}`;\n  const where = list ? 'Array' : WhereShapeTypeMap[scalar.shape.type];\n\n  return `$.Where${nullish}${where}<${name}>`;\n};\n\nconst WhereShapeTypeMap: Record<StoreShapeType, string> = {\n  boolean: 'Boolean',\n  'date-time': 'DateTime',\n  number: 'Number',\n  string: 'String',\n  binary: 'Buffer',\n  json: 'Unknown',\n  enum: 'Enum',\n};\n","import { Type } from '@neuledge/states';\nimport { generateEntityScalar, generateEntityType } from './entity';\n\nexport const generateTypeScalar = (type: Type): string => {\n  switch (type.type) {\n    // case 'TypeGenerator':\n    //   throw new ParsingError('Not implemented.');\n\n    case 'EntityExpression': {\n      return type.list\n        ? `[${generateEntityScalar(type.entity)}]`\n        : generateEntityScalar(type.entity);\n    }\n\n    default: {\n      throw new TypeError(`Unexpected type: ${type.type}`);\n    }\n  }\n};\n\nexport const generateTypeType = (type: Type): string => {\n  switch (type.type) {\n    // case 'TypeGenerator':\n    //   throw new ParsingError('Not implemented.');\n\n    case 'EntityExpression': {\n      return type.list\n        ? `${generateEntityType(type.entity)}[]`\n        : generateEntityType(type.entity);\n    }\n\n    default: {\n      throw new TypeError(`Unexpected type: ${type.type}`);\n    }\n  }\n};\n","import { ScalarField, State } from '@neuledge/states';\nimport { generateDescriptionComment } from '../comments';\nimport { generateEntityScalar } from '../entity';\nimport { generateTypeScalar, generateTypeType } from '../type';\n\nexport const generateStateScalars = (state: State, indent: string): string =>\n  `() => ({${Object.values(state.fields)\n    .filter((item): item is ScalarField => item.type === 'ScalarField')\n    .map(\n      (item) =>\n        `\\n${indent}  ${item.name}: { type: ${generateTypeScalar(\n          item.as,\n        )}, index: ${item.index}${item.nullable ? ', nullable: true' : ''} },`,\n    )\n    .join('')}\\n${indent}})`;\n\nexport const generateStateFields = (state: State, indent: string): string =>\n  `${Object.values(state.fields)\n    .filter((item): item is ScalarField => item.type === 'ScalarField')\n    .map(\n      (item) =>\n        `\\n${indent}${generateDescriptionComment(item, indent)}${item.name}${\n          item.nullable\n            ? `?: ${generateTypeType(item.as)} | null;`\n            : `!: ${generateTypeType(item.as)};`\n        }`,\n    )\n    .join('')}`;\n\nexport const generateStateOptionalRelations = (\n  state: State,\n  indent: string,\n): string | null => {\n  const fields = Object.values(state.fields).filter(\n    (item) => item.type === 'RelationField' || item.as.entity.type !== 'Scalar',\n  );\n\n  if (!fields.length) {\n    return null;\n  }\n\n  return `() => ({${fields\n    .map(\n      (item) =>\n        `\\n${indent}  ${item.name}: { states: ${generateEntityScalar(\n          item.as.entity,\n        )}${item.as.list ? ', list: true' : ''}${\n          item.type === 'RelationField' && item.referenceField\n            ? `, reference: '${item.referenceField.replace(/('|\\\\)/g, '\\\\$1')}'`\n            : ''\n        } } as const,`,\n    )\n    .join('')}\\n${indent}})`;\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\n\nexport interface IdentifierNode extends AbstractNode<'Identifier'> {\n  name: string;\n}\n\nexport const parseIdentifierNode = (cursor: TokenCursor): IdentifierNode => ({\n  type: 'Identifier',\n  path: cursor.path,\n  start: cursor.start,\n  name: cursor.consume('Word', null, `identifier name`).value,\n  end: cursor.end,\n});\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\nimport { IdentifierNode, parseIdentifierNode } from './identifier';\n\nexport interface ArgumentNode<Value> extends AbstractNode<'Argument'> {\n  key: IdentifierNode;\n  value: Value;\n}\n\nexport const parseMaybeArgumentNodes = <Value>(\n  cursor: TokenCursor,\n  parseValue: (cursor: TokenCursor) => Value,\n  allowImplicit?: boolean,\n): ArgumentNode<Value>[] => {\n  if (!cursor.pickPunctuation('(')) {\n    return [];\n  }\n\n  return parseArgumentNodes(cursor, parseValue, allowImplicit);\n};\n\nexport const parseArgumentNodes = <Value>(\n  cursor: TokenCursor,\n  parseValue: (cursor: TokenCursor) => Value,\n  allowImplicit?: boolean,\n): ArgumentNode<Value>[] => {\n  const { index: position } = cursor;\n\n  cursor.consumePunctuation('(');\n\n  try {\n    const args: ArgumentNode<Value>[] = [];\n    do {\n      if (cursor.maybeConsumePunctuation(')')) {\n        return args;\n      }\n\n      args.push(parseArgumentNode(cursor, parseValue, allowImplicit));\n    } while (cursor.maybeConsumePunctuation(','));\n\n    cursor.consumePunctuation(')');\n    return args;\n  } catch (error) {\n    cursor.index = position;\n    throw error;\n  }\n};\n\nconst parseArgumentNode = <Value>(\n  cursor: TokenCursor,\n  parseValue: (cursor: TokenCursor) => Value,\n  allowImplicit?: boolean,\n): ArgumentNode<Value> => {\n  const start = cursor.start;\n  const path = cursor.path;\n\n  const key = parseIdentifierNode(cursor);\n\n  const explicit = allowImplicit\n    ? cursor.maybeConsumePunctuation(':')\n    : cursor.consumePunctuation(':');\n\n  const value = explicit ? parseValue(cursor) : (key as Value);\n\n  return {\n    type: 'Argument',\n    path,\n    start,\n    end: cursor.end,\n    key,\n    value,\n  };\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\n\nexport interface LiteralNode<T extends LiteralValue = LiteralValue>\n  extends AbstractNode<'Literal'> {\n  value: T;\n}\n\nexport type LiteralValue =\n  | string\n  | number\n  | boolean\n  | null\n  | LiteralValue[]\n  | { [K in string]?: LiteralValue };\n\nconst LiteralValues: Partial<Record<string, LiteralNode['value']>> = {\n  true: true,\n  false: false,\n  null: null,\n  NaN: NaN,\n  Infinity: Infinity,\n};\n\nexport const parseLiteralNode = <Value extends LiteralValue>(\n  cursor: TokenCursor,\n  parseValue: (cursor: TokenCursor) => Value = parseLiteralValue as never,\n): LiteralNode<Value> => ({\n  type: 'Literal',\n  path: cursor.path,\n  start: cursor.start,\n  value: parseValue(cursor),\n  end: cursor.end,\n});\n\nexport const parseUInt8LiteralNode = (\n  cursor: TokenCursor,\n): LiteralNode<number> => ({\n  type: 'Literal',\n  path: cursor.path,\n  start: cursor.start,\n  value: parseUInt8(cursor),\n  end: cursor.end,\n});\n\n// value parsers\n\nconst parseUInt8 = (cursor: TokenCursor): number =>\n  cursor.consume(\n    'Number',\n    ({ value }) => value > 0 && Number.isInteger(value) && value <= 255,\n    `positive unsigned integer between 1 and 255`,\n  ).value;\n\nconst parseLiteralValue = (cursor: TokenCursor): LiteralValue => {\n  const token = cursor.current;\n\n  switch (token?.type) {\n    case 'String':\n    case 'Number': {\n      cursor.index += 1;\n      return token.value;\n    }\n\n    case 'Word': {\n      const value = LiteralValues[token.value] as LiteralNode['value'];\n      if (value === undefined) {\n        throw cursor.createError(`literal value`);\n      }\n\n      cursor.index += 1;\n      return value;\n    }\n\n    case 'Punctuation': {\n      return parseLiteralPunctuationValue(cursor, token.value);\n    }\n\n    default: {\n      throw cursor.createError(`literal value`);\n    }\n  }\n};\n\nconst parseLiteralPunctuationValue = (\n  cursor: TokenCursor,\n  value: string,\n): LiteralValue => {\n  switch (value) {\n    case '-':\n    case '+': {\n      cursor.index += 1;\n\n      const { index: position } = cursor;\n      const num = parseLiteralValue(cursor);\n\n      if (typeof num === 'number') {\n        return value === '-' ? -num : num;\n      }\n\n      // rollback position before throw\n      cursor.index = position;\n      throw cursor.createError(`literal number`);\n    }\n\n    case '[': {\n      cursor.index += 1;\n      const values = parseLiteralArrayValues(cursor);\n\n      cursor.consumePunctuation(']');\n      return values;\n    }\n\n    case '{': {\n      cursor.index += 1;\n      const entries = parseObjectEntries(cursor);\n\n      cursor.consumePunctuation('}');\n      return Object.fromEntries(entries);\n    }\n\n    default: {\n      throw cursor.createError(`literal value`);\n    }\n  }\n};\n\nconst parseLiteralArrayValues = (cursor: TokenCursor): LiteralValue[] => {\n  const values: LiteralValue[] = [];\n\n  while (!cursor.pickPunctuation(']')) {\n    values.push(parseLiteralValue(cursor));\n\n    if (!cursor.maybeConsumePunctuation(',')) {\n      break;\n    }\n  }\n\n  return values;\n};\n\nconst parseObjectEntries = (cursor: TokenCursor): [string, LiteralValue][] => {\n  const entries: [string, LiteralValue][] = [];\n\n  while (!cursor.pickPunctuation('}')) {\n    const key = (\n      cursor.maybeConsume('String') ||\n      cursor.consume('Word', undefined, `object key`)\n    ).value;\n\n    cursor.consumePunctuation(':');\n    const value = parseLiteralValue(cursor);\n\n    entries.push([key, value]);\n\n    if (!cursor.maybeConsumePunctuation(',')) {\n      break;\n    }\n  }\n\n  return entries;\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\nimport { ArgumentNode, parseMaybeArgumentNodes } from './argument';\nimport { IdentifierNode, parseIdentifierNode } from './identifier';\nimport { LiteralNode, parseLiteralNode } from './literal';\n\nexport interface DecoratorNode extends AbstractNode<'Decorator'> {\n  callee: IdentifierNode;\n  arguments: ArgumentNode<LiteralNode>[];\n}\n\nexport const parseDecoratorNodes = (cursor: TokenCursor): DecoratorNode[] => {\n  const decorators: DecoratorNode[] = [];\n\n  for (let decorator; (decorator = parseMaybeDecoratorNode(cursor)); ) {\n    decorators.push(decorator);\n  }\n\n  return decorators;\n};\n\nconst parseMaybeDecoratorNode = (\n  cursor: TokenCursor,\n): DecoratorNode | undefined => {\n  const start = cursor.start;\n  const path = cursor.path;\n\n  const decoratorToken = cursor.maybeConsumePunctuation('@');\n  if (!decoratorToken) return undefined;\n\n  if (!decoratorToken.adjacent) {\n    cursor.index -= 1;\n    throw cursor.createError('decorator name');\n  }\n\n  const callee = parseIdentifierNode(cursor);\n  const args = parseMaybeArgumentNodes(cursor, parseLiteralNode);\n\n  return {\n    type: 'Decorator',\n    path,\n    start,\n    end: cursor.end,\n    callee,\n    arguments: args,\n  };\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\n\nexport interface DescriptionNode extends AbstractNode<'Description'> {\n  value: string;\n}\n\nexport const parseMaybeDescriptionNode = (\n  cursor: TokenCursor,\n): DescriptionNode | undefined => {\n  const start = cursor.start;\n  const path = cursor.path;\n\n  const strToken = cursor.maybeConsume(\n    'String',\n    (token) => token.kind === '\"' || token.kind === '\"\"\"',\n  );\n\n  return (\n    strToken && {\n      type: 'Description',\n      path,\n      start,\n      end: cursor.end,\n      value: strToken.value,\n    }\n  );\n};\n","import { TokenCursor } from '@/tokens';\nimport { DecoratorNode } from './decorator';\nimport { DescriptionNode } from './description';\nimport { IdentifierNode, parseIdentifierNode } from './identifier';\nimport { NamedNode } from './named';\n\nexport const EITHER_KEYWORD = 'either';\n\nexport interface EitherNode extends NamedNode<'Either'> {\n  states: IdentifierNode[];\n}\n\nexport const parseEitherNode = (\n  cursor: TokenCursor,\n  description?: DescriptionNode,\n  decorators: DecoratorNode[] = [],\n): EitherNode => {\n  const start = cursor.start;\n\n  cursor.consumeKeyword(EITHER_KEYWORD);\n  const id = parseIdentifierNode(cursor);\n\n  cursor.consumePunctuation('=');\n  const states = parseEitherStateNodes(cursor);\n\n  return {\n    type: 'Either',\n    path: cursor.path,\n    start,\n    end: cursor.end,\n    id,\n    description,\n    decorators,\n    states,\n  };\n};\n\nconst parseEitherStateNodes = (cursor: TokenCursor): IdentifierNode[] => {\n  const states: IdentifierNode[] = [];\n\n  do {\n    const state = parseIdentifierNode(cursor);\n    states.push(state);\n  } while (cursor.maybeConsumePunctuation('|'));\n\n  return states;\n};\n","import { AbstractNode } from '../abstract';\nimport { ExpressionNode } from './expression';\n\nconst BinaryExpressionNodeOperators = {\n  '+': 1,\n  '-': 1,\n  '*': 1,\n  '/': 1,\n  '%': 1,\n  '**': 1,\n  '==': 1,\n  '!=': 1,\n  '===': 1,\n  '!==': 1,\n  '<': 1,\n  '<=': 1,\n  '>': 1,\n  '>=': 1,\n} as const;\n\nexport const isBinaryExpressionNodeOperator = (\n  operator: string,\n): operator is keyof typeof BinaryExpressionNodeOperators =>\n  operator in BinaryExpressionNodeOperators;\n\nexport interface BinaryExpressionNode extends AbstractNode<'BinaryExpression'> {\n  operator: keyof typeof BinaryExpressionNodeOperators;\n  left: ExpressionNode;\n  right: ExpressionNode;\n}\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from '../abstract';\nimport { IdentifierNode, parseIdentifierNode } from '../identifier';\n\nexport type IdentifierExpressionNode =\n  | ThisExpressionNode\n  | NullLiteralNode\n  | IdentifierNode;\n\nexport interface ThisExpressionNode extends AbstractNode<'ThisExpression'> {\n  name: 'this';\n}\n\nexport interface NullLiteralNode extends AbstractNode<'NullLiteral'> {\n  value: null;\n}\n\nexport const parseIdentifierExpressionNode = (\n  cursor: TokenCursor,\n): IdentifierExpressionNode => {\n  const start = cursor.start;\n  const value = cursor.pickKeyword('this', 'null')?.value;\n\n  switch (value) {\n    case 'this': {\n      cursor.consumeKeyword('this');\n\n      return {\n        type: 'ThisExpression',\n        path: cursor.path,\n        start,\n        end: cursor.end,\n        name: 'this',\n      };\n    }\n\n    case 'null': {\n      cursor.consumeKeyword('null');\n\n      return {\n        type: 'NullLiteral',\n        path: cursor.path,\n        start,\n        end: cursor.end,\n        value: null,\n      };\n    }\n\n    default: {\n      return parseIdentifierNode(cursor);\n    }\n  }\n};\n","import { AbstractNode } from '../abstract';\nimport { ExpressionNode } from './expression';\n\nconst LogicalExpressionNodeOperators = {\n  '&&': 1,\n  '||': 1,\n  '??': 1,\n} as const;\n\nexport const isLogicalExpressionNodeOperator = (\n  operator: string,\n): operator is keyof typeof LogicalExpressionNodeOperators =>\n  operator in LogicalExpressionNodeOperators;\n\nexport interface LogicalExpressionNode\n  extends AbstractNode<'LogicalExpression'> {\n  operator: keyof typeof LogicalExpressionNodeOperators;\n  left: ExpressionNode;\n  right: ExpressionNode;\n}\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from '../abstract';\nimport { IdentifierNode, parseIdentifierNode } from '../identifier';\nimport {\n  IdentifierExpressionNode,\n  NullLiteralNode,\n  parseIdentifierExpressionNode,\n} from './identifier';\n\nexport interface MemberExpressionNode extends AbstractNode<'MemberExpression'> {\n  object:\n    | Exclude<IdentifierExpressionNode, NullLiteralNode>\n    | MemberExpressionNode;\n  property: IdentifierNode;\n}\n\nexport const parseMemberExpressionNode = (\n  cursor: TokenCursor,\n): MemberExpressionNode => {\n  const start = cursor.start;\n\n  let object: IdentifierExpressionNode | MemberExpressionNode =\n    parseIdentifierExpressionNode(cursor);\n  if (object.type === 'NullLiteral') {\n    throw cursor.createError(`Unexpected null literal`);\n  }\n\n  cursor.consumePunctuation('.');\n\n  do {\n    const property = parseIdentifierNode(cursor);\n\n    object = {\n      type: 'MemberExpression',\n      path: cursor.path,\n      start,\n      end: cursor.end,\n      object,\n      property,\n    };\n  } while (cursor.maybeConsumePunctuation('.'));\n\n  return object;\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from '../abstract';\nimport { ExpressionNode, parseExpressionNode } from './expression';\n\nconst UnaryExpressionNodeOperators = {\n  '!': 1,\n  '-': 1,\n  '+': 1,\n  '~': 1,\n} as const;\n\nexport interface UnaryExpressionNode extends AbstractNode<'UnaryExpression'> {\n  operator: keyof typeof UnaryExpressionNodeOperators;\n  argument: ExpressionNode;\n}\n\nconst UnaryExpressionNodeOperatorsArray = Object.keys(\n  UnaryExpressionNodeOperators,\n) as (keyof typeof UnaryExpressionNodeOperators)[];\n\nexport const isUnaryExpressionNodeOperator = (\n  operator: string,\n): operator is keyof typeof UnaryExpressionNodeOperators =>\n  operator in UnaryExpressionNodeOperators;\n\nexport const parseUnaryExpressionNode = (\n  cursor: TokenCursor,\n): UnaryExpressionNode => {\n  const start = cursor.start;\n\n  const operator = cursor.consumePunctuation(\n    ...UnaryExpressionNodeOperatorsArray,\n  ).value;\n  const argument = parseExpressionNode(cursor);\n\n  return {\n    type: 'UnaryExpression',\n    path: cursor.path,\n    start,\n    end: cursor.end,\n    operator,\n    argument,\n  };\n};\n","import { TokenCursor } from '@/tokens';\nimport { LiteralNode, parseLiteralNode } from '../literal';\nimport { BinaryExpressionNode, isBinaryExpressionNodeOperator } from './binary';\nimport { CallExpressionNode, parseCallExpressionNode } from './call';\nimport {\n  IdentifierExpressionNode,\n  parseIdentifierExpressionNode,\n} from './identifier';\nimport {\n  isLogicalExpressionNodeOperator,\n  LogicalExpressionNode,\n} from './logical';\nimport { MemberExpressionNode, parseMemberExpressionNode } from './member';\nimport {\n  isUnaryExpressionNodeOperator,\n  parseUnaryExpressionNode,\n  UnaryExpressionNode,\n} from './unary';\n\nexport type ExpressionNode =\n  | MemberExpressionNode\n  | CallExpressionNode\n  | BinaryExpressionNode\n  | LogicalExpressionNode\n  | UnaryExpressionNode\n  | LiteralNode\n  | IdentifierExpressionNode;\n\nexport const parseExpressionNode = (cursor: TokenCursor): ExpressionNode => {\n  const start = cursor.start;\n  const node = parseCoreExpressionNode(cursor);\n\n  const current = cursor.current;\n  if (current?.type !== 'Punctuation') {\n    return node;\n  }\n\n  if (isLogicalExpressionNodeOperator(current.value)) {\n    cursor.consume('Punctuation');\n    const right = parseExpressionNode(cursor);\n\n    return {\n      type: 'LogicalExpression',\n      path: cursor.path,\n      start,\n      end: cursor.end,\n      operator: current.value,\n      left: node,\n      right,\n    };\n  }\n\n  if (isBinaryExpressionNodeOperator(current.value)) {\n    cursor.consume('Punctuation');\n    const right = parseExpressionNode(cursor);\n\n    return {\n      type: 'BinaryExpression',\n      path: cursor.path,\n      start,\n      end: cursor.end,\n      operator: current.value,\n      left: node,\n      right,\n    };\n  }\n\n  return node;\n};\n\nconst parseCoreExpressionNode = (cursor: TokenCursor): ExpressionNode => {\n  const { current, next } = cursor;\n\n  if (current?.type === 'Punctuation') {\n    if (current.value === '(') {\n      cursor.consumePunctuation('(');\n\n      const node = parseExpressionNode(cursor);\n      cursor.consumePunctuation(')');\n\n      return node;\n    }\n\n    if (isUnaryExpressionNodeOperator(current.value)) {\n      return parseUnaryExpressionNode(cursor);\n    }\n\n    return parseLiteralNode(cursor);\n  }\n\n  if (current?.type !== 'Word') {\n    return parseLiteralNode(cursor);\n  }\n\n  switch (next?.value) {\n    case '(': {\n      return parseCallExpressionNode(cursor);\n    }\n\n    case '.': {\n      return parseMemberExpressionNode(cursor);\n    }\n\n    default: {\n      return parseIdentifierExpressionNode(cursor);\n    }\n  }\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from '../abstract';\nimport { ArgumentNode, parseArgumentNodes } from '../argument';\nimport { IdentifierNode, parseIdentifierNode } from '../identifier';\nimport { ExpressionNode, parseExpressionNode } from './expression';\n\nexport interface CallExpressionNode extends AbstractNode<'CallExpression'> {\n  callee: IdentifierNode;\n  arguments: ArgumentNode<ExpressionNode>[];\n}\n\nexport const parseCallExpressionNode = (\n  cursor: TokenCursor,\n): CallExpressionNode => {\n  const start = cursor.start;\n\n  const callee = parseIdentifierNode(cursor);\n  const args = parseArgumentNodes(cursor, parseExpressionNode, true);\n\n  return {\n    type: 'CallExpression',\n    path: cursor.path,\n    start,\n    end: cursor.end,\n    callee,\n    arguments: args,\n  };\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\nimport { ArgumentNode, parseMaybeArgumentNodes } from './argument';\nimport { IdentifierNode, parseIdentifierNode } from './identifier';\nimport { LiteralNode, parseLiteralNode } from './literal';\n\nexport type TypeNode = TypeGeneratorNode | TypeExpressionNode;\n\nexport interface TypeGeneratorNode extends AbstractNode<'TypeGenerator'> {\n  identifier: IdentifierNode;\n  arguments: ArgumentNode<LiteralNode>[];\n}\n\nexport interface TypeExpressionNode extends AbstractNode<'TypeExpression'> {\n  identifier: IdentifierNode;\n  list: boolean;\n}\n\nexport const parseTypeNode = (cursor: TokenCursor): TypeNode => {\n  const start = cursor.start;\n  const path = cursor.path;\n\n  const identifier = parseIdentifierNode(cursor);\n  const args = parseMaybeArgumentNodes(cursor, parseLiteralNode);\n\n  if (args.length) {\n    return {\n      type: 'TypeGenerator',\n      path,\n      start,\n      end: cursor.end,\n      identifier,\n      arguments: args,\n    };\n  }\n\n  const list = !!cursor.maybeConsumePunctuation('[');\n  if (list) {\n    cursor.consumePunctuation(']');\n  }\n\n  return {\n    type: 'TypeExpression',\n    path,\n    start,\n    end: cursor.end,\n    identifier,\n    list,\n  };\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\nimport { DecoratorNode, parseDecoratorNodes } from './decorator';\nimport { DescriptionNode, parseMaybeDescriptionNode } from './description';\nimport { IdentifierNode, parseIdentifierNode } from './identifier';\nimport { parseTypeNode, TypeNode } from './type';\n\nexport interface ParameterNode extends AbstractNode<'Parameter'> {\n  key: IdentifierNode;\n  description?: DescriptionNode;\n  decorators: DecoratorNode[];\n  as: TypeNode;\n  nullable: boolean;\n}\n\nexport const parseParameterNodes = (cursor: TokenCursor): ParameterNode[] => {\n  const parameters: ParameterNode[] = [];\n\n  cursor.consumePunctuation('(');\n\n  while (!cursor.maybeConsumePunctuation(')')) {\n    const parameter = parseParameterNode(cursor);\n    parameters.push(parameter);\n\n    cursor.maybeConsumePunctuation(',');\n  }\n\n  return parameters;\n};\n\nconst parseParameterNode = (cursor: TokenCursor): ParameterNode => {\n  const start = cursor.start;\n\n  const description = parseMaybeDescriptionNode(cursor);\n  const decorators = parseDecoratorNodes(cursor);\n  const key = parseIdentifierNode(cursor);\n  const nullable = !!cursor.maybeConsumePunctuation('?');\n\n  cursor.consumePunctuation(':');\n  const as = parseTypeNode(cursor);\n\n  return {\n    type: 'Parameter',\n    path: cursor.path,\n    start,\n    end: cursor.end,\n    key,\n    as,\n    nullable,\n    description,\n    decorators,\n  };\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\nimport {\n  ExpressionNode,\n  // MemberExpressionNode,\n  parseExpressionNode,\n} from './expressions';\nimport { IdentifierNode, parseIdentifierNode } from './identifier';\n\nexport type ReturnBodyNode = PropertyNode; /* | SpreadElementNode; */\n\nexport interface PropertyNode extends AbstractNode<'Property'> {\n  key: IdentifierNode;\n  value: ExpressionNode;\n}\n\n// export interface SpreadElementNode extends AbstractNode<'SpreadElement'> {\n//   argument: MemberExpressionNode['object'];\n// }\n\nexport const parseReturnBodyNodes = (cursor: TokenCursor): ReturnBodyNode[] => {\n  const body: ReturnBodyNode[] = [];\n\n  cursor.consumePunctuation('{');\n\n  do {\n    if (cursor.maybeConsumePunctuation('}')) {\n      return body;\n    }\n\n    body.push(parseReturnBodyNode(cursor));\n  } while (cursor.maybeConsumePunctuation(','));\n\n  cursor.consumePunctuation('}');\n  return body;\n};\n\nconst parseReturnBodyNode = (cursor: TokenCursor): ReturnBodyNode => {\n  const start = cursor.start;\n\n  const key = parseIdentifierNode(cursor);\n\n  const explicit = cursor.maybeConsumePunctuation(':');\n  const value = explicit ? parseExpressionNode(cursor) : key;\n\n  return {\n    type: 'Property',\n    path: cursor.path,\n    start,\n    end: cursor.end,\n    key,\n    value,\n  };\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\nimport { DecoratorNode } from './decorator';\nimport { DescriptionNode } from './description';\nimport { IdentifierNode, parseIdentifierNode } from './identifier';\nimport { ParameterNode, parseParameterNodes } from './parameter';\nimport { parseReturnBodyNodes, ReturnBodyNode } from './property';\n\nexport interface MutationNode extends AbstractNode<'Mutation'> {\n  key: IdentifierNode;\n  description?: DescriptionNode;\n  decorators: DecoratorNode[];\n  from?: IdentifierNode;\n  parameters: ParameterNode[];\n  returns: IdentifierNode;\n  body: ReturnBodyNode[];\n}\n\nexport const parseMutationNode = (\n  cursor: TokenCursor,\n  description?: DescriptionNode,\n  decorators: DecoratorNode[] = [],\n): MutationNode => {\n  const start = cursor.start;\n\n  const firstId = parseIdentifierNode(cursor);\n  const secondId = cursor.maybeConsumePunctuation('.')\n    ? parseIdentifierNode(cursor)\n    : undefined;\n\n  const parameters = parseParameterNodes(cursor);\n\n  cursor.consumePunctuation(':');\n  const returns = parseIdentifierNode(cursor);\n\n  const hasBody = cursor.maybeConsumePunctuation('=>');\n  const body = hasBody ? parseReturnBodyNodes(cursor) : [];\n\n  return {\n    type: 'Mutation',\n    path: cursor.path,\n    start,\n    end: cursor.end,\n    key: secondId || firstId,\n    description,\n    decorators,\n    from: secondId ? firstId : undefined,\n    parameters,\n    returns,\n    body,\n  };\n};\n","export class ParsingError extends SyntaxError {\n  public readonly name = 'ParsingError';\n\n  public readonly start: number;\n  public readonly end: number;\n  public readonly path?: string;\n\n  constructor(\n    position: { start: number; end: number; path?: string },\n    message: string,\n  ) {\n    super(message);\n\n    // because we are extending a built-in class\n    Object.setPrototypeOf(this, ParsingError.prototype);\n\n    this.start = position.start;\n    this.end = position.end;\n    this.path = position.path;\n\n    this.stack = `${this.name}: ${this.message}\\r\\n\\tat ${\n      this.path ?? `character ${this.start}`\n    }`;\n  }\n}\n","import { TokenCursor } from '@/tokens';\nimport { parseDecoratorNodes } from './decorator';\nimport { parseMaybeDescriptionNode } from './description';\nimport { ExcludedFieldNode } from './excluded-field';\nimport { ReferenceFieldNode } from './reference-field';\nimport { FieldNode } from './field';\nimport { parseIdentifierNode } from './identifier';\nimport { LiteralNode, parseUInt8LiteralNode } from './literal';\nimport { parseTypeNode } from './type';\nimport { ParsingError } from '@/error';\n\nexport const STATE_FIELD_INDEX_MAX_INPUT_VALUE = 255;\n\nexport type StateFieldNode = FieldNode | ReferenceFieldNode | ExcludedFieldNode;\n\nexport const parseStateFieldNodes = (\n  cursor: TokenCursor,\n  hasParent?: boolean,\n): StateFieldNode[] => {\n  const fieldMap: Record<string, StateFieldNode> = {};\n  const indexMap: Record<number, StateFieldNode> = {};\n\n  cursor.consumePunctuation('{');\n\n  while (!cursor.maybeConsumePunctuation('}')) {\n    const field = parseStateFieldNode(cursor);\n\n    if (fieldMap[field.key.name]) {\n      throw new ParsingError(\n        field.key,\n        `Duplicate field name '${field.key.name}'`,\n      );\n    }\n\n    if (!hasParent && field.type === 'ExcludedField') {\n      throw new ParsingError(\n        field,\n        `Unexpected excluded field on state without a parent state`,\n      );\n    }\n\n    if ('index' in field) {\n      if (indexMap[field.index.value]) {\n        throw new ParsingError(\n          field.index,\n          `Duplicate index for field name '${\n            indexMap[field.index.value].key.name\n          }'`,\n        );\n      }\n\n      indexMap[field.index.value] = field;\n    }\n\n    fieldMap[field.key.name] = field;\n\n    cursor.maybeConsumePunctuation(',');\n  }\n\n  return Object.values(fieldMap);\n};\n\nconst parseStateFieldNode = (cursor: TokenCursor): StateFieldNode => {\n  const description = parseMaybeDescriptionNode(cursor);\n  const decorators = parseDecoratorNodes(cursor);\n\n  const maybeRef = !description && !decorators.length;\n  const start = cursor.start;\n  const path = cursor.path;\n\n  const substractSign = maybeRef\n    ? cursor.maybeConsumePunctuation('-')\n    : undefined;\n\n  const firstId = parseIdentifierNode(cursor);\n  if (substractSign) {\n    return {\n      type: 'ExcludedField',\n      key: firstId,\n      path,\n      start,\n      end: cursor.end,\n    };\n  }\n\n  const dotSign = maybeRef ? cursor.maybeConsumePunctuation('.') : undefined;\n\n  if (!dotSign) {\n    return parseFieldNode(cursor, {\n      path,\n      start,\n      key: firstId,\n      description,\n      decorators,\n    });\n  }\n\n  const secId = parseIdentifierNode(cursor);\n\n  return parseReferenceFieldNode(cursor, {\n    path,\n    start,\n    state: firstId,\n    key: secId,\n  });\n};\n\nconst parseFieldNode = (\n  cursor: TokenCursor,\n  base: Pick<\n    FieldNode,\n    'key' | 'description' | 'decorators' | 'path' | 'start'\n  >,\n): FieldNode => {\n  const nullSign = cursor.maybeConsumePunctuation('?');\n\n  cursor.maybeConsumePunctuation(':');\n  const as = parseTypeNode(cursor);\n  const index = parseIndex(cursor);\n\n  return {\n    type: 'Field',\n    ...base,\n    end: cursor.end,\n    as,\n    index,\n    nullable: !!nullSign,\n  };\n};\n\nconst parseReferenceFieldNode = (\n  cursor: TokenCursor,\n  base: Pick<ReferenceFieldNode, 'state' | 'key' | 'path' | 'start'>,\n): ReferenceFieldNode => {\n  const index = parseIndex(cursor);\n\n  return {\n    type: 'ReferenceField',\n    ...base,\n    end: cursor.end,\n    index,\n  };\n};\n\nconst parseIndex = (cursor: TokenCursor): LiteralNode<number> => {\n  cursor.consumePunctuation('=');\n  return parseUInt8LiteralNode(cursor);\n};\n","import { TokenCursor } from '@/tokens';\nimport { DecoratorNode } from './decorator';\nimport { DescriptionNode } from './description';\nimport { IdentifierNode, parseIdentifierNode } from './identifier';\nimport { NamedNode } from './named';\nimport { parseStateFieldNodes, StateFieldNode } from './state-field';\n\nexport const STATE_KEYWORD = 'state';\n\nexport interface StateNode extends NamedNode<'State'> {\n  from?: IdentifierNode;\n  fields: StateFieldNode[];\n}\n\nexport const parseStateNode = (\n  cursor: TokenCursor,\n  description?: DescriptionNode,\n  decorators: DecoratorNode[] = [],\n): StateNode => {\n  const start = cursor.start;\n\n  cursor.consumeKeyword(STATE_KEYWORD);\n  const id = parseIdentifierNode(cursor);\n\n  const fromKeyword = cursor.maybeConsumeKeyword('from');\n  let from;\n  if (fromKeyword) {\n    from = parseIdentifierNode(cursor);\n  }\n\n  const fields = parseStateFieldNodes(cursor, !!from);\n\n  return {\n    type: 'State',\n    path: cursor.path,\n    start,\n    end: cursor.end,\n    id,\n    description,\n    from,\n    fields,\n    decorators,\n  };\n};\n","import { TokenCursor } from '@/tokens';\nimport { AbstractNode } from './abstract';\nimport { parseDecoratorNodes } from './decorator';\nimport { parseMaybeDescriptionNode } from './description';\nimport { EITHER_KEYWORD, parseEitherNode } from './either';\nimport { EntityNode } from './entity';\nimport { MigrationNode } from './migration';\nimport { MutationNode, parseMutationNode } from './mutation';\nimport { parseStateNode, STATE_KEYWORD } from './state';\n\nexport interface DocumentNode extends AbstractNode<'Root'> {\n  body: DocumentBodyNode[];\n}\n\nexport type DocumentBodyNode = EntityNode | MigrationNode | MutationNode;\n\nexport const parseDocumentNode = (cursor: TokenCursor): DocumentNode => ({\n  type: 'Root',\n  path: cursor.path,\n  start: cursor.start,\n  body: parseDocumentBodyNodes(cursor),\n  end: cursor.end,\n});\n\nconst parseDocumentBodyNodes = (cursor: TokenCursor): DocumentBodyNode[] => {\n  const body: DocumentBodyNode[] = [];\n\n  while (cursor.current) {\n    const description = parseMaybeDescriptionNode(cursor);\n    const decorators = parseDecoratorNodes(cursor);\n\n    const keyword = cursor.pickKeyword();\n    const nodeKeyword =\n      keyword && cursor.next?.type === 'Word' ? keyword.value : null;\n\n    let node: DocumentBodyNode;\n\n    switch (nodeKeyword) {\n      case STATE_KEYWORD: {\n        node = parseStateNode(cursor, description, decorators);\n        break;\n      }\n\n      case EITHER_KEYWORD: {\n        node = parseEitherNode(cursor, description, decorators);\n        break;\n      }\n\n      default: {\n        if (!keyword) {\n          // TODO parse migration\n          throw cursor.createError();\n        }\n\n        node = parseMutationNode(cursor, description, decorators);\n      }\n    }\n\n    body.push(node);\n  }\n\n  return body;\n};\n","import { PunctuationToken, StringToken, Token } from '@/tokens';\n\nconst TokenCharMap: Record<string, Token['type'] | 0 | -1> = {\n  '\"': 'String',\n  \"'\": 'String',\n  '': -1,\n  ' ': -1,\n  '\\t': -1,\n  '\\r': -1,\n  '\\n': -1,\n};\nfor (const char of '$_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') {\n  TokenCharMap[char] = 'Word';\n}\nfor (const char of '0123456789') {\n  TokenCharMap[char] = 'Number';\n}\n\nexport const tokenize = (content: string, path?: string): Token[] => {\n  const values = splitTokenValues(content);\n\n  const tokens: Token[] = [];\n  let position = 0;\n  let line = 1;\n  let column = 1;\n  let isComment = false;\n  let lastPunctuation: PunctuationToken | null = null;\n\n  for (const value of values) {\n    if (!isComment) {\n      const token = parseToken(\n        value,\n        position,\n        path && `${path}:${line}:${column}`,\n      );\n      if (token) {\n        if (lastPunctuation) {\n          lastPunctuation.adjacent = true;\n        }\n\n        tokens.push(token);\n        lastPunctuation = token.type === 'Punctuation' ? token : null;\n      } else {\n        lastPunctuation = null;\n        if (value === '#') isComment = true;\n      }\n    }\n\n    const lines = value.split(/\\r*\\n/g);\n    if (lines.length > 1) {\n      line += lines.length - 1;\n      column = 1;\n    }\n\n    column += lines[lines.length - 1].length;\n    position += value.length;\n\n    if (isComment && value.includes('\\n')) {\n      isComment = false;\n    }\n  }\n\n  return tokens;\n};\n\nconst splitTokenValues = (content: string): string[] =>\n  content.match(\n    /([$_a-z]\\w*|(?:\\d*\\.\\d+|\\d+)|\\s+|\"\"\"(?:[^\"]+|\"[^\"]|\"\"[^\"])*\"\"\"|\"(?:[^\\n\"\\\\]+|\\\\.)*\"|'(?:[^\\n'\\\\]+|\\\\.)*'|[<=>]=|=>|[!=]==|&&|!!|\\|\\||\\?\\?|\\*\\*|\\.\\.\\.|.)/gi,\n  ) || [];\n\nconst parseToken = (\n  value: string,\n  position: number,\n  path?: string,\n): Token | null => {\n  const kind = value[0];\n  const type = TokenCharMap[kind] || 'Punctuation';\n  const start = position;\n  const end = position + value.length;\n\n  switch (type) {\n    case 'Number': {\n      return { type, path, start, end, value: Number(value) };\n    }\n\n    case 'String': {\n      return {\n        type,\n        start,\n        end,\n        ...parseStringToken(kind, value),\n      };\n    }\n\n    case 'Punctuation': {\n      if (value.length > 1 && /^[+-]?(?:\\d*\\.\\d+|\\d+)$/.test(value)) {\n        return {\n          type: 'Number',\n          path,\n          start,\n          end,\n          value: Number(value),\n        };\n      }\n\n      if (value === '#') {\n        return null;\n      }\n\n      return { type, path, start, end, value, adjacent: false };\n    }\n\n    case 'Word': {\n      return { type, path, start, end, value };\n    }\n\n    case -1: {\n      return null;\n    }\n  }\n};\n\nconst parseStringToken = (\n  kind: string,\n  raw: string,\n): Pick<StringToken, 'value' | 'kind'> => {\n  if (kind === '\"' && raw[1] === '\"' && raw[2] === '\"') {\n    return {\n      kind: '\"\"\"',\n      value: raw\n        .slice(3, -3)\n        .trim()\n        .replace(/[\\t ]*\\r?\\n[\\t ]*/g, '\\n'),\n    };\n  }\n\n  return {\n    kind: kind as '\"' | \"'\",\n    value: raw.slice(1, -1).replace(/\\\\(.)/g, '$1'),\n  };\n};\n","import { tokenize } from './tokenize';\nimport { ParsingError } from '@/error';\nimport { PunctuationToken, Token, WordToken } from './index';\nimport { AbstractToken } from './abstract';\n\nexport class TokenCursor {\n  public readonly tokens: Token[];\n\n  constructor(\n    public readonly content: string,\n    path?: string,\n    public index = 0,\n  ) {\n    this.tokens = tokenize(content, path);\n  }\n\n  get current(): Token | undefined {\n    return this.tokens[this.index];\n  }\n\n  get next(): Token | undefined {\n    return this.tokens[this.index + 1];\n  }\n\n  get path(): string | undefined {\n    return this.tokens[this.index]?.path;\n  }\n\n  get start(): number {\n    return this.tokens[this.index]?.start ?? this.content.length;\n  }\n\n  get end(): number {\n    return this.tokens[this.index - 1]?.end ?? 0;\n  }\n\n  static isMatch<T extends Token['type']>(\n    token: Token | null | undefined,\n    type: T,\n    test?: ((token: Token & AbstractToken<T>) => boolean) | null,\n  ): token is Token & AbstractToken<T> {\n    if (token?.type !== type) {\n      return false;\n    }\n\n    if (test == null) {\n      return true;\n    }\n\n    try {\n      return test(token as Token & AbstractToken<T>);\n    } catch {\n      return false;\n    }\n  }\n\n  pickKeyword<V extends string>(\n    ...values: V[]\n  ): (WordToken & { value: V }) | null {\n    return this.pick(\n      'Word',\n      values.length ? (token) => values.includes(token.value as V) : undefined,\n    ) as (WordToken & { value: V }) | null;\n  }\n\n  consumeKeyword<V extends string>(...values: V[]): WordToken & { value: V } {\n    return this.consume(\n      'Word',\n      (token) => values.includes(token.value as V),\n      `'${values[0]}' keyword`,\n    ) as WordToken & { value: V };\n  }\n\n  pickPunctuation<V extends string>(\n    ...values: V[]\n  ): PunctuationToken & { value: V } {\n    return this.pick('Punctuation', (token) =>\n      values.includes(token.value as V),\n    ) as PunctuationToken & { value: V };\n  }\n\n  consumePunctuation<V extends string>(\n    ...values: V[]\n  ): PunctuationToken & { value: V } {\n    return this.consume(\n      'Punctuation',\n      (token) => values.includes(token.value as V),\n      `'${values[0]}' token`,\n    ) as PunctuationToken & { value: V };\n  }\n\n  pick<T extends Token['type']>(\n    type: T,\n    test?: ((token: Token & AbstractToken<T>) => boolean) | null,\n  ): (Token & AbstractToken<T>) | null {\n    const token = this.current;\n\n    if (!TokenCursor.isMatch<T>(token, type, test)) {\n      return null;\n    }\n\n    return token as Token & AbstractToken<T>;\n  }\n\n  consume<T extends Token['type']>(\n    type: T,\n    test?: ((token: Token & AbstractToken<T>) => boolean) | null,\n    expected?: string,\n  ): Token & AbstractToken<T> {\n    const token = this.pick<T>(type, test);\n\n    if (!token) {\n      throw this.createError(expected);\n    }\n\n    this.index += 1;\n    return token;\n  }\n\n  createError(expected?: string): ParsingError {\n    const token = this.current ?? null;\n\n    return new ParsingError(\n      token ?? { start: this.content.length - 1, end: this.content.length },\n      expected\n        ? `Expect ${expected}`\n        : token\n        ? `Unexpected token '${this.content.slice(token.start, token.end)}'`\n        : `Unexpected EOF`,\n    );\n  }\n\n  maybeConsumeKeyword<V extends string>(\n    value: V,\n  ): (WordToken & { value: V }) | undefined {\n    const token = this.current;\n\n    if (\n      !token ||\n      (token as WordToken).value !== value ||\n      token.type !== 'Word'\n    ) {\n      return undefined;\n    }\n\n    this.index += 1;\n    return token as WordToken & { value: V };\n  }\n\n  maybeConsumePunctuation<V extends string>(\n    value: V,\n  ): (PunctuationToken & { value: V }) | undefined {\n    const token = this.current;\n\n    if (\n      !token ||\n      (token as PunctuationToken).value !== value ||\n      token.type !== 'Punctuation'\n    ) {\n      return undefined;\n    }\n\n    this.index += 1;\n    return token as PunctuationToken & { value: V };\n  }\n\n  maybeConsume<T extends Token['type']>(\n    type: T,\n    test?: ((token: Token & AbstractToken<T>) => boolean) | null,\n  ): (Token & AbstractToken<T>) | undefined {\n    const token = this.current;\n\n    if (!TokenCursor.isMatch<T>(token, type, test)) {\n      return undefined;\n    }\n\n    this.index += 1;\n    return token as Token & AbstractToken<T>;\n  }\n\n  transaction<T>(fn: () => T): T {\n    const { index: position } = this;\n\n    try {\n      return fn();\n    } catch (error) {\n      this.index = position;\n      throw error;\n    }\n  }\n}\n","import { DocumentNode, parseDocumentNode } from './nodes';\nimport { TokenCursor } from './tokens';\n\nexport const parseStates = (\n  source: string,\n  filepath?: string,\n): DocumentNode => {\n  const cursor = new TokenCursor(source, filepath);\n  return parseDocumentNode(cursor);\n};\n","import { ParsingError } from '@neuledge/states-parser';\nimport { ScalarField, State, StateSortingIndex } from '@neuledge/states';\nimport { generateWhereEntityExpression } from '../entity';\nimport { generateTypeScalar } from '../type';\n\nexport const generateStateIdType = (state: State): string => {\n  const { fields, auto } = state.primaryKey;\n\n  const keys = Object.entries(fields).map(\n    ([name, dir]) => `'${dir === 'asc' ? '+' : '-'}${name}'`,\n  );\n\n  return `{ fields: [${keys.join(', ')}]${auto ? `, auto: '${auto}'` : ''} }`;\n};\n\nexport const generateStateQueryIndexes = (\n  state: State,\n  indent: string,\n): string =>\n  `static $where: ${generateStateWhereType(state, indent)};\\n` +\n  `${indent}static $unique: ${generateStateUniqueType(state, indent)};\\n` +\n  `${indent}static $filter: ${generateStateFilterType(state, indent)};`;\n\nexport const generateStateOptionalIndexes = (\n  state: State,\n  indent: string,\n): string | null => {\n  const indexes = Object.values(state.indexes).filter(\n    (index) => index.name !== state.primaryKey.name,\n  );\n\n  if (!indexes.length) {\n    return null;\n  }\n\n  return (\n    `{` +\n    indexes\n      .map(\n        (index) =>\n          `\\n${indent}  ${\n            /^\\w+$/.test(index.name)\n              ? index.name\n              : `'${index.name.replace(/['\\\\]/g, '\\\\$1')}'`\n          }: { fields: [${Object.entries(index.fields)\n            .map(([field, sort]) => `'${sort === 'asc' ? `+` : '-'}${field}'`)\n            .join(', ')}]${index.unique ? ', unique: true' : ''} } as const,`,\n      )\n      .join('') +\n    `\\n${indent}}`\n  );\n};\n\nconst generateStateFilterType = (state: State, indent: string): string =>\n  `{${Object.values(state.fields)\n    .filter((field) => field.type === 'ScalarField')\n    .map(\n      (item) =>\n        `\\n${indent}  ${item.name}?: ${generateWhereEntityExpression(\n          item.as,\n          item.nullable,\n        )} | null;`,\n    )\n    .join('')}\\n${indent}}`;\n\nconst generateStateWhereType = (state: State, indent: string): string => {\n  const paths = getIndexTypePaths(state, Object.values(state.indexes));\n  const multiPaths = paths.length > 1 || paths[0].length > 1;\n\n  return paths\n    .flatMap((fields) =>\n      fields.map(\n        (field, i) =>\n          `${multiPaths ? `\\n${indent}  | {` : '{'}${fields\n            .slice(0, i)\n            .map(\n              (item) =>\n                `\\n${multiPaths ? `${indent}    ` : indent}  ${\n                  item.name\n                }: ${generateWhereEntityExpression(item.as, item.nullable)};`,\n            )\n            .join('')}\\n${indent}${multiPaths ? '    ' : ''}  ${\n            field.name\n          }?: ${generateWhereEntityExpression(\n            field.as,\n            field.nullable,\n          )} | null;${fields\n            .slice(i + 1)\n            .map(\n              (item) =>\n                `\\n${multiPaths ? `${indent}    ` : indent}  ${\n                  item.name\n                }?: null;`,\n            )\n            .join('')}\\n${multiPaths ? `${indent}    ` : indent}}`,\n      ),\n    )\n    .join(multiPaths ? '' : ' | ');\n};\n\nconst generateStateUniqueType = (state: State, indent: string): string =>\n  getIndexTypePaths(\n    state,\n    Object.values(state.indexes).filter((index) => index.unique),\n  )\n    .map(\n      (fields) =>\n        `{${fields\n          .map(\n            (item) =>\n              `\\n${indent}  ${item.name}: ${generateTypeScalar(item.as)};`,\n          )\n          .join('')}\\n${indent}}`,\n    )\n    .join(' | ');\n\nconst getIndexTypePaths = (\n  state: State,\n  indexes: StateSortingIndex[],\n): ScalarField[][] => {\n  type FieldMap = Map<string, { children: FieldMap; field: ScalarField }>;\n  const fields: FieldMap = new Map();\n\n  for (const index of indexes) {\n    let current = fields;\n\n    for (const key of Object.keys(index.fields)) {\n      let entry = current.get(key);\n      if (!entry) {\n        const field = state.fields[key];\n        if (field?.type !== 'ScalarField') {\n          throw new ParsingError(\n            state.node,\n            `Index field '${key}' not found in state '${state.name}'`,\n          );\n        }\n\n        entry = { children: new Map(), field };\n        current.set(key, entry);\n      }\n\n      current = entry.children;\n    }\n  }\n\n  const result: ScalarField[][] = [];\n\n  const walk = (current: FieldMap, path: ScalarField[]): void => {\n    for (const [, entry] of current) {\n      const newPath = [...path, entry.field];\n\n      if (!entry.children.size) {\n        result.push(newPath);\n        continue;\n      }\n\n      walk(entry.children, newPath);\n    }\n  };\n\n  walk(fields, []);\n\n  return result;\n};\n","import { Parameter } from '@neuledge/states';\nimport { generateTypeType } from './type';\n\nexport const generateParametersType = (\n  parameters: Parameter[],\n  indent: string,\n): string => {\n  if (!parameters.length) {\n    return '{}';\n  }\n\n  return `{\\n${parameters\n    .map((parameter) => generateParameterType(parameter, indent))\n    .join('')}${indent}}`;\n};\n\nconst generateParameterType = (parameter: Parameter, indent: string): string =>\n  `${indent}  ${parameter.name}${\n    parameter.nullable ? '?' : ''\n  }: ${generateTypeType(parameter.as)}${\n    parameter.nullable ? ' | null' : ''\n  };\\n`;\n\nexport const generateParametersArgument = (parameters: Parameter[]): string => {\n  if (!parameters.length) {\n    return '';\n  }\n\n  return `{ ${parameters.map((parameter) => parameter.name).join(', ')} }`;\n};\n","import { Literal, NullLiteral } from '@neuledge/states';\n\nexport const generateLiteral = (literal: Literal): string =>\n  JSON.stringify(literal.value);\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const generateNullLiteral = (literal: NullLiteral): string => 'null';\n","import { BinaryExpression } from '@neuledge/states';\nimport { generateExpression } from './index';\n\nexport const generateBinaryExpression = (\n  expression: BinaryExpression,\n  indent: string,\n): string =>\n  `(${generateExpression(expression.left, indent)} ${\n    expression.operator\n  } ${generateExpression(expression.right, indent)})`;\n","import { Arguments, Expression } from '@neuledge/states';\nimport { generateExpression } from './expression';\n\nexport const generateArguments = (\n  args: Arguments<Expression>,\n  indent: string,\n): string => {\n  const values = Object.values(args);\n\n  if (!values.length) {\n    return '{}';\n  }\n\n  return `{ ${values\n    .map(\n      (arg) =>\n        `${generateArgumentName(arg.name)}: ${generateExpression(\n          arg.value,\n          indent,\n        )}`,\n    )\n    .join(', ')} }`;\n};\n\nconst generateArgumentName = (name: string): string =>\n  /^\\w+$/.test(name) ? name : `'${name.replace(/(['\\\\])/g, '\\\\$1')}'`;\n","import { CallExpression } from '@neuledge/states';\nimport { generateArguments } from '../arguments';\n\nexport const generateCallExpression = (\n  expression: CallExpression,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  indent: string,\n): string =>\n  `await $.runtime.${expression.callee.name}(${generateArguments(\n    expression.arguments,\n    indent,\n  )})`;\n","import { IdentifierExpression } from '@neuledge/states';\n\nexport const generateIdentifierExpression = (\n  expression: IdentifierExpression,\n): string => expression.reference.name;\n","import { LogicalExpression } from '@neuledge/states';\nimport { generateExpression } from './index';\n\nexport const generateLogicalExpression = (\n  expression: LogicalExpression,\n  indent: string,\n): string =>\n  `(${generateExpression(expression.left, indent)} ${\n    expression.operator\n  } ${generateExpression(expression.right, indent)})`;\n","import { MemberExpression, PropertyExpression } from '@neuledge/states';\nimport { generateExpression } from './index';\n\nexport const generateMemberExpression = (\n  expression: MemberExpression,\n  indent: string,\n): string => {\n  const object = generateExpression(expression.object, indent);\n\n  return `${object}${expression.properties\n    .map((p) => generatePropertyExpression(p))\n    .join('')}`;\n};\n\nconst generatePropertyExpression = (expression: PropertyExpression): string =>\n  /^\\w+$/.test(expression.name)\n    ? `.${expression.name}`\n    : `['${expression.name.replace(/(['\\\\])/g, '\\\\$1')}']`;\n","import { ThisExpression } from '@neuledge/states';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const generateThisExpression = (expression: ThisExpression): string =>\n  'this';\n","import { UnaryExpression } from '@neuledge/states';\nimport { generateExpression } from './index';\n\nexport const generateUnaryExpression = (\n  expression: UnaryExpression,\n  indent: string,\n): string =>\n  `${expression.operator}${generateExpression(expression.argument, indent)}`;\n","import { Expression } from '@neuledge/states';\nimport { generateLiteral, generateNullLiteral } from '../literal';\nimport { generateBinaryExpression } from './binary';\nimport { generateCallExpression } from './call';\nimport { generateIdentifierExpression } from './identifier';\nimport { generateLogicalExpression } from './logical';\nimport { generateMemberExpression } from './member';\nimport { generateThisExpression } from './this';\nimport { generateUnaryExpression } from './unary';\n\nexport const generateExpression = (\n  expression: Expression,\n  indent: string,\n): string => {\n  switch (expression.type) {\n    case 'IdentifierExpression': {\n      return generateIdentifierExpression(expression);\n    }\n\n    case 'CallExpression': {\n      return generateCallExpression(expression, indent);\n    }\n\n    case 'ThisExpression': {\n      return generateThisExpression(expression);\n    }\n\n    case 'MemberExpression': {\n      return generateMemberExpression(expression, indent);\n    }\n\n    case 'Literal': {\n      return generateLiteral(expression);\n    }\n\n    case 'UnaryExpression': {\n      return generateUnaryExpression(expression, indent);\n    }\n\n    case 'BinaryExpression': {\n      return generateBinaryExpression(expression, indent);\n    }\n\n    case 'LogicalExpression': {\n      return generateLogicalExpression(expression, indent);\n    }\n\n    case 'NullLiteral': {\n      return generateNullLiteral(expression);\n    }\n\n    default: {\n      // @ts-expect-error `expression` type is never\n      throw new TypeError(`Unexpected expression: ${expression.type}`);\n    }\n  }\n};\n","import { Parameter, Property, State } from '@neuledge/states';\nimport { generateExpression } from './expression';\n\nexport const generateStateFunctionBody = (\n  state: State,\n  parameters: Record<string, Parameter>,\n  properties: Record<string, Property>,\n  extendsThis: boolean,\n  indent: string,\n): string => {\n  let res =\n    `{\\n` +\n    `${indent}  return {\\n` +\n    (extendsThis ? `${indent}    ...this,\\n` : '') +\n    `${indent}    $state: '${state.name}',\\n`;\n\n  if (!extendsThis) {\n    for (const key in state.fields) {\n      if (properties[key] || parameters[key]) continue;\n\n      res += `${indent}    ${key}: null,\\n`;\n    }\n  }\n\n  for (const key in parameters) {\n    if (properties[key] || !state.fields[key]) continue;\n\n    res += `${indent}    ${key},\\n`;\n  }\n\n  for (const key in properties) {\n    const property = properties[key];\n\n    res += `${indent}    ${generateProperty(property, `${indent}    `)},\\n`;\n  }\n\n  res += `${indent}  };\\n${indent}}`;\n\n  return res;\n};\n\nconst generateProperty = (property: Property, indent: string): string => {\n  const value = generateExpression(property.value, indent);\n\n  if (value === property.name) {\n    return property.name;\n  }\n\n  return `${property.name}: ${value}`;\n};\n","import { ParsingError } from '@neuledge/states-parser';\nimport { State, Mutation } from '@neuledge/states';\nimport { generateDescriptionComment } from '../comments';\nimport {\n  generateParametersArgument,\n  generateParametersType,\n} from '../parameters';\nimport { generateStateFunctionBody } from '../property';\n\nexport const generateStateOptionalTransforms = (\n  state: State,\n  indent: string,\n): string | null => {\n  const transforms = Object.values(state.mutations)\n    .filter(\n      (item) => item.mutation === 'update' && item.returns.name !== state.name,\n    )\n    .map((item) => item.returns);\n\n  if (!transforms.length) {\n    return null;\n  }\n\n  if (transforms.length <= 3) {\n    return `() => [${transforms.map((item) => item.name).join(', ')}]`;\n  }\n\n  return `() => [${transforms\n    .map((item) => `\\n${indent}  ${item.name},`)\n    .join('')}\\n${indent}]`;\n};\n\nexport const generateStateMutations = (state: State, indent: string): string =>\n  Object.values(state.mutations)\n    .map(\n      (mutation) =>\n        `\\n${indent}${generateStateMutation(state, mutation, indent)}`,\n    )\n    .join('');\n\nconst generateStateMutation = (\n  state: State,\n  mutation: Mutation,\n  indent: string,\n): string => {\n  let value;\n  switch (mutation.mutation) {\n    case 'create': {\n      value = generateCreateMutationFn(state, mutation, indent);\n      break;\n    }\n\n    case 'update': {\n      value = generateUpdateMutationFn(state, mutation, indent);\n      break;\n    }\n\n    case 'delete': {\n      value = generateDeleteMutationFn(state, mutation, indent);\n      break;\n    }\n\n    default: {\n      throw new ParsingError(\n        mutation.node,\n        `Unknown mutation type: ${mutation.mutation}`,\n      );\n    }\n  }\n\n  return (\n    generateDescriptionComment(mutation, indent) +\n    `static ${mutation.name} = ${value};\\n`\n  );\n};\n\nconst generateCreateMutationFn = (\n  state: State,\n  mutation: Mutation,\n  indent: string,\n): string => {\n  const parameters = Object.values(mutation.parameters);\n\n  if (!parameters.length) {\n    return `$.mutation<typeof ${state.name}>('${\n      mutation.mutation\n    }', async function () ${generateStateFunctionBody(\n      state,\n      mutation.parameters,\n      mutation.body,\n      false,\n      indent,\n    )})`;\n  }\n\n  return (\n    `$.mutation<\\n` +\n    `${indent}  typeof ${state.name},\\n` +\n    `${indent}  ${generateParametersType(parameters, `${indent}  `)}\\n` +\n    `${indent}>('${\n      mutation.mutation\n    }', async function (${generateParametersArgument(\n      parameters,\n    )}) ${generateStateFunctionBody(\n      state,\n      mutation.parameters,\n      mutation.body,\n      false,\n      indent,\n    )})`\n  );\n};\n\nconst generateUpdateMutationFn = (\n  state: State,\n  mutation: Mutation,\n  indent: string,\n): string => {\n  const parameters = Object.values(mutation.parameters);\n\n  if (!parameters.length) {\n    return (\n      `$.mutation<typeof ${state.name}, typeof ${mutation.returns.name}>(\\n` +\n      `${indent}  '${mutation.mutation}',\\n` +\n      `${indent}  async function () ${generateStateFunctionBody(\n        mutation.returns as State,\n        mutation.parameters,\n        mutation.body,\n        true,\n        `${indent}  `,\n      )},\\n` +\n      `${indent})`\n    );\n  }\n\n  return (\n    `$.mutation<\\n` +\n    `${indent}  typeof ${state.name},\\n` +\n    `${indent}  ${generateParametersType(parameters, `${indent}  `)},\\n` +\n    `${indent}  typeof ${mutation.returns.name}\\n` +\n    `${indent}>('${\n      mutation.mutation\n    }', async function (${generateParametersArgument(\n      parameters,\n    )}) ${generateStateFunctionBody(\n      mutation.returns as State,\n      mutation.parameters,\n      mutation.body,\n      true,\n      indent,\n    )})`\n  );\n};\n\nconst generateDeleteMutationFn = (\n  state: State,\n  mutation: Mutation,\n  indent: string,\n): string => {\n  const parameters = Object.values(mutation.parameters);\n  const properties = Object.values(mutation.body);\n\n  if (!properties.length) {\n    return `$.mutation<typeof ${state.name}>('${mutation.mutation}')`;\n  }\n\n  return (\n    `$.mutation<\\n` +\n    `${indent}  typeof ${state.name},\\n` +\n    `${indent}  ${generateParametersType(parameters, `${indent}  `)}\\n` +\n    `${indent}>('${\n      mutation.mutation\n    }', async function (${generateParametersArgument(\n      parameters,\n    )}) ${generateStateFunctionBody(\n      state,\n      mutation.parameters,\n      mutation.body,\n      true,\n      indent,\n    )})`\n  );\n};\n","import { State } from '@neuledge/states';\nimport { generateDescriptionComment } from '../comments';\nimport {\n  generateStateFields,\n  generateStateOptionalRelations,\n  generateStateScalars,\n} from './fields';\nimport {\n  generateStateIdType,\n  generateStateOptionalIndexes,\n  generateStateQueryIndexes,\n} from './indexes';\nimport {\n  generateStateMutations,\n  generateStateOptionalTransforms,\n} from './mutations';\n\nexport const generateState = (state: State): string => {\n  const relations = generateStateOptionalRelations(state, '  ');\n  const transforms = generateStateOptionalTransforms(state, '  ');\n  const indexes = generateStateOptionalIndexes(state, '  ');\n\n  return (\n    generateDescriptionComment(state, '') +\n    `@$.State<'${state.name}', ${state.name}>()\\n` +\n    `export class ${state.name} {\\n` +\n    `  static $name = '${state.name}' as const;\\n` +\n    `  static $id = ${generateStateIdType(state)} as const;\\n` +\n    `  static $scalars = ${generateStateScalars(state, '  ')};\\n` +\n    `  ${generateStateQueryIndexes(state, '  ')}\\n` +\n    (relations ? `  static $relations = ${relations};\\n` : '') +\n    (indexes ? `  static $indexes = ${indexes};\\n` : '') +\n    (transforms ? `  static $transforms = ${transforms};\\n` : '') +\n    `${generateStateFields(state, '  ')}\\n` +\n    generateStateMutations(state, '  ') +\n    `}\\n` +\n    `export type $${state.name} = $.Entity<typeof ${state.name}>;`\n  );\n};\n","import { Entity, StatesContext } from '@neuledge/states';\nimport { generateEither } from './either';\nimport { generateImports } from './imports';\nimport { generateState } from './state';\n\ntype GeneratedCode = {\n  source: string;\n  order: number;\n};\n\nexport const generate = (\n  context: StatesContext,\n  entities: Iterable<Entity> = context.entities(),\n): string => {\n  const res: GeneratedCode[] = [{ source: generateImports(), order: 0 }];\n\n  for (const entity of entities) {\n    switch (entity.type) {\n      case 'Scalar': {\n        // skip built-in scalars\n        if (!entity.node) break;\n\n        // TODO generate scalars code\n        // res.push({ source: generateScalar(entity), order: 1 });\n        break;\n      }\n\n      case 'State': {\n        res.push({ source: generateState(entity), order: 2 });\n        break;\n      }\n\n      case 'Either': {\n        res.push({ source: generateEither(entity), order: 3 });\n        break;\n      }\n\n      case 'Void': {\n        break;\n      }\n\n      default: {\n        // @ts-expect-error `entity.type` is never\n        throw new TypeError(`Unsupported entity type '${entity.type}'`);\n      }\n    }\n  }\n\n  return (\n    res\n      .sort((a, b) => a.order - b.order)\n      .map(({ source }) => source)\n      .join('\\n\\n') + '\\n'\n  );\n};\n"],"mappings":"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","names":["generateDescriptionComment","description","deprecated","indent","deprecationReason","replace","generateEither","either","generateDescriptionComment","generateEitherType","generateEitherConst","name","states","map","state","join","generateImports","generateEntityScalar","entity","type","name","TypeError","generateEntityType","node","generateWhereEntityExpression","list","nullable","nullish","generateWhereScalar","scalar","where","WhereShapeTypeMap","shape","boolean","number","string","binary","json","enum","generateTypeScalar","type","list","generateEntityScalar","entity","TypeError","generateTypeType","generateEntityType","generateStateScalars","state","indent","Object","values","fields","filter","item","type","map","name","generateTypeScalar","as","index","nullable","join","generateStateFields","generateDescriptionComment","generateTypeType","generateStateOptionalRelations","entity","length","generateEntityScalar","list","referenceField","replace","UnaryExpressionNodeOperators","UnaryExpressionNodeOperatorsArray","Object","keys","ParsingError","SyntaxError","name","start","end","path","constructor","position","message","Object","setPrototypeOf","prototype","stack","TokenCharMap","char","tokenize","__name","content","path","values","splitTokenValues","tokens","position","line","column","isComment","lastPunctuation","value","token","parseToken","adjacent","push","type","lines","split","length","includes","match","kind","start","end","Number","parseStringToken","test","raw","slice","trim","replace","TokenCursor","index","constructor","current","next","isMatch","pickKeyword","pick","undefined","consumeKeyword","consume","pickPunctuation","consumePunctuation","expected","createError","ParsingError","maybeConsumeKeyword","maybeConsumePunctuation","maybeConsume","transaction","fn","error","generateStateIdType","state","fields","auto","primaryKey","keys","Object","entries","map","name","dir","join","generateStateQueryIndexes","indent","generateStateWhereType","generateStateUniqueType","generateStateFilterType","generateStateOptionalIndexes","indexes","values","filter","index","length","test","replace","field","sort","unique","type","item","generateWhereEntityExpression","as","nullable","paths","getIndexTypePaths","multiPaths","flatMap","i","slice","generateTypeScalar","Map","current","key","entry","get","ParsingError","node","children","set","result","walk","path","newPath","size","push","generateParametersType","parameters","indent","length","map","parameter","generateParameterType","join","name","nullable","generateTypeType","as","generateParametersArgument","generateLiteral","literal","JSON","stringify","value","generateNullLiteral","generateBinaryExpression","expression","indent","generateExpression","left","operator","right","generateArguments","args","indent","values","Object","length","map","arg","generateArgumentName","name","generateExpression","value","join","test","replace","generateCallExpression","expression","indent","callee","name","generateArguments","arguments","generateIdentifierExpression","expression","reference","name","generateLogicalExpression","expression","indent","generateExpression","left","operator","right","generateMemberExpression","expression","indent","object","generateExpression","properties","map","p","generatePropertyExpression","join","test","name","replace","generateThisExpression","expression","generateUnaryExpression","expression","indent","operator","generateExpression","argument","generateExpression","expression","indent","type","generateIdentifierExpression","generateCallExpression","generateThisExpression","generateMemberExpression","generateLiteral","generateUnaryExpression","generateBinaryExpression","generateLogicalExpression","generateNullLiteral","TypeError","generateStateFunctionBody","state","parameters","properties","extendsThis","indent","res","name","key","fields","property","generateProperty","value","generateExpression","generateStateOptionalTransforms","state","indent","transforms","Object","values","mutations","filter","item","mutation","returns","name","map","length","join","generateStateMutations","generateStateMutation","value","generateCreateMutationFn","generateUpdateMutationFn","generateDeleteMutationFn","ParsingError","node","generateDescriptionComment","parameters","generateStateFunctionBody","body","generateParametersType","generateParametersArgument","properties","generateState","state","relations","generateStateOptionalRelations","transforms","generateStateOptionalTransforms","indexes","generateStateOptionalIndexes","generateDescriptionComment","name","generateStateIdType","generateStateScalars","generateStateQueryIndexes","generateStateFields","generateStateMutations","generate","context","entities","res","source","generateImports","order","entity","type","node","push","generateState","generateEither","TypeError","sort","a","b","map","join"]}